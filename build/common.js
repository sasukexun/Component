/*! This file is created by sasukexun */
/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest() { // eslint-disable-line no-unused-vars
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = 10000;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "ce97f65de71757bb4e78"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest().then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 2;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate).then(function(result) {
/******/ 				deferred.resolve(result);
/******/ 			}, function(err) {
/******/ 				deferred.reject(err);
/******/ 			});
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					dependency = moduleOutdatedDependencies[i];
/******/ 					cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(i = 0; i < callbacks.length; i++) {
/******/ 					cb = callbacks[i];
/******/ 					try {
/******/ 						cb(moduleOutdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "accept-errored",
/******/ 								moduleId: moduleId,
/******/ 								dependencyId: moduleOutdatedDependencies[i],
/******/ 								error: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err;
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "../";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(9)(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ({

/***/ 2:
/***/ (function(module, exports) {

eval("/*!\n * jQuery JavaScript Library v1.3.1\n * http://jquery.com/\n *\n * Copyright (c) 2009 John Resig\n * Dual licensed under the MIT and GPL licenses.\n * http://docs.jquery.com/License\n *\n * Date: 2009-01-21 20:42:16 -0500 (Wed, 21 Jan 2009)\n * Revision: 6158\n */\n(function(){\n\nvar \n\t// Will speed up references to window, and allows munging its name.\n\twindow = this,\n\t// Will speed up references to undefined, and allows munging its name.\n\tundefined,\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\tjQuery = window.jQuery = window.$ = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// A simple way to check for HTML strings or ID strings\n\t// (both of which we optimize for)\n\tquickExpr = /^[^<]*(<(.|\\s)+>)[^>]*$|^#([\\w-]+)$/,\n\t// Is it a simple selector\n\tisSimple = /^.[^:#\\[\\.,]*$/;\n\njQuery.fn = jQuery.prototype = {\n\tinit: function( selector, context ) {\n\t\t// Make sure that a selection was provided\n\t\tselector = selector || document;\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\tthis.context = selector;\n\t\t\treturn this;\n\t\t}\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\t// Are we dealing with HTML string or an ID?\n\t\t\tvar match = quickExpr.exec( selector );\n\n\t\t\t// Verify a match, and that no context was specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] )\n\t\t\t\t\tselector = jQuery.clean( [ match[1] ], context );\n\n\t\t\t\t// HANDLE: $(\"#id\")\n\t\t\t\telse {\n\t\t\t\t\tvar elem = document.getElementById( match[3] );\n\n\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t// by name instead of ID\n\t\t\t\t\tif ( elem && elem.id != match[3] )\n\t\t\t\t\t\treturn jQuery().find( selector );\n\n\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\tvar ret = jQuery( elem || [] );\n\t\t\t\t\tret.context = document;\n\t\t\t\t\tret.selector = selector;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, [context])\n\t\t\t// (which is just equivalent to: $(content).find(expr)\n\t\t\t} else\n\t\t\t\treturn jQuery( context ).find( selector );\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) )\n\t\t\treturn jQuery( document ).ready( selector );\n\n\t\t// Make sure that old selector state is passed along\n\t\tif ( selector.selector && selector.context ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn this.setArray(jQuery.makeArray(selector));\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The current version of jQuery being used\n\tjquery: \"1.3.1\",\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num === undefined ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tjQuery.makeArray( this ) :\n\n\t\t\t// Return just the object\n\t\t\tthis[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems, name, selector ) {\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery( elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\tret.context = this.context;\n\n\t\tif ( name === \"find\" )\n\t\t\tret.selector = this.selector + (this.selector ? \" \" : \"\") + selector;\n\t\telse if ( name )\n\t\t\tret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Force the current matched set of elements to become\n\t// the specified array of elements (destroying the stack in the process)\n\t// You should use pushStack() in order to do this, but maintain the stack\n\tsetArray: function( elems ) {\n\t\t// Resetting the length to 0, then using the native Array push\n\t\t// is a super-fast way to populate an object with array-like properties\n\t\tthis.length = 0;\n\t\tArray.prototype.push.apply( this, elems );\n\n\t\treturn this;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem && elem.jquery ? elem[0] : elem\n\t\t, this );\n\t},\n\n\tattr: function( name, value, type ) {\n\t\tvar options = name;\n\n\t\t// Look for the case where we're accessing a style value\n\t\tif ( typeof name === \"string\" )\n\t\t\tif ( value === undefined )\n\t\t\t\treturn this[0] && jQuery[ type || \"attr\" ]( this[0], name );\n\n\t\t\telse {\n\t\t\t\toptions = {};\n\t\t\t\toptions[ name ] = value;\n\t\t\t}\n\n\t\t// Check to see if we're setting style values\n\t\treturn this.each(function(i){\n\t\t\t// Set all the styles\n\t\t\tfor ( name in options )\n\t\t\t\tjQuery.attr(\n\t\t\t\t\ttype ?\n\t\t\t\t\t\tthis.style :\n\t\t\t\t\t\tthis,\n\t\t\t\t\tname, jQuery.prop( this, options[ name ], type, i, name )\n\t\t\t\t);\n\t\t});\n\t},\n\n\tcss: function( key, value ) {\n\t\t// ignore negative width and height values\n\t\tif ( (key == 'width' || key == 'height') && parseFloat(value) < 0 )\n\t\t\tvalue = undefined;\n\t\treturn this.attr( key, value, \"curCSS\" );\n\t},\n\n\ttext: function( text ) {\n\t\tif ( typeof text !== \"object\" && text != null )\n\t\t\treturn this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );\n\n\t\tvar ret = \"\";\n\n\t\tjQuery.each( text || this, function(){\n\t\t\tjQuery.each( this.childNodes, function(){\n\t\t\t\tif ( this.nodeType != 8 )\n\t\t\t\t\tret += this.nodeType != 1 ?\n\t\t\t\t\t\tthis.nodeValue :\n\t\t\t\t\t\tjQuery.fn.text( [ this ] );\n\t\t\t});\n\t\t});\n\n\t\treturn ret;\n\t},\n\n\twrapAll: function( html ) {\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).clone();\n\n\t\t\tif ( this[0].parentNode )\n\t\t\t\twrap.insertBefore( this[0] );\n\n\t\t\twrap.map(function(){\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild )\n\t\t\t\t\telem = elem.firstChild;\n\n\t\t\t\treturn elem;\n\t\t\t}).append(this);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\treturn this.each(function(){\n\t\t\tjQuery( this ).contents().wrapAll( html );\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\treturn this.each(function(){\n\t\t\tjQuery( this ).wrapAll( html );\n\t\t});\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip(arguments, true, function(elem){\n\t\t\tif (this.nodeType == 1)\n\t\t\t\tthis.appendChild( elem );\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip(arguments, true, function(elem){\n\t\t\tif (this.nodeType == 1)\n\t\t\t\tthis.insertBefore( elem, this.firstChild );\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip(arguments, false, function(elem){\n\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip(arguments, false, function(elem){\n\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t});\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || jQuery( [] );\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's .push method, not like a jQuery method.\n\tpush: [].push,\n\n\tfind: function( selector ) {\n\t\tif ( this.length === 1 && !/,/.test(selector) ) {\n\t\t\tvar ret = this.pushStack( [], \"find\", selector );\n\t\t\tret.length = 0;\n\t\t\tjQuery.find( selector, this[0], ret );\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tvar elems = jQuery.map(this, function(elem){\n\t\t\t\treturn jQuery.find( selector, elem );\n\t\t\t});\n\n\t\t\treturn this.pushStack( /[^+>] [^+>]/.test( selector ) ?\n\t\t\t\tjQuery.unique( elems ) :\n\t\t\t\telems, \"find\", selector );\n\t\t}\n\t},\n\n\tclone: function( events ) {\n\t\t// Do the clone\n\t\tvar ret = this.map(function(){\n\t\t\tif ( !jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this) ) {\n\t\t\t\t// IE copies events bound via attachEvent when\n\t\t\t\t// using cloneNode. Calling detachEvent on the\n\t\t\t\t// clone will also remove the events from the orignal\n\t\t\t\t// In order to get around this, we use innerHTML.\n\t\t\t\t// Unfortunately, this means some modifications to\n\t\t\t\t// attributes in IE that are actually only stored\n\t\t\t\t// as properties will not be copied (such as the\n\t\t\t\t// the name attribute on an input).\n\t\t\t\tvar clone = this.cloneNode(true),\n\t\t\t\t\tcontainer = document.createElement(\"div\");\n\t\t\t\tcontainer.appendChild(clone);\n\t\t\t\treturn jQuery.clean([container.innerHTML])[0];\n\t\t\t} else\n\t\t\t\treturn this.cloneNode(true);\n\t\t});\n\n\t\t// Need to set the expando to null on the cloned set if it exists\n\t\t// removeData doesn't work here, IE removes it from the original as well\n\t\t// this is primarily for IE but the data expando shouldn't be copied over in any browser\n\t\tvar clone = ret.find(\"*\").andSelf().each(function(){\n\t\t\tif ( this[ expando ] !== undefined )\n\t\t\t\tthis[ expando ] = null;\n\t\t});\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( events === true )\n\t\t\tthis.find(\"*\").andSelf().each(function(i){\n\t\t\t\tif (this.nodeType == 3)\n\t\t\t\t\treturn;\n\t\t\t\tvar events = jQuery.data( this, \"events\" );\n\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tfor ( var handler in events[ type ] )\n\t\t\t\t\t\tjQuery.event.add( clone[ i ], type, events[ type ][ handler ], events[ type ][ handler ].data );\n\t\t\t});\n\n\t\t// Return the cloned set\n\t\treturn ret;\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.isFunction( selector ) &&\n\t\t\tjQuery.grep(this, function(elem, i){\n\t\t\t\treturn selector.call( elem, i );\n\t\t\t}) ||\n\n\t\t\tjQuery.multiFilter( selector, jQuery.grep(this, function(elem){\n\t\t\t\treturn elem.nodeType === 1;\n\t\t\t}) ), \"filter\", selector );\n\t},\n\n\tclosest: function( selector ) {\n\t\tvar pos = jQuery.expr.match.POS.test( selector ) ? jQuery(selector) : null;\n\n\t\treturn this.map(function(){\n\t\t\tvar cur = this;\n\t\t\twhile ( cur && cur.ownerDocument ) {\n\t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery(cur).is(selector) )\n\t\t\t\t\treturn cur;\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\tif ( typeof selector === \"string\" )\n\t\t\t// test special case where just one selector is passed in\n\t\t\tif ( isSimple.test( selector ) )\n\t\t\t\treturn this.pushStack( jQuery.multiFilter( selector, this, true ), \"not\", selector );\n\t\t\telse\n\t\t\t\tselector = jQuery.multiFilter( selector, this );\n\n\t\tvar isArrayLike = selector.length && selector[selector.length - 1] !== undefined && !selector.nodeType;\n\t\treturn this.filter(function() {\n\t\t\treturn isArrayLike ? jQuery.inArray( this, selector ) < 0 : this != selector;\n\t\t});\n\t},\n\n\tadd: function( selector ) {\n\t\treturn this.pushStack( jQuery.unique( jQuery.merge(\n\t\t\tthis.get(),\n\t\t\ttypeof selector === \"string\" ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tjQuery.makeArray( selector )\n\t\t)));\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!selector && jQuery.multiFilter( selector, this ).length > 0;\n\t},\n\n\thasClass: function( selector ) {\n\t\treturn !!selector && this.is( \".\" + selector );\n\t},\n\n\tval: function( value ) {\n\t\tif ( value === undefined ) {\t\t\t\n\t\t\tvar elem = this[0];\n\n\t\t\tif ( elem ) {\n\t\t\t\tif( jQuery.nodeName( elem, 'option' ) )\n\t\t\t\t\treturn (elem.attributes.value || {}).specified ? elem.value : elem.text;\n\t\t\t\t\n\t\t\t\t// We need to handle select boxes special\n\t\t\t\tif ( jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\t\tvar index = elem.selectedIndex,\n\t\t\t\t\t\tvalues = [],\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tone = elem.type == \"select-one\";\n\n\t\t\t\t\t// Nothing was selected\n\t\t\t\t\tif ( index < 0 )\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {\n\t\t\t\t\t\tvar option = options[ i ];\n\n\t\t\t\t\t\tif ( option.selected ) {\n\t\t\t\t\t\t\t// Get the specifc value for the option\n\t\t\t\t\t\t\tvalue = jQuery(option).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one )\n\t\t\t\t\t\t\t\treturn value;\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// Everything else, we just grab the value\n\t\t\t\treturn (elem.value || \"\").replace(/\\r/g, \"\");\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif ( typeof value === \"number\" )\n\t\t\tvalue += '';\n\n\t\treturn this.each(function(){\n\t\t\tif ( this.nodeType != 1 )\n\t\t\t\treturn;\n\n\t\t\tif ( jQuery.isArray(value) && /radio|checkbox/.test( this.type ) )\n\t\t\t\tthis.checked = (jQuery.inArray(this.value, value) >= 0 ||\n\t\t\t\t\tjQuery.inArray(this.name, value) >= 0);\n\n\t\t\telse if ( jQuery.nodeName( this, \"select\" ) ) {\n\t\t\t\tvar values = jQuery.makeArray(value);\n\n\t\t\t\tjQuery( \"option\", this ).each(function(){\n\t\t\t\t\tthis.selected = (jQuery.inArray( this.value, values ) >= 0 ||\n\t\t\t\t\t\tjQuery.inArray( this.text, values ) >= 0);\n\t\t\t\t});\n\n\t\t\t\tif ( !values.length )\n\t\t\t\t\tthis.selectedIndex = -1;\n\n\t\t\t} else\n\t\t\t\tthis.value = value;\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn value === undefined ?\n\t\t\t(this[0] ?\n\t\t\t\tthis[0].innerHTML :\n\t\t\t\tnull) :\n\t\t\tthis.empty().append( value );\n\t},\n\n\treplaceWith: function( value ) {\n\t\treturn this.after( value ).remove();\n\t},\n\n\teq: function( i ) {\n\t\treturn this.slice( i, +i + 1 );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( Array.prototype.slice.apply( this, arguments ),\n\t\t\t\"slice\", Array.prototype.slice.call(arguments).join(\",\") );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function(elem, i){\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tandSelf: function() {\n\t\treturn this.add( this.prevObject );\n\t},\n\n\tdomManip: function( args, table, callback ) {\n\t\tif ( this[0] ) {\n\t\t\tvar fragment = (this[0].ownerDocument || this[0]).createDocumentFragment(),\n\t\t\t\tscripts = jQuery.clean( args, (this[0].ownerDocument || this[0]), fragment ),\n\t\t\t\tfirst = fragment.firstChild,\n\t\t\t\textra = this.length > 1 ? fragment.cloneNode(true) : fragment;\n\n\t\t\tif ( first )\n\t\t\t\tfor ( var i = 0, l = this.length; i < l; i++ )\n\t\t\t\t\tcallback.call( root(this[i], first), i > 0 ? extra.cloneNode(true) : fragment );\n\t\t\t\n\t\t\tif ( scripts )\n\t\t\t\tjQuery.each( scripts, evalScript );\n\t\t}\n\n\t\treturn this;\n\t\t\n\t\tfunction root( elem, cur ) {\n\t\t\treturn table && jQuery.nodeName(elem, \"table\") && jQuery.nodeName(cur, \"tr\") ?\n\t\t\t\t(elem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\t\telem.appendChild(elem.ownerDocument.createElement(\"tbody\"))) :\n\t\t\t\telem;\n\t\t}\n\t}\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\nfunction evalScript( i, elem ) {\n\tif ( elem.src )\n\t\tjQuery.ajax({\n\t\t\turl: elem.src,\n\t\t\tasync: false,\n\t\t\tdataType: \"script\"\n\t\t});\n\n\telse\n\t\tjQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || \"\" );\n\n\tif ( elem.parentNode )\n\t\telem.parentNode.removeChild( elem );\n}\n\nfunction now(){\n\treturn +new Date;\n}\n\njQuery.extend = jQuery.fn.extend = function() {\n\t// copy reference to target object\n\tvar target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) )\n\t\ttarget = {};\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length == i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ )\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null )\n\t\t\t// Extend the base object\n\t\t\tfor ( var name in options ) {\n\t\t\t\tvar src = target[ name ], copy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Recurse if we're merging object values\n\t\t\t\tif ( deep && copy && typeof copy === \"object\" && !copy.nodeType )\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, \n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsrc || ( copy.length != null ? [ ] : { } )\n\t\t\t\t\t, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\telse if ( copy !== undefined )\n\t\t\t\t\ttarget[ name ] = copy;\n\n\t\t\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n// exclude the following css properties to add px\nvar\texclude = /z-?index|font-?weight|opacity|zoom|line-?height/i,\n\t// cache defaultView\n\tdefaultView = document.defaultView || {},\n\ttoString = Object.prototype.toString;\n\njQuery.extend({\n\tnoConflict: function( deep ) {\n\t\twindow.$ = _$;\n\n\t\tif ( deep )\n\t\t\twindow.jQuery = _jQuery;\n\n\t\treturn jQuery;\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn toString.call(obj) === \"[object Function]\";\n\t},\n\n\tisArray: function( obj ) {\n\t\treturn toString.call(obj) === \"[object Array]\";\n\t},\n\n\t// check if an element is in a (or is an) XML document\n\tisXMLDoc: function( elem ) {\n\t\treturn elem.nodeType === 9 && elem.documentElement.nodeName !== \"HTML\" ||\n\t\t\t!!elem.ownerDocument && jQuery.isXMLDoc( elem.ownerDocument );\n\t},\n\n\t// Evalulates a script in a global context\n\tglobalEval: function( data ) {\n\t\tdata = jQuery.trim( data );\n\n\t\tif ( data ) {\n\t\t\t// Inspired by code by Andrea Giammarchi\n\t\t\t// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0] || document.documentElement,\n\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\tscript.type = \"text/javascript\";\n\t\t\tif ( jQuery.support.scriptEval )\n\t\t\t\tscript.appendChild( document.createTextNode( data ) );\n\t\t\telse\n\t\t\t\tscript.text = data;\n\n\t\t\t// Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n\t\t\t// This arises when a base node is used (#2709).\n\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\thead.removeChild( script );\n\t\t}\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toUpperCase() == name.toUpperCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( object, callback, args ) {\n\t\tvar name, i = 0, length = object.length;\n\n\t\tif ( args ) {\n\t\t\tif ( length === undefined ) {\n\t\t\t\tfor ( name in object )\n\t\t\t\t\tif ( callback.apply( object[ name ], args ) === false )\n\t\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tfor ( ; i < length; )\n\t\t\t\t\tif ( callback.apply( object[ i++ ], args ) === false )\n\t\t\t\t\t\tbreak;\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( length === undefined ) {\n\t\t\t\tfor ( name in object )\n\t\t\t\t\tif ( callback.call( object[ name ], name, object[ name ] ) === false )\n\t\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tfor ( var value = object[0];\n\t\t\t\t\ti < length && callback.call( value, i, value ) !== false; value = object[++i] ){}\n\t\t}\n\n\t\treturn object;\n\t},\n\n\tprop: function( elem, value, type, i, name ) {\n\t\t// Handle executable functions\n\t\tif ( jQuery.isFunction( value ) )\n\t\t\tvalue = value.call( elem, i );\n\n\t\t// Handle passing in a number to a CSS property\n\t\treturn typeof value === \"number\" && type == \"curCSS\" && !exclude.test( name ) ?\n\t\t\tvalue + \"px\" :\n\t\t\tvalue;\n\t},\n\n\tclassName: {\n\t\t// internal only, use addClass(\"class\")\n\t\tadd: function( elem, classNames ) {\n\t\t\tjQuery.each((classNames || \"\").split(/\\s+/), function(i, className){\n\t\t\t\tif ( elem.nodeType == 1 && !jQuery.className.has( elem.className, className ) )\n\t\t\t\t\telem.className += (elem.className ? \" \" : \"\") + className;\n\t\t\t});\n\t\t},\n\n\t\t// internal only, use removeClass(\"class\")\n\t\tremove: function( elem, classNames ) {\n\t\t\tif (elem.nodeType == 1)\n\t\t\t\telem.className = classNames !== undefined ?\n\t\t\t\t\tjQuery.grep(elem.className.split(/\\s+/), function(className){\n\t\t\t\t\t\treturn !jQuery.className.has( classNames, className );\n\t\t\t\t\t}).join(\" \") :\n\t\t\t\t\t\"\";\n\t\t},\n\n\t\t// internal only, use hasClass(\"class\")\n\t\thas: function( elem, className ) {\n\t\t\treturn elem && jQuery.inArray( className, (elem.className || elem).toString().split(/\\s+/) ) > -1;\n\t\t}\n\t},\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\tswap: function( elem, options, callback ) {\n\t\tvar old = {};\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( var name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tcallback.call( elem );\n\n\t\t// Revert the old values\n\t\tfor ( var name in options )\n\t\t\telem.style[ name ] = old[ name ];\n\t},\n\n\tcss: function( elem, name, force ) {\n\t\tif ( name == \"width\" || name == \"height\" ) {\n\t\t\tvar val, props = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, which = name == \"width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ];\n\n\t\t\tfunction getWH() {\n\t\t\t\tval = name == \"width\" ? elem.offsetWidth : elem.offsetHeight;\n\t\t\t\tvar padding = 0, border = 0;\n\t\t\t\tjQuery.each( which, function() {\n\t\t\t\t\tpadding += parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0;\n\t\t\t\t\tborder += parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0;\n\t\t\t\t});\n\t\t\t\tval -= Math.round(padding + border);\n\t\t\t}\n\n\t\t\tif ( jQuery(elem).is(\":visible\") )\n\t\t\t\tgetWH();\n\t\t\telse\n\t\t\t\tjQuery.swap( elem, props, getWH );\n\n\t\t\treturn Math.max(0, val);\n\t\t}\n\n\t\treturn jQuery.curCSS( elem, name, force );\n\t},\n\n\tcurCSS: function( elem, name, force ) {\n\t\tvar ret, style = elem.style;\n\n\t\t// We need to handle opacity special in IE\n\t\tif ( name == \"opacity\" && !jQuery.support.opacity ) {\n\t\t\tret = jQuery.attr( style, \"opacity\" );\n\n\t\t\treturn ret == \"\" ?\n\t\t\t\t\"1\" :\n\t\t\t\tret;\n\t\t}\n\n\t\t// Make sure we're using the right name for getting the float value\n\t\tif ( name.match( /float/i ) )\n\t\t\tname = styleFloat;\n\n\t\tif ( !force && style && style[ name ] )\n\t\t\tret = style[ name ];\n\n\t\telse if ( defaultView.getComputedStyle ) {\n\n\t\t\t// Only \"float\" is needed here\n\t\t\tif ( name.match( /float/i ) )\n\t\t\t\tname = \"float\";\n\n\t\t\tname = name.replace( /([A-Z])/g, \"-$1\" ).toLowerCase();\n\n\t\t\tvar computedStyle = defaultView.getComputedStyle( elem, null );\n\n\t\t\tif ( computedStyle )\n\t\t\t\tret = computedStyle.getPropertyValue( name );\n\n\t\t\t// We should always get a number back from opacity\n\t\t\tif ( name == \"opacity\" && ret == \"\" )\n\t\t\t\tret = \"1\";\n\n\t\t} else if ( elem.currentStyle ) {\n\t\t\tvar camelCase = name.replace(/\\-(\\w)/g, function(all, letter){\n\t\t\t\treturn letter.toUpperCase();\n\t\t\t});\n\n\t\t\tret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];\n\n\t\t\t// From the awesome hack by Dean Edwards\n\t\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t\t// If we're not dealing with a regular pixel number\n\t\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t\tif ( !/^\\d+(px)?$/i.test( ret ) && /^\\d/.test( ret ) ) {\n\t\t\t\t// Remember the original values\n\t\t\t\tvar left = style.left, rsLeft = elem.runtimeStyle.left;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\t\tstyle.left = ret || 0;\n\t\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.left = left;\n\t\t\t\telem.runtimeStyle.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tclean: function( elems, context, fragment ) {\n\t\tcontext = context || document;\n\n\t\t// !context.createElement fails in IE with an error but returns typeof 'object'\n\t\tif ( typeof context.createElement === \"undefined\" )\n\t\t\tcontext = context.ownerDocument || context[0] && context[0].ownerDocument || document;\n\n\t\t// If a single string is passed in and it's a single tag\n\t\t// just do a createElement and skip the rest\n\t\tif ( !fragment && elems.length === 1 && typeof elems[0] === \"string\" ) {\n\t\t\tvar match = /^<(\\w+)\\s*\\/?>$/.exec(elems[0]);\n\t\t\tif ( match )\n\t\t\t\treturn [ context.createElement( match[1] ) ];\n\t\t}\n\n\t\tvar ret = [], scripts = [], div = context.createElement(\"div\");\n\n\t\tjQuery.each(elems, function(i, elem){\n\t\t\tif ( typeof elem === \"number\" )\n\t\t\t\telem += '';\n\n\t\t\tif ( !elem )\n\t\t\t\treturn;\n\n\t\t\t// Convert html string into DOM nodes\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\t\t\telem = elem.replace(/(<(\\w+)[^>]*?)\\/>/g, function(all, front, tag){\n\t\t\t\t\treturn tag.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i) ?\n\t\t\t\t\t\tall :\n\t\t\t\t\t\tfront + \"></\" + tag + \">\";\n\t\t\t\t});\n\n\t\t\t\t// Trim whitespace, otherwise indexOf won't work as expected\n\t\t\t\tvar tags = jQuery.trim( elem ).toLowerCase();\n\n\t\t\t\tvar wrap =\n\t\t\t\t\t// option or optgroup\n\t\t\t\t\t!tags.indexOf(\"<opt\") &&\n\t\t\t\t\t[ 1, \"<select multiple='multiple'>\", \"</select>\" ] ||\n\n\t\t\t\t\t!tags.indexOf(\"<leg\") &&\n\t\t\t\t\t[ 1, \"<fieldset>\", \"</fieldset>\" ] ||\n\n\t\t\t\t\ttags.match(/^<(thead|tbody|tfoot|colg|cap)/) &&\n\t\t\t\t\t[ 1, \"<table>\", \"</table>\" ] ||\n\n\t\t\t\t\t!tags.indexOf(\"<tr\") &&\n\t\t\t\t\t[ 2, \"<table><tbody>\", \"</tbody></table>\" ] ||\n\n\t\t\t\t \t// <thead> matched above\n\t\t\t\t\t(!tags.indexOf(\"<td\") || !tags.indexOf(\"<th\")) &&\n\t\t\t\t\t[ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ] ||\n\n\t\t\t\t\t!tags.indexOf(\"<col\") &&\n\t\t\t\t\t[ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ] ||\n\n\t\t\t\t\t// IE can't serialize <link> and <script> tags normally\n\t\t\t\t\t!jQuery.support.htmlSerialize &&\n\t\t\t\t\t[ 1, \"div<div>\", \"</div>\" ] ||\n\n\t\t\t\t\t[ 0, \"\", \"\" ];\n\n\t\t\t\t// Go to html and back, then peel off extra wrappers\n\t\t\t\tdiv.innerHTML = wrap[1] + elem + wrap[2];\n\n\t\t\t\t// Move to the right depth\n\t\t\t\twhile ( wrap[0]-- )\n\t\t\t\t\tdiv = div.lastChild;\n\n\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\tif ( !jQuery.support.tbody ) {\n\n\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\tvar tbody = !tags.indexOf(\"<table\") && tags.indexOf(\"<tbody\") < 0 ?\n\t\t\t\t\t\tdiv.firstChild && div.firstChild.childNodes :\n\n\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\twrap[1] == \"<table>\" && tags.indexOf(\"<tbody\") < 0 ?\n\t\t\t\t\t\t\tdiv.childNodes :\n\t\t\t\t\t\t\t[];\n\n\t\t\t\t\tfor ( var j = tbody.length - 1; j >= 0 ; --j )\n\t\t\t\t\t\tif ( jQuery.nodeName( tbody[ j ], \"tbody\" ) && !tbody[ j ].childNodes.length )\n\t\t\t\t\t\t\ttbody[ j ].parentNode.removeChild( tbody[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t// IE completely kills leading whitespace when innerHTML is used\n\t\t\t\tif ( !jQuery.support.leadingWhitespace && /^\\s/.test( elem ) )\n\t\t\t\t\tdiv.insertBefore( context.createTextNode( elem.match(/^\\s*/)[0] ), div.firstChild );\n\t\t\t\t\n\t\t\t\telem = jQuery.makeArray( div.childNodes );\n\t\t\t}\n\n\t\t\tif ( elem.nodeType )\n\t\t\t\tret.push( elem );\n\t\t\telse\n\t\t\t\tret = jQuery.merge( ret, elem );\n\n\t\t});\n\n\t\tif ( fragment ) {\n\t\t\tfor ( var i = 0; ret[i]; i++ ) {\n\t\t\t\tif ( jQuery.nodeName( ret[i], \"script\" ) && (!ret[i].type || ret[i].type.toLowerCase() === \"text/javascript\") ) {\n\t\t\t\t\tscripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );\n\t\t\t\t} else {\n\t\t\t\t\tif ( ret[i].nodeType === 1 )\n\t\t\t\t\t\tret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName(\"script\"))) );\n\t\t\t\t\tfragment.appendChild( ret[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn scripts;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tattr: function( elem, name, value ) {\n\t\t// don't set attributes on text and comment nodes\n\t\tif (!elem || elem.nodeType == 3 || elem.nodeType == 8)\n\t\t\treturn undefined;\n\n\t\tvar notxml = !jQuery.isXMLDoc( elem ),\n\t\t\t// Whether we are setting (or getting)\n\t\t\tset = value !== undefined;\n\n\t\t// Try to normalize/fix the name\n\t\tname = notxml && jQuery.props[ name ] || name;\n\n\t\t// Only do all the following if this is a node (faster for style)\n\t\t// IE elem.getAttribute passes even for style\n\t\tif ( elem.tagName ) {\n\n\t\t\t// These attributes require special treatment\n\t\t\tvar special = /href|src|style/.test( name );\n\n\t\t\t// Safari mis-reports the default selected property of a hidden option\n\t\t\t// Accessing the parent's selectedIndex property fixes it\n\t\t\tif ( name == \"selected\" && elem.parentNode )\n\t\t\t\telem.parentNode.selectedIndex;\n\n\t\t\t// If applicable, access the attribute via the DOM 0 way\n\t\t\tif ( name in elem && notxml && !special ) {\n\t\t\t\tif ( set ){\n\t\t\t\t\t// We can't allow the type property to be changed (since it causes problems in IE)\n\t\t\t\t\tif ( name == \"type\" && jQuery.nodeName( elem, \"input\" ) && elem.parentNode )\n\t\t\t\t\t\tthrow \"type property can't be changed\";\n\n\t\t\t\t\telem[ name ] = value;\n\t\t\t\t}\n\n\t\t\t\t// browsers index elements by id/name on forms, give priority to attributes.\n\t\t\t\tif( jQuery.nodeName( elem, \"form\" ) && elem.getAttributeNode(name) )\n\t\t\t\t\treturn elem.getAttributeNode( name ).nodeValue;\n\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\tif ( name == \"tabIndex\" ) {\n\t\t\t\t\tvar attributeNode = elem.getAttributeNode( \"tabIndex\" );\n\t\t\t\t\treturn attributeNode && attributeNode.specified\n\t\t\t\t\t\t? attributeNode.value\n\t\t\t\t\t\t: elem.nodeName.match(/(button|input|object|select|textarea)/i)\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: elem.nodeName.match(/^(a|area)$/i) && elem.href\n\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t: undefined;\n\t\t\t\t}\n\n\t\t\t\treturn elem[ name ];\n\t\t\t}\n\n\t\t\tif ( !jQuery.support.style && notxml &&  name == \"style\" )\n\t\t\t\treturn jQuery.attr( elem.style, \"cssText\", value );\n\n\t\t\tif ( set )\n\t\t\t\t// convert the value to a string (all browsers do this but IE) see #1070\n\t\t\t\telem.setAttribute( name, \"\" + value );\n\n\t\t\tvar attr = !jQuery.support.hrefNormalized && notxml && special\n\t\t\t\t\t// Some attributes require a special call on IE\n\t\t\t\t\t? elem.getAttribute( name, 2 )\n\t\t\t\t\t: elem.getAttribute( name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn attr === null ? undefined : attr;\n\t\t}\n\n\t\t// elem is actually elem.style ... set the style\n\n\t\t// IE uses filters for opacity\n\t\tif ( !jQuery.support.opacity && name == \"opacity\" ) {\n\t\t\tif ( set ) {\n\t\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t\t// Force it by setting the zoom level\n\t\t\t\telem.zoom = 1;\n\n\t\t\t\t// Set the alpha filter to set the opacity\n\t\t\t\telem.filter = (elem.filter || \"\").replace( /alpha\\([^)]*\\)/, \"\" ) +\n\t\t\t\t\t(parseInt( value ) + '' == \"NaN\" ? \"\" : \"alpha(opacity=\" + value * 100 + \")\");\n\t\t\t}\n\n\t\t\treturn elem.filter && elem.filter.indexOf(\"opacity=\") >= 0 ?\n\t\t\t\t(parseFloat( elem.filter.match(/opacity=([^)]*)/)[1] ) / 100) + '':\n\t\t\t\t\"\";\n\t\t}\n\n\t\tname = name.replace(/-([a-z])/ig, function(all, letter){\n\t\t\treturn letter.toUpperCase();\n\t\t});\n\n\t\tif ( set )\n\t\t\telem[ name ] = value;\n\n\t\treturn elem[ name ];\n\t},\n\n\ttrim: function( text ) {\n\t\treturn (text || \"\").replace( /^\\s+|\\s+$/g, \"\" );\n\t},\n\n\tmakeArray: function( array ) {\n\t\tvar ret = [];\n\n\t\tif( array != null ){\n\t\t\tvar i = array.length;\n\t\t\t// The window, strings (and functions) also have 'length'\n\t\t\tif( i == null || typeof array === \"string\" || jQuery.isFunction(array) || array.setInterval )\n\t\t\t\tret[0] = array;\n\t\t\telse\n\t\t\t\twhile( i )\n\t\t\t\t\tret[--i] = array[i];\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, array ) {\n\t\tfor ( var i = 0, length = array.length; i < length; i++ )\n\t\t// Use === because on IE, window == document\n\t\t\tif ( array[ i ] === elem )\n\t\t\t\treturn i;\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\t// We have to loop this way because IE & Opera overwrite the length\n\t\t// expando of getElementsByTagName\n\t\tvar i = 0, elem, pos = first.length;\n\t\t// Also, we need to make sure that the correct elements are being returned\n\t\t// (IE returns comment nodes in a '*' query)\n\t\tif ( !jQuery.support.getAll ) {\n\t\t\twhile ( (elem = second[ i++ ]) != null )\n\t\t\t\tif ( elem.nodeType != 8 )\n\t\t\t\t\tfirst[ pos++ ] = elem;\n\n\t\t} else\n\t\t\twhile ( (elem = second[ i++ ]) != null )\n\t\t\t\tfirst[ pos++ ] = elem;\n\n\t\treturn first;\n\t},\n\n\tunique: function( array ) {\n\t\tvar ret = [], done = {};\n\n\t\ttry {\n\n\t\t\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\t\t\tvar id = jQuery.data( array[ i ] );\n\n\t\t\t\tif ( !done[ id ] ) {\n\t\t\t\t\tdone[ id ] = true;\n\t\t\t\t\tret.push( array[ i ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch( e ) {\n\t\t\tret = array;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar ret = [];\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ )\n\t\t\tif ( !inv != !callback( elems[ i ], i ) )\n\t\t\t\tret.push( elems[ i ] );\n\n\t\treturn ret;\n\t},\n\n\tmap: function( elems, callback ) {\n\t\tvar ret = [];\n\n\t\t// Go through the array, translating each of the items to their\n\t\t// new value (or values).\n\t\tfor ( var i = 0, length = elems.length; i < length; i++ ) {\n\t\t\tvar value = callback( elems[ i ], i );\n\n\t\t\tif ( value != null )\n\t\t\t\tret[ ret.length ] = value;\n\t\t}\n\n\t\treturn ret.concat.apply( [], ret );\n\t}\n});\n\n// Use of jQuery.browser is deprecated.\n// It's included for backwards compatibility and plugins,\n// although they should work to migrate away.\n\nvar userAgent = navigator.userAgent.toLowerCase();\n\n// Figure out what browser is being used\njQuery.browser = {\n\tversion: (userAgent.match( /.+(?:rv|it|ra|ie)[\\/: ]([\\d.]+)/ ) || [0,'0'])[1],\n\tsafari: /webkit/.test( userAgent ),\n\topera: /opera/.test( userAgent ),\n\tmsie: /msie/.test( userAgent ) && !/opera/.test( userAgent ),\n\tmozilla: /mozilla/.test( userAgent ) && !/(compatible|webkit)/.test( userAgent )\n};\n\njQuery.each({\n\tparent: function(elem){return elem.parentNode;},\n\tparents: function(elem){return jQuery.dir(elem,\"parentNode\");},\n\tnext: function(elem){return jQuery.nth(elem,2,\"nextSibling\");},\n\tprev: function(elem){return jQuery.nth(elem,2,\"previousSibling\");},\n\tnextAll: function(elem){return jQuery.dir(elem,\"nextSibling\");},\n\tprevAll: function(elem){return jQuery.dir(elem,\"previousSibling\");},\n\tsiblings: function(elem){return jQuery.sibling(elem.parentNode.firstChild,elem);},\n\tchildren: function(elem){return jQuery.sibling(elem.firstChild);},\n\tcontents: function(elem){return jQuery.nodeName(elem,\"iframe\")?elem.contentDocument||elem.contentWindow.document:jQuery.makeArray(elem.childNodes);}\n}, function(name, fn){\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar ret = jQuery.map( this, fn );\n\n\t\tif ( selector && typeof selector == \"string\" )\n\t\t\tret = jQuery.multiFilter( selector, ret );\n\n\t\treturn this.pushStack( jQuery.unique( ret ), name, selector );\n\t};\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function(name, original){\n\tjQuery.fn[ name ] = function() {\n\t\tvar args = arguments;\n\n\t\treturn this.each(function(){\n\t\t\tfor ( var i = 0, length = args.length; i < length; i++ )\n\t\t\t\tjQuery( args[ i ] )[ original ]( this );\n\t\t});\n\t};\n});\n\njQuery.each({\n\tremoveAttr: function( name ) {\n\t\tjQuery.attr( this, name, \"\" );\n\t\tif (this.nodeType == 1)\n\t\t\tthis.removeAttribute( name );\n\t},\n\n\taddClass: function( classNames ) {\n\t\tjQuery.className.add( this, classNames );\n\t},\n\n\tremoveClass: function( classNames ) {\n\t\tjQuery.className.remove( this, classNames );\n\t},\n\n\ttoggleClass: function( classNames, state ) {\n\t\tif( typeof state !== \"boolean\" )\n\t\t\tstate = !jQuery.className.has( this, classNames );\n\t\tjQuery.className[ state ? \"add\" : \"remove\" ]( this, classNames );\n\t},\n\n\tremove: function( selector ) {\n\t\tif ( !selector || jQuery.filter( selector, [ this ] ).length ) {\n\t\t\t// Prevent memory leaks\n\t\t\tjQuery( \"*\", this ).add([this]).each(function(){\n\t\t\t\tjQuery.event.remove(this);\n\t\t\t\tjQuery.removeData(this);\n\t\t\t});\n\t\t\tif (this.parentNode)\n\t\t\t\tthis.parentNode.removeChild( this );\n\t\t}\n\t},\n\n\tempty: function() {\n\t\t// Remove element nodes and prevent memory leaks\n\t\tjQuery( \">*\", this ).remove();\n\n\t\t// Remove any remaining nodes\n\t\twhile ( this.firstChild )\n\t\t\tthis.removeChild( this.firstChild );\n\t}\n}, function(name, fn){\n\tjQuery.fn[ name ] = function(){\n\t\treturn this.each( fn, arguments );\n\t};\n});\n\n// Helper function used by the dimensions and offset modules\nfunction num(elem, prop) {\n\treturn elem[0] && parseInt( jQuery.curCSS(elem[0], prop, true), 10 ) || 0;\n}\nvar expando = \"jQuery\" + now(), uuid = 0, windowData = {};\r\n\r\njQuery.extend({\r\n\tcache: {},\r\n\r\n\tdata: function( elem, name, data ) {\r\n\t\telem = elem == window ?\r\n\t\t\twindowData :\r\n\t\t\telem;\r\n\r\n\t\tvar id = elem[ expando ];\r\n\r\n\t\t// Compute a unique ID for the element\r\n\t\tif ( !id )\r\n\t\t\tid = elem[ expando ] = ++uuid;\r\n\r\n\t\t// Only generate the data cache if we're\r\n\t\t// trying to access or manipulate it\r\n\t\tif ( name && !jQuery.cache[ id ] )\r\n\t\t\tjQuery.cache[ id ] = {};\r\n\r\n\t\t// Prevent overriding the named cache with undefined values\r\n\t\tif ( data !== undefined )\r\n\t\t\tjQuery.cache[ id ][ name ] = data;\r\n\r\n\t\t// Return the named cache data, or the ID for the element\r\n\t\treturn name ?\r\n\t\t\tjQuery.cache[ id ][ name ] :\r\n\t\t\tid;\r\n\t},\r\n\r\n\tremoveData: function( elem, name ) {\r\n\t\telem = elem == window ?\r\n\t\t\twindowData :\r\n\t\t\telem;\r\n\r\n\t\tvar id = elem[ expando ];\r\n\r\n\t\t// If we want to remove a specific section of the element's data\r\n\t\tif ( name ) {\r\n\t\t\tif ( jQuery.cache[ id ] ) {\r\n\t\t\t\t// Remove the section of cache data\r\n\t\t\t\tdelete jQuery.cache[ id ][ name ];\r\n\r\n\t\t\t\t// If we've removed all the data, remove the element's cache\r\n\t\t\t\tname = \"\";\r\n\r\n\t\t\t\tfor ( name in jQuery.cache[ id ] )\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tif ( !name )\r\n\t\t\t\t\tjQuery.removeData( elem );\r\n\t\t\t}\r\n\r\n\t\t// Otherwise, we want to remove all of the element's data\r\n\t\t} else {\r\n\t\t\t// Clean up the element expando\r\n\t\t\ttry {\r\n\t\t\t\tdelete elem[ expando ];\r\n\t\t\t} catch(e){\r\n\t\t\t\t// IE has trouble directly removing the expando\r\n\t\t\t\t// but it's ok with using removeAttribute\r\n\t\t\t\tif ( elem.removeAttribute )\r\n\t\t\t\t\telem.removeAttribute( expando );\r\n\t\t\t}\r\n\r\n\t\t\t// Completely remove the data cache\r\n\t\t\tdelete jQuery.cache[ id ];\r\n\t\t}\r\n\t},\r\n\tqueue: function( elem, type, data ) {\r\n\t\tif ( elem ){\r\n\t\r\n\t\t\ttype = (type || \"fx\") + \"queue\";\r\n\t\r\n\t\t\tvar q = jQuery.data( elem, type );\r\n\t\r\n\t\t\tif ( !q || jQuery.isArray(data) )\r\n\t\t\t\tq = jQuery.data( elem, type, jQuery.makeArray(data) );\r\n\t\t\telse if( data )\r\n\t\t\t\tq.push( data );\r\n\t\r\n\t\t}\r\n\t\treturn q;\r\n\t},\r\n\r\n\tdequeue: function( elem, type ){\r\n\t\tvar queue = jQuery.queue( elem, type ),\r\n\t\t\tfn = queue.shift();\r\n\t\t\r\n\t\tif( !type || type === \"fx\" )\r\n\t\t\tfn = queue[0];\r\n\t\t\t\r\n\t\tif( fn !== undefined )\r\n\t\t\tfn.call(elem);\r\n\t}\r\n});\r\n\r\njQuery.fn.extend({\r\n\tdata: function( key, value ){\r\n\t\tvar parts = key.split(\".\");\r\n\t\tparts[1] = parts[1] ? \".\" + parts[1] : \"\";\r\n\r\n\t\tif ( value === undefined ) {\r\n\t\t\tvar data = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]);\r\n\r\n\t\t\tif ( data === undefined && this.length )\r\n\t\t\t\tdata = jQuery.data( this[0], key );\r\n\r\n\t\t\treturn data === undefined && parts[1] ?\r\n\t\t\t\tthis.data( parts[0] ) :\r\n\t\t\t\tdata;\r\n\t\t} else\r\n\t\t\treturn this.trigger(\"setData\" + parts[1] + \"!\", [parts[0], value]).each(function(){\r\n\t\t\t\tjQuery.data( this, key, value );\r\n\t\t\t});\r\n\t},\r\n\r\n\tremoveData: function( key ){\r\n\t\treturn this.each(function(){\r\n\t\t\tjQuery.removeData( this, key );\r\n\t\t});\r\n\t},\r\n\tqueue: function(type, data){\r\n\t\tif ( typeof type !== \"string\" ) {\r\n\t\t\tdata = type;\r\n\t\t\ttype = \"fx\";\r\n\t\t}\r\n\r\n\t\tif ( data === undefined )\r\n\t\t\treturn jQuery.queue( this[0], type );\r\n\r\n\t\treturn this.each(function(){\r\n\t\t\tvar queue = jQuery.queue( this, type, data );\r\n\t\t\t\r\n\t\t\t if( type == \"fx\" && queue.length == 1 )\r\n\t\t\t\tqueue[0].call(this);\r\n\t\t});\r\n\t},\r\n\tdequeue: function(type){\r\n\t\treturn this.each(function(){\r\n\t\t\tjQuery.dequeue( this, type );\r\n\t\t});\r\n\t}\r\n});/*!\n * Sizzle CSS Selector Engine - v0.9.3\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n(function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]+['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tcontext = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 )\n\t\treturn [];\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true;\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tset = posProcess( parts[0] + parts[1], context );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tselector = parts.shift();\n\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tset = posProcess( selector, set );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar ret = seed ?\n\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\tSizzle.find( parts.pop(), parts.length === 1 && context.parentNode ? context.parentNode : context, isXML(context) );\n\t\tset = Sizzle.filter( ret.expr, ret.set );\n\n\t\tif ( parts.length > 0 ) {\n\t\t\tcheckSet = makeArray(set);\n\t\t} else {\n\t\t\tprune = false;\n\t\t}\n\n\t\twhile ( parts.length ) {\n\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\tcur = \"\";\n\t\t\t} else {\n\t\t\t\tpop = parts.pop();\n\t\t\t}\n\n\t\t\tif ( pop == null ) {\n\t\t\t\tpop = context;\n\t\t\t}\n\n\t\t\tExpr.relative[ cur ]( checkSet, pop, isXML(context) );\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n\n\tif ( !checkSet ) {\n\t\tthrow \"Syntax error, unrecognized expression: \" + (cur || selector);\n\t}\n\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\n\t\tif ( !prune ) {\n\t\t\tresults.push.apply( results, checkSet );\n\t\t} else if ( context.nodeType === 1 ) {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmakeArray( checkSet, results );\n\t}\n\n\tif ( extra ) {\n\t\tSizzle( extra, context, results, seed );\n\t}\n\n\treturn results;\n};\n\nSizzle.matches = function(expr, set){\n\treturn Sizzle(expr, null, null, set);\n};\n\nSizzle.find = function(expr, context, isXML){\n\tvar set, match;\n\n\tif ( !expr ) {\n\t\treturn [];\n\t}\n\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n\t\tvar type = Expr.order[i], match;\n\t\t\n\t\tif ( (match = Expr.match[ type ].exec( expr )) ) {\n\t\t\tvar left = RegExp.leftContext;\n\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\n\t\t\t\tmatch[1] = (match[1] || \"\").replace(/\\\\/g, \"\");\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n\t\t\t\tif ( set != null ) {\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !set ) {\n\t\tset = context.getElementsByTagName(\"*\");\n\t}\n\n\treturn {set: set, expr: expr};\n};\n\nSizzle.filter = function(expr, set, inplace, not){\n\tvar old = expr, result = [], curLoop = set, match, anyFound;\n\n\twhile ( expr && set.length ) {\n\t\tfor ( var type in Expr.filter ) {\n\t\t\tif ( (match = Expr.match[ type ].exec( expr )) != null ) {\n\t\t\t\tvar filter = Expr.filter[ type ], found, item;\n\t\t\t\tanyFound = false;\n\n\t\t\t\tif ( curLoop == result ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t}\n\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not );\n\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\tanyFound = found = true;\n\t\t\t\t\t} else if ( match === true ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n\t\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\n\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\n\t\t\t\t\t\t\t\tif ( pass ) {\n\t\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( pass ) {\n\t\t\t\t\t\t\t\tresult.push( item );\n\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( found !== undefined ) {\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tcurLoop = result;\n\t\t\t\t\t}\n\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\n\t\t\t\t\tif ( !anyFound ) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\texpr = expr.replace(/\\s*,\\s*/, \"\");\n\n\t\t// Improper expression\n\t\tif ( expr == old ) {\n\t\t\tif ( anyFound == null ) {\n\t\t\t\tthrow \"Syntax error, unrecognized expression: \" + expr;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\told = expr;\n\t}\n\n\treturn curLoop;\n};\n\nvar Expr = Sizzle.selectors = {\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\n\tmatch: {\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)['\"]*\\]/,\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*_-]|\\\\.)+)/,\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)(?:\\((['\"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/\n\t},\n\tattrMap: {\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\"\n\t},\n\tattrHandle: {\n\t\thref: function(elem){\n\t\t\treturn elem.getAttribute(\"href\");\n\t\t}\n\t},\n\trelative: {\n\t\t\"+\": function(checkSet, part){\n\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\tvar elem = checkSet[i];\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tvar cur = elem.previousSibling;\n\t\t\t\t\twhile ( cur && cur.nodeType !== 1 ) {\n\t\t\t\t\t\tcur = cur.previousSibling;\n\t\t\t\t\t}\n\t\t\t\t\tcheckSet[i] = typeof part === \"string\" ?\n\t\t\t\t\t\tcur || false :\n\t\t\t\t\t\tcur === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( typeof part === \"string\" ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t},\n\t\t\">\": function(checkSet, part, isXML){\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\n\t\t\t\tpart = isXML ? part : part.toUpperCase();\n\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = typeof part === \"string\" ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( typeof part === \"string\" ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"\": function(checkSet, part, isXML){\n\t\t\tvar doneName = \"done\" + (done++), checkFn = dirCheck;\n\n\t\t\tif ( !part.match(/\\W/) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t},\n\t\t\"~\": function(checkSet, part, isXML){\n\t\t\tvar doneName = \"done\" + (done++), checkFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !part.match(/\\W/) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}\n\t},\n\tfind: {\n\t\tID: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? [m] : [];\n\t\t\t}\n\t\t},\n\t\tNAME: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" && !isXML ) {\n\t\t\t\treturn context.getElementsByName(match[1]);\n\t\t\t}\n\t\t},\n\t\tTAG: function(match, context){\n\t\t\treturn context.getElementsByTagName(match[1]);\n\t\t}\n\t},\n\tpreFilter: {\n\t\tCLASS: function(match, curLoop, inplace, result, not){\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\n\n\t\t\tvar elem;\n\t\t\tfor ( var i = 0; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (\" \" + elem.className + \" \").indexOf(match) >= 0 ) {\n\t\t\t\t\t\tif ( !inplace )\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\tID: function(match){\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\n\t\t},\n\t\tTAG: function(match, curLoop){\n\t\t\tfor ( var i = 0; curLoop[i] === false; i++ ){}\n\t\t\treturn curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();\n\t\t},\n\t\tCHILD: function(match){\n\t\t\tif ( match[1] == \"nth\" ) {\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n\t\t\t\t\tmatch[2] == \"even\" && \"2n\" || match[2] == \"odd\" && \"2n+1\" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = \"done\" + (done++);\n\n\t\t\treturn match;\n\t\t},\n\t\tATTR: function(match){\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\n\t\t\t\n\t\t\tif ( Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\n\t\t\tif ( match[1] === \"not\" ) {\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\n\t\t\t\tif ( match[3].match(chunker).length > 1 ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t},\n\t\tPOS: function(match){\n\t\t\tmatch.unshift( true );\n\t\t\treturn match;\n\t\t}\n\t},\n\tfilters: {\n\t\tenabled: function(elem){\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t},\n\t\tdisabled: function(elem){\n\t\t\treturn elem.disabled === true;\n\t\t},\n\t\tchecked: function(elem){\n\t\t\treturn elem.checked === true;\n\t\t},\n\t\tselected: function(elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t},\n\t\tparent: function(elem){\n\t\t\treturn !!elem.firstChild;\n\t\t},\n\t\tempty: function(elem){\n\t\t\treturn !elem.firstChild;\n\t\t},\n\t\thas: function(elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t},\n\t\theader: function(elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t},\n\t\ttext: function(elem){\n\t\t\treturn \"text\" === elem.type;\n\t\t},\n\t\tradio: function(elem){\n\t\t\treturn \"radio\" === elem.type;\n\t\t},\n\t\tcheckbox: function(elem){\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t},\n\t\tfile: function(elem){\n\t\t\treturn \"file\" === elem.type;\n\t\t},\n\t\tpassword: function(elem){\n\t\t\treturn \"password\" === elem.type;\n\t\t},\n\t\tsubmit: function(elem){\n\t\t\treturn \"submit\" === elem.type;\n\t\t},\n\t\timage: function(elem){\n\t\t\treturn \"image\" === elem.type;\n\t\t},\n\t\treset: function(elem){\n\t\t\treturn \"reset\" === elem.type;\n\t\t},\n\t\tbutton: function(elem){\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toUpperCase() === \"BUTTON\";\n\t\t},\n\t\tinput: function(elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}\n\t},\n\tsetFilters: {\n\t\tfirst: function(elem, i){\n\t\t\treturn i === 0;\n\t\t},\n\t\tlast: function(elem, i, match, array){\n\t\t\treturn i === array.length - 1;\n\t\t},\n\t\teven: function(elem, i){\n\t\t\treturn i % 2 === 0;\n\t\t},\n\t\todd: function(elem, i){\n\t\t\treturn i % 2 === 1;\n\t\t},\n\t\tlt: function(elem, i, match){\n\t\t\treturn i < match[3] - 0;\n\t\t},\n\t\tgt: function(elem, i, match){\n\t\t\treturn i > match[3] - 0;\n\t\t},\n\t\tnth: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t},\n\t\teq: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}\n\t},\n\tfilter: {\n\t\tCHILD: function(elem, match){\n\t\t\tvar type = match[1], parent = elem.parentNode;\n\n\t\t\tvar doneName = match[0];\n\t\t\t\n\t\t\tif ( parent && (!parent[ doneName ] || !elem.nodeIndex) ) {\n\t\t\t\tvar count = 1;\n\n\t\t\t\tfor ( var node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\tif ( node.nodeType == 1 ) {\n\t\t\t\t\t\tnode.nodeIndex = count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tparent[ doneName ] = count - 1;\n\t\t\t}\n\n\t\t\tif ( type == \"first\" ) {\n\t\t\t\treturn elem.nodeIndex == 1;\n\t\t\t} else if ( type == \"last\" ) {\n\t\t\t\treturn elem.nodeIndex == parent[ doneName ];\n\t\t\t} else if ( type == \"only\" ) {\n\t\t\t\treturn parent[ doneName ] == 1;\n\t\t\t} else if ( type == \"nth\" ) {\n\t\t\t\tvar add = false, first = match[2], last = match[3];\n\n\t\t\t\tif ( first == 1 && last == 0 ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif ( first == 0 ) {\n\t\t\t\t\tif ( elem.nodeIndex == last ) {\n\t\t\t\t\t\tadd = true;\n\t\t\t\t\t}\n\t\t\t\t} else if ( (elem.nodeIndex - last) % first == 0 && (elem.nodeIndex - last) / first >= 0 ) {\n\t\t\t\t\tadd = true;\n\t\t\t\t}\n\n\t\t\t\treturn add;\n\t\t\t}\n\t\t},\n\t\tPSEUDO: function(elem, match, i, array){\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t} else if ( name === \"contains\" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || \"\").indexOf(match[3]) >= 0;\n\t\t\t} else if ( name === \"not\" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var i = 0, l = not.length; i < l; i++ ) {\n\t\t\t\t\tif ( not[i] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tID: function(elem, match){\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n\t\t},\n\t\tTAG: function(elem, match){\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName === match;\n\t\t},\n\t\tCLASS: function(elem, match){\n\t\t\treturn match.test( elem.className );\n\t\t},\n\t\tATTR: function(elem, match){\n\t\t\tvar result = Expr.attrHandle[ match[1] ] ? Expr.attrHandle[ match[1] ]( elem ) : elem[ match[1] ] || elem.getAttribute( match[1] ), value = result + \"\", type = match[2], check = match[4];\n\t\t\treturn result == null ?\n\t\t\t\ttype === \"!=\" :\n\t\t\t\ttype === \"=\" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === \"*=\" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === \"~=\" ?\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n\t\t\t\t!match[4] ?\n\t\t\t\tresult :\n\t\t\t\ttype === \"!=\" ?\n\t\t\t\tvalue != check :\n\t\t\t\ttype === \"^=\" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === \"$=\" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === \"|=\" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n\t\t\t\tfalse;\n\t\t},\n\t\tPOS: function(elem, match, i, array){\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar origPOS = Expr.match.POS;\n\nfor ( var type in Expr.match ) {\n\tExpr.match[ type ] = RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source );\n}\n\nvar makeArray = function(array, results) {\n\tarray = Array.prototype.slice.call( array );\n\n\tif ( results ) {\n\t\tresults.push.apply( results, array );\n\t\treturn results;\n\t}\n\t\n\treturn array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\ntry {\n\tArray.prototype.slice.call( document.documentElement.childNodes );\n\n// Provide a fallback method if it does not work\n} catch(e){\n\tmakeArray = function(array, results) {\n\t\tvar ret = results || [];\n\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\n\t\t\tArray.prototype.push.apply( ret, array );\n\t\t} else {\n\t\t\tif ( typeof array.length === \"number\" ) {\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0; array[i]; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n\t// We're going to inject a fake input element with a specified name\n\tvar form = document.createElement(\"form\"),\n\t\tid = \"script\" + (new Date).getTime();\n\tform.innerHTML = \"<input name='\" + id + \"'/>\";\n\n\t// Inject it into the root element, check its status, and remove it quickly\n\tvar root = document.documentElement;\n\troot.insertBefore( form, root.firstChild );\n\n\t// The workaround has to do additional checks after a getElementById\n\t// Which slows things down for other browsers (hence the branching)\n\tif ( !!document.getElementById( id ) ) {\n\t\tExpr.find.ID = function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\n\t\t\t}\n\t\t};\n\n\t\tExpr.filter.ID = function(elem, match){\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n\t\t};\n\t}\n\n\troot.removeChild( form );\n})();\n\n(function(){\n\t// Check to see if the browser returns only elements\n\t// when doing getElementsByTagName(\"*\")\n\n\t// Create a fake element\n\tvar div = document.createElement(\"div\");\n\tdiv.appendChild( document.createComment(\"\") );\n\n\t// Make sure no comments are found\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\n\t\tExpr.find.TAG = function(match, context){\n\t\t\tvar results = context.getElementsByTagName(match[1]);\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( match[1] === \"*\" ) {\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresults = tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// Check to see if an attribute returns normalized href attributes\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\tif ( div.firstChild && div.firstChild.getAttribute(\"href\") !== \"#\" ) {\n\t\tExpr.attrHandle.href = function(elem){\n\t\t\treturn elem.getAttribute(\"href\", 2);\n\t\t};\n\t}\n})();\n\nif ( document.querySelectorAll ) (function(){\n\tvar oldSizzle = Sizzle, div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<p class='TEST'></p>\";\n\n\t// Safari can't handle uppercase or unicode characters when\n\t// in quirks mode.\n\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\n\t\treturn;\n\t}\n\t\n\tSizzle = function(query, context, extra, seed){\n\t\tcontext = context || document;\n\n\t\t// Only use querySelectorAll on non-XML documents\n\t\t// (ID selectors don't work in non-HTML documents)\n\t\tif ( !seed && context.nodeType === 9 && !isXML(context) ) {\n\t\t\ttry {\n\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t} catch(e){}\n\t\t}\n\t\t\n\t\treturn oldSizzle(query, context, extra, seed);\n\t};\n\n\tSizzle.find = oldSizzle.find;\n\tSizzle.filter = oldSizzle.filter;\n\tSizzle.selectors = oldSizzle.selectors;\n\tSizzle.matches = oldSizzle.matches;\n})();\n\nif ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) {\n\tExpr.order.splice(1, 0, \"CLASS\");\n\tExpr.find.CLASS = function(match, context) {\n\t\treturn context.getElementsByClassName(match[1]);\n\t};\n}\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem && elem.nodeType ) {\n\t\t\t\tvar done = elem[doneName];\n\t\t\t\tif ( done ) {\n\t\t\t\t\tmatch = checkSet[ done ];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 && !isXML )\n\t\t\t\t\telem[doneName] = i;\n\n\t\t\t\tif ( elem.nodeName === cur ) {\n\t\t\t\t\tmatch = elem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem && elem.nodeType ) {\n\t\t\t\tif ( elem[doneName] ) {\n\t\t\t\t\tmatch = checkSet[ elem[doneName] ];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !isXML )\n\t\t\t\t\t\telem[doneName] = i;\n\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\n\t\t\t\t\t\tif ( elem === cur ) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n\t\t\t\t\t\tmatch = elem;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nvar contains = document.compareDocumentPosition ?  function(a, b){\n\treturn a.compareDocumentPosition(b) & 16;\n} : function(a, b){\n\treturn a !== b && (a.contains ? a.contains(b) : true);\n};\n\nvar isXML = function(elem){\n\treturn elem.nodeType === 9 && elem.documentElement.nodeName !== \"HTML\" ||\n\t\t!!elem.ownerDocument && isXML( elem.ownerDocument );\n};\n\nvar posProcess = function(selector, context){\n\tvar tmpSet = [], later = \"\", match,\n\t\troot = context.nodeType ? [context] : context;\n\n\t// Position selectors must be done after the filter\n\t// And so must :not(positional) so we move all PSEUDOs to the end\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n\t\tlater += match[0];\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\n\t}\n\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\n\t\tSizzle( selector, root[i], tmpSet );\n\t}\n\n\treturn Sizzle.filter( later, tmpSet );\n};\n\n// EXPOSE\njQuery.find = Sizzle;\njQuery.filter = Sizzle.filter;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.filters;\n\nSizzle.selectors.filters.hidden = function(elem){\n\treturn \"hidden\" === elem.type ||\n\t\tjQuery.css(elem, \"display\") === \"none\" ||\n\t\tjQuery.css(elem, \"visibility\") === \"hidden\";\n};\n\nSizzle.selectors.filters.visible = function(elem){\n\treturn \"hidden\" !== elem.type &&\n\t\tjQuery.css(elem, \"display\") !== \"none\" &&\n\t\tjQuery.css(elem, \"visibility\") !== \"hidden\";\n};\n\nSizzle.selectors.filters.animated = function(elem){\n\treturn jQuery.grep(jQuery.timers, function(fn){\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\njQuery.multiFilter = function( expr, elems, not ) {\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn Sizzle.matches(expr, elems);\n};\n\njQuery.dir = function( elem, dir ){\n\tvar matched = [], cur = elem[dir];\n\twhile ( cur && cur != document ) {\n\t\tif ( cur.nodeType == 1 )\n\t\t\tmatched.push( cur );\n\t\tcur = cur[dir];\n\t}\n\treturn matched;\n};\n\njQuery.nth = function(cur, result, dir, elem){\n\tresult = result || 1;\n\tvar num = 0;\n\n\tfor ( ; cur; cur = cur[dir] )\n\t\tif ( cur.nodeType == 1 && ++num == result )\n\t\t\tbreak;\n\n\treturn cur;\n};\n\njQuery.sibling = function(n, elem){\n\tvar r = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType == 1 && n != elem )\n\t\t\tr.push( n );\n\t}\n\n\treturn r;\n};\n\nreturn;\n\nwindow.Sizzle = Sizzle;\n\n})();\n/*\n * A number of helper functions used for managing events.\n * Many of the ideas behind this code originated from\n * Dean Edwards' addEvent library.\n */\njQuery.event = {\n\n\t// Bind an event to an element\n\t// Original by Dean Edwards\n\tadd: function(elem, types, handler, data) {\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\t// For whatever reason, IE has trouble passing the window object\n\t\t// around, causing it to be cloned in the process\n\t\tif ( elem.setInterval && elem != window )\n\t\t\telem = window;\n\n\t\t// Make sure that the function being executed has a unique ID\n\t\tif ( !handler.guid )\n\t\t\thandler.guid = this.guid++;\n\n\t\t// if data is passed, bind to handler\n\t\tif ( data !== undefined ) {\n\t\t\t// Create temporary function pointer to original handler\n\t\t\tvar fn = handler;\n\n\t\t\t// Create unique handler function, wrapped around original handler\n\t\t\thandler = this.proxy( fn );\n\n\t\t\t// Store data in unique handler\n\t\t\thandler.data = data;\n\t\t}\n\n\t\t// Init the element's event structure\n\t\tvar events = jQuery.data(elem, \"events\") || jQuery.data(elem, \"events\", {}),\n\t\t\thandle = jQuery.data(elem, \"handle\") || jQuery.data(elem, \"handle\", function(){\n\t\t\t\t// Handle the second event of a trigger and when\n\t\t\t\t// an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && !jQuery.event.triggered ?\n\t\t\t\t\tjQuery.event.handle.apply(arguments.callee.elem, arguments) :\n\t\t\t\t\tundefined;\n\t\t\t});\n\t\t// Add elem as a property of the handle function\n\t\t// This is to prevent a memory leak with non-native\n\t\t// event in IE.\n\t\thandle.elem = elem;\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\tjQuery.each(types.split(/\\s+/), function(index, type) {\n\t\t\t// Namespaced event handlers\n\t\t\tvar namespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\thandler.type = namespaces.slice().sort().join(\".\");\n\n\t\t\t// Get the current list of functions bound to this event\n\t\t\tvar handlers = events[type];\n\t\t\t\n\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\tjQuery.event.specialAll[type].setup.call(elem, data, namespaces);\n\n\t\t\t// Init the event handler queue\n\t\t\tif (!handlers) {\n\t\t\t\thandlers = events[type] = {};\n\n\t\t\t\t// Check for a special event handler\n\t\t\t\t// Only use addEventListener/attachEvent if the special\n\t\t\t\t// events handler returns false\n\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].setup.call(elem, data, namespaces) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif (elem.addEventListener)\n\t\t\t\t\t\telem.addEventListener(type, handle, false);\n\t\t\t\t\telse if (elem.attachEvent)\n\t\t\t\t\t\telem.attachEvent(\"on\" + type, handle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the function to the element's handler list\n\t\t\thandlers[handler.guid] = handler;\n\n\t\t\t// Keep track of which events have been used, for global triggering\n\t\t\tjQuery.event.global[type] = true;\n\t\t});\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\tguid: 1,\n\tglobal: {},\n\n\t// Detach an event or set of events from an element\n\tremove: function(elem, types, handler) {\n\t\t// don't do events on text and comment nodes\n\t\tif ( elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\treturn;\n\n\t\tvar events = jQuery.data(elem, \"events\"), ret, index;\n\n\t\tif ( events ) {\n\t\t\t// Unbind all events for the element\n\t\t\tif ( types === undefined || (typeof types === \"string\" && types.charAt(0) == \".\") )\n\t\t\t\tfor ( var type in events )\n\t\t\t\t\tthis.remove( elem, type + (types || \"\") );\n\t\t\telse {\n\t\t\t\t// types is actually an event object here\n\t\t\t\tif ( types.type ) {\n\t\t\t\t\thandler = types.handler;\n\t\t\t\t\ttypes = types.type;\n\t\t\t\t}\n\n\t\t\t\t// Handle multiple events seperated by a space\n\t\t\t\t// jQuery(...).unbind(\"mouseover mouseout\", fn);\n\t\t\t\tjQuery.each(types.split(/\\s+/), function(index, type){\n\t\t\t\t\t// Namespaced event handlers\n\t\t\t\t\tvar namespaces = type.split(\".\");\n\t\t\t\t\ttype = namespaces.shift();\n\t\t\t\t\tvar namespace = RegExp(\"(^|\\\\.)\" + namespaces.slice().sort().join(\".*\\\\.\") + \"(\\\\.|$)\");\n\n\t\t\t\t\tif ( events[type] ) {\n\t\t\t\t\t\t// remove the given handler for the given type\n\t\t\t\t\t\tif ( handler )\n\t\t\t\t\t\t\tdelete events[type][handler.guid];\n\n\t\t\t\t\t\t// remove all handlers for the given type\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfor ( var handle in events[type] )\n\t\t\t\t\t\t\t\t// Handle the removal of namespaced events\n\t\t\t\t\t\t\t\tif ( namespace.test(events[type][handle].type) )\n\t\t\t\t\t\t\t\t\tdelete events[type][handle];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tif ( jQuery.event.specialAll[type] )\n\t\t\t\t\t\t\tjQuery.event.specialAll[type].teardown.call(elem, namespaces);\n\n\t\t\t\t\t\t// remove generic event handler if no more handlers exist\n\t\t\t\t\t\tfor ( ret in events[type] ) break;\n\t\t\t\t\t\tif ( !ret ) {\n\t\t\t\t\t\t\tif ( !jQuery.event.special[type] || jQuery.event.special[type].teardown.call(elem, namespaces) === false ) {\n\t\t\t\t\t\t\t\tif (elem.removeEventListener)\n\t\t\t\t\t\t\t\t\telem.removeEventListener(type, jQuery.data(elem, \"handle\"), false);\n\t\t\t\t\t\t\t\telse if (elem.detachEvent)\n\t\t\t\t\t\t\t\t\telem.detachEvent(\"on\" + type, jQuery.data(elem, \"handle\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = null;\n\t\t\t\t\t\t\tdelete events[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tfor ( ret in events ) break;\n\t\t\tif ( !ret ) {\n\t\t\t\tvar handle = jQuery.data( elem, \"handle\" );\n\t\t\t\tif ( handle ) handle.elem = null;\n\t\t\t\tjQuery.removeData( elem, \"events\" );\n\t\t\t\tjQuery.removeData( elem, \"handle\" );\n\t\t\t}\n\t\t}\n\t},\n\n\t// bubbling is internal\n\ttrigger: function( event, data, elem, bubbling ) {\n\t\t// Event object or event type\n\t\tvar type = event.type || event;\n\n\t\tif( !bubbling ){\n\t\t\tevent = typeof event === \"object\" ?\n\t\t\t\t// jQuery.Event object\n\t\t\t\tevent[expando] ? event :\n\t\t\t\t// Object literal\n\t\t\t\tjQuery.extend( jQuery.Event(type), event ) :\n\t\t\t\t// Just the event type (string)\n\t\t\t\tjQuery.Event(type);\n\n\t\t\tif ( type.indexOf(\"!\") >= 0 ) {\n\t\t\t\tevent.type = type = type.slice(0, -1);\n\t\t\t\tevent.exclusive = true;\n\t\t\t}\n\n\t\t\t// Handle a global trigger\n\t\t\tif ( !elem ) {\n\t\t\t\t// Don't bubble custom events when global (to avoid too much overhead)\n\t\t\t\tevent.stopPropagation();\n\t\t\t\t// Only trigger if we've ever bound an event for it\n\t\t\t\tif ( this.global[type] )\n\t\t\t\t\tjQuery.each( jQuery.cache, function(){\n\t\t\t\t\t\tif ( this.events && this.events[type] )\n\t\t\t\t\t\t\tjQuery.event.trigger( event, data, this.handle.elem );\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Handle triggering a single element\n\n\t\t\t// don't do events on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType == 3 || elem.nodeType == 8 )\n\t\t\t\treturn undefined;\n\t\t\t\n\t\t\t// Clean up in case it is reused\n\t\t\tevent.result = undefined;\n\t\t\tevent.target = elem;\n\t\t\t\n\t\t\t// Clone the incoming data, if any\n\t\t\tdata = jQuery.makeArray(data);\n\t\t\tdata.unshift( event );\n\t\t}\n\n\t\tevent.currentTarget = elem;\n\n\t\t// Trigger the event, it is assumed that \"handle\" is a function\n\t\tvar handle = jQuery.data(elem, \"handle\");\n\t\tif ( handle )\n\t\t\thandle.apply( elem, data );\n\n\t\t// Handle triggering native .onfoo handlers (and on links since we don't call .click() for links)\n\t\tif ( (!elem[type] || (jQuery.nodeName(elem, 'a') && type == \"click\")) && elem[\"on\"+type] && elem[\"on\"+type].apply( elem, data ) === false )\n\t\t\tevent.result = false;\n\n\t\t// Trigger the native events (except for clicks on links)\n\t\tif ( !bubbling && elem[type] && !event.isDefaultPrevented() && !(jQuery.nodeName(elem, 'a') && type == \"click\") ) {\n\t\t\tthis.triggered = true;\n\t\t\ttry {\n\t\t\t\telem[ type ]();\n\t\t\t// prevent IE from throwing an error for some hidden elements\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\tthis.triggered = false;\n\n\t\tif ( !event.isPropagationStopped() ) {\n\t\t\tvar parent = elem.parentNode || elem.ownerDocument;\n\t\t\tif ( parent )\n\t\t\t\tjQuery.event.trigger(event, data, parent, true);\n\t\t}\n\t},\n\n\thandle: function(event) {\n\t\t// returned undefined or false\n\t\tvar all, handlers;\n\n\t\tevent = arguments[0] = jQuery.event.fix( event || window.event );\n\n\t\t// Namespaced event handlers\n\t\tvar namespaces = event.type.split(\".\");\n\t\tevent.type = namespaces.shift();\n\n\t\t// Cache this now, all = true means, any handler\n\t\tall = !namespaces.length && !event.exclusive;\n\t\t\n\t\tvar namespace = RegExp(\"(^|\\\\.)\" + namespaces.slice().sort().join(\".*\\\\.\") + \"(\\\\.|$)\");\n\n\t\thandlers = ( jQuery.data(this, \"events\") || {} )[event.type];\n\n\t\tfor ( var j in handlers ) {\n\t\t\tvar handler = handlers[j];\n\n\t\t\t// Filter the functions by class\n\t\t\tif ( all || namespace.test(handler.type) ) {\n\t\t\t\t// Pass in a reference to the handler function itself\n\t\t\t\t// So that we can later remove it\n\t\t\t\tevent.handler = handler;\n\t\t\t\tevent.data = handler.data;\n\n\t\t\t\tvar ret = handler.apply(this, arguments);\n\n\t\t\t\tif( ret !== undefined ){\n\t\t\t\t\tevent.result = ret;\n\t\t\t\t\tif ( ret === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( event.isImmediatePropagationStopped() )\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\t},\n\n\tprops: \"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode metaKey newValue originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which\".split(\" \"),\n\n\tfix: function(event) {\n\t\tif ( event[expando] )\n\t\t\treturn event;\n\n\t\t// store a copy of the original event object\n\t\t// and \"clone\" to set read-only properties\n\t\tvar originalEvent = event;\n\t\tevent = jQuery.Event( originalEvent );\n\n\t\tfor ( var i = this.props.length, prop; i; ){\n\t\t\tprop = this.props[ --i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Fix target property, if necessary\n\t\tif ( !event.target )\n\t\t\tevent.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either\n\n\t\t// check if target is a textnode (safari)\n\t\tif ( event.target.nodeType == 3 )\n\t\t\tevent.target = event.target.parentNode;\n\n\t\t// Add relatedTarget, if necessary\n\t\tif ( !event.relatedTarget && event.fromElement )\n\t\t\tevent.relatedTarget = event.fromElement == event.target ? event.toElement : event.fromElement;\n\n\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\tif ( event.pageX == null && event.clientX != null ) {\n\t\t\tvar doc = document.documentElement, body = document.body;\n\t\t\tevent.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0);\n\t\t\tevent.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc.clientTop || 0);\n\t\t}\n\n\t\t// Add which for key events\n\t\tif ( !event.which && ((event.charCode || event.charCode === 0) ? event.charCode : event.keyCode) )\n\t\t\tevent.which = event.charCode || event.keyCode;\n\n\t\t// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)\n\t\tif ( !event.metaKey && event.ctrlKey )\n\t\t\tevent.metaKey = event.ctrlKey;\n\n\t\t// Add which for click: 1 == left; 2 == middle; 3 == right\n\t\t// Note: button is not normalized, so don't use it\n\t\tif ( !event.which && event.button )\n\t\t\tevent.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));\n\n\t\treturn event;\n\t},\n\n\tproxy: function( fn, proxy ){\n\t\tproxy = proxy || function(){ return fn.apply(this, arguments); };\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || proxy.guid || this.guid++;\n\t\t// So proxy can be declared as an argument\n\t\treturn proxy;\n\t},\n\n\tspecial: {\n\t\tready: {\n\t\t\t// Make sure the ready event is setup\n\t\t\tsetup: bindReady,\n\t\t\tteardown: function() {}\n\t\t}\n\t},\n\t\n\tspecialAll: {\n\t\tlive: {\n\t\t\tsetup: function( selector, namespaces ){\n\t\t\t\tjQuery.event.add( this, namespaces[0], liveHandler );\n\t\t\t},\n\t\t\tteardown:  function( namespaces ){\n\t\t\t\tif ( namespaces.length ) {\n\t\t\t\t\tvar remove = 0, name = RegExp(\"(^|\\\\.)\" + namespaces[0] + \"(\\\\.|$)\");\n\t\t\t\t\t\n\t\t\t\t\tjQuery.each( (jQuery.data(this, \"events\").live || {}), function(){\n\t\t\t\t\t\tif ( name.test(this.type) )\n\t\t\t\t\t\t\tremove++;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif ( remove < 1 )\n\t\t\t\t\t\tjQuery.event.remove( this, namespaces[0], liveHandler );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.Event = function( src ){\n\t// Allow instantiation without the 'new' keyword\n\tif( !this.preventDefault )\n\t\treturn new jQuery.Event(src);\n\t\n\t// Event object\n\tif( src && src.type ){\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\t// Event type\n\t}else\n\t\tthis.type = src;\n\n\t// timeStamp is buggy for some events on Firefox(#3843)\n\t// So we won't rely on the native value\n\tthis.timeStamp = now();\n\t\n\t// Mark it as fixed\n\tthis[expando] = true;\n};\n\nfunction returnFalse(){\n\treturn false;\n}\nfunction returnTrue(){\n\treturn true;\n}\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tpreventDefault: function() {\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tvar e = this.originalEvent;\n\t\tif( !e )\n\t\t\treturn;\n\t\t// if preventDefault exists run it on the original event\n\t\tif (e.preventDefault)\n\t\t\te.preventDefault();\n\t\t// otherwise set the returnValue property of the original event to false (IE)\n\t\te.returnValue = false;\n\t},\n\tstopPropagation: function() {\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tvar e = this.originalEvent;\n\t\tif( !e )\n\t\t\treturn;\n\t\t// if stopPropagation exists run it on the original event\n\t\tif (e.stopPropagation)\n\t\t\te.stopPropagation();\n\t\t// otherwise set the cancelBubble property of the original event to true (IE)\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation:function(){\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t},\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse\n};\n// Checks if an event happened on an element within another element\n// Used in jQuery.event.special.mouseenter and mouseleave handlers\nvar withinElement = function(event) {\n\t// Check if mouse(over|out) are still within the same parent element\n\tvar parent = event.relatedTarget;\n\t// Traverse up the tree\n\twhile ( parent && parent != this )\n\t\ttry { parent = parent.parentNode; }\n\t\tcatch(e) { parent = this; }\n\t\n\tif( parent != this ){\n\t\t// set the correct event type\n\t\tevent.type = event.data;\n\t\t// handle event if we actually just moused on to a non sub-element\n\t\tjQuery.event.handle.apply( this, arguments );\n\t}\n};\n\t\njQuery.each({ \n\tmouseover: 'mouseenter', \n\tmouseout: 'mouseleave'\n}, function( orig, fix ){\n\tjQuery.event.special[ fix ] = {\n\t\tsetup: function(){\n\t\t\tjQuery.event.add( this, orig, withinElement, fix );\n\t\t},\n\t\tteardown: function(){\n\t\t\tjQuery.event.remove( this, orig, withinElement );\n\t\t}\n\t};\t\t\t   \n});\n\njQuery.fn.extend({\n\tbind: function( type, data, fn ) {\n\t\treturn type == \"unload\" ? this.one(type, data, fn) : this.each(function(){\n\t\t\tjQuery.event.add( this, type, fn || data, fn && data );\n\t\t});\n\t},\n\n\tone: function( type, data, fn ) {\n\t\tvar one = jQuery.event.proxy( fn || data, function(event) {\n\t\t\tjQuery(this).unbind(event, one);\n\t\t\treturn (fn || data).apply( this, arguments );\n\t\t});\n\t\treturn this.each(function(){\n\t\t\tjQuery.event.add( this, type, one, fn && data);\n\t\t});\n\t},\n\n\tunbind: function( type, fn ) {\n\t\treturn this.each(function(){\n\t\t\tjQuery.event.remove( this, type, fn );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function(){\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\n\ttriggerHandler: function( type, data ) {\n\t\tif( this[0] ){\n\t\t\tvar event = jQuery.Event(type);\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tjQuery.event.trigger( event, data, this[0] );\n\t\t\treturn event.result;\n\t\t}\t\t\n\t},\n\n\ttoggle: function( fn ) {\n\t\t// Save reference to arguments for access in closure\n\t\tvar args = arguments, i = 1;\n\n\t\t// link all the functions, so any of them can unbind this click handler\n\t\twhile( i < args.length )\n\t\t\tjQuery.event.proxy( fn, args[i++] );\n\n\t\treturn this.click( jQuery.event.proxy( fn, function(event) {\n\t\t\t// Figure out which function to execute\n\t\t\tthis.lastToggle = ( this.lastToggle || 0 ) % i;\n\n\t\t\t// Make sure that clicks stop\n\t\t\tevent.preventDefault();\n\n\t\t\t// and execute the function\n\t\t\treturn args[ this.lastToggle++ ].apply( this, arguments ) || false;\n\t\t}));\n\t},\n\n\thover: function(fnOver, fnOut) {\n\t\treturn this.mouseenter(fnOver).mouseleave(fnOut);\n\t},\n\n\tready: function(fn) {\n\t\t// Attach the listeners\n\t\tbindReady();\n\n\t\t// If the DOM is already ready\n\t\tif ( jQuery.isReady )\n\t\t\t// Execute the function immediately\n\t\t\tfn.call( document, jQuery );\n\n\t\t// Otherwise, remember the function for later\n\t\telse\n\t\t\t// Add the function to the wait list\n\t\t\tjQuery.readyList.push( fn );\n\n\t\treturn this;\n\t},\n\t\n\tlive: function( type, fn ){\n\t\tvar proxy = jQuery.event.proxy( fn );\n\t\tproxy.guid += this.selector + type;\n\n\t\tjQuery(document).bind( liveConvert(type, this.selector), this.selector, proxy );\n\n\t\treturn this;\n\t},\n\t\n\tdie: function( type, fn ){\n\t\tjQuery(document).unbind( liveConvert(type, this.selector), fn ? { guid: fn.guid + this.selector + type } : null );\n\t\treturn this;\n\t}\n});\n\nfunction liveHandler( event ){\n\tvar check = RegExp(\"(^|\\\\.)\" + event.type + \"(\\\\.|$)\"),\n\t\tstop = true,\n\t\telems = [];\n\n\tjQuery.each(jQuery.data(this, \"events\").live || [], function(i, fn){\n\t\tif ( check.test(fn.type) ) {\n\t\t\tvar elem = jQuery(event.target).closest(fn.data)[0];\n\t\t\tif ( elem )\n\t\t\t\telems.push({ elem: elem, fn: fn });\n\t\t}\n\t});\n\n\tjQuery.each(elems, function(){\n\t\tif ( this.fn.call(this.elem, event, this.fn.data) === false )\n\t\t\tstop = false;\n\t});\n\n\treturn stop;\n}\n\nfunction liveConvert(type, selector){\n\treturn [\"live\", type, selector.replace(/\\./g, \"`\").replace(/ /g, \"|\")].join(\".\");\n}\n\njQuery.extend({\n\tisReady: false,\n\treadyList: [],\n\t// Handle when the DOM is ready\n\tready: function() {\n\t\t// Make sure that the DOM is not already loaded\n\t\tif ( !jQuery.isReady ) {\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If there are functions bound, to execute\n\t\t\tif ( jQuery.readyList ) {\n\t\t\t\t// Execute all of them\n\t\t\t\tjQuery.each( jQuery.readyList, function(){\n\t\t\t\t\tthis.call( document, jQuery );\n\t\t\t\t});\n\n\t\t\t\t// Reset the list of functions\n\t\t\t\tjQuery.readyList = null;\n\t\t\t}\n\n\t\t\t// Trigger any bound ready events\n\t\t\tjQuery(document).triggerHandler(\"ready\");\n\t\t}\n\t}\n});\n\nvar readyBound = false;\n\nfunction bindReady(){\n\tif ( readyBound ) return;\n\treadyBound = true;\n\n\t// Mozilla, Opera and webkit nightlies currently support this event\n\tif ( document.addEventListener ) {\n\t\t// Use the handy event callback\n\t\tdocument.addEventListener( \"DOMContentLoaded\", function(){\n\t\t\tdocument.removeEventListener( \"DOMContentLoaded\", arguments.callee, false );\n\t\t\tjQuery.ready();\n\t\t}, false );\n\n\t// If IE event model is used\n\t} else if ( document.attachEvent ) {\n\t\t// ensure firing before onload,\n\t\t// maybe late but safe also for iframes\n\t\tdocument.attachEvent(\"onreadystatechange\", function(){\n\t\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t\tdocument.detachEvent( \"onreadystatechange\", arguments.callee );\n\t\t\t\tjQuery.ready();\n\t\t\t}\n\t\t});\n\n\t\t// If IE and not an iframe\n\t\t// continually check to see if the document is ready\n\t\tif ( document.documentElement.doScroll && typeof window.frameElement === \"undefined\" ) (function(){\n\t\t\tif ( jQuery.isReady ) return;\n\n\t\t\ttry {\n\t\t\t\t// If IE is used, use the trick by Diego Perini\n\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\tdocument.documentElement.doScroll(\"left\");\n\t\t\t} catch( error ) {\n\t\t\t\tsetTimeout( arguments.callee, 0 );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// and execute any waiting functions\n\t\t\tjQuery.ready();\n\t\t})();\n\t}\n\n\t// A fallback to window.onload, that will always work\n\tjQuery.event.add( window, \"load\", jQuery.ready );\n}\n\njQuery.each( (\"blur,focus,load,resize,scroll,unload,click,dblclick,\" +\n\t\"mousedown,mouseup,mousemove,mouseover,mouseout,mouseenter,mouseleave,\" +\n\t\"change,select,submit,keydown,keypress,keyup,error\").split(\",\"), function(i, name){\n\n\t// Handle event binding\n\tjQuery.fn[name] = function(fn){\n\t\treturn fn ? this.bind(name, fn) : this.trigger(name);\n\t};\n});\n\n// Prevent memory leaks in IE\n// And prevent errors on refresh with events like mouseover in other browsers\n// Window isn't included so as not to unbind existing unload events\njQuery( window ).bind( 'unload', function(){ \n\tfor ( var id in jQuery.cache )\n\t\t// Skip the window\n\t\tif ( id != 1 && jQuery.cache[ id ].handle )\n\t\t\tjQuery.event.remove( jQuery.cache[ id ].handle.elem );\n}); \n(function(){\n\n\tjQuery.support = {};\n\n\tvar root = document.documentElement,\n\t\tscript = document.createElement(\"script\"),\n\t\tdiv = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date).getTime();\n\n\tdiv.style.display = \"none\";\n\tdiv.innerHTML = '   <link/><table></table><a href=\"/a\" style=\"color:red;float:left;opacity:.5;\">a</a><select><option>text</option></select><object><param/></object>';\n\n\tvar all = div.getElementsByTagName(\"*\"),\n\t\ta = div.getElementsByTagName(\"a\")[0];\n\n\t// Can't get basic test support\n\tif ( !all || !all.length || !a ) {\n\t\treturn;\n\t}\n\n\tjQuery.support = {\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tleadingWhitespace: div.firstChild.nodeType == 3,\n\t\t\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\t\t\n\t\t// Make sure that you can get all elements in an <object> element\n\t\t// IE 7 always returns no results\n\t\tobjectAll: !!div.getElementsByTagName(\"object\")[0]\n\t\t\t.getElementsByTagName(\"*\").length,\n\t\t\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\t\t\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText insted)\n\t\tstyle: /red/.test( a.getAttribute(\"style\") ),\n\t\t\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\threfNormalized: a.getAttribute(\"href\") === \"/a\",\n\t\t\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\topacity: a.style.opacity === \"0.5\",\n\t\t\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tcssFloat: !!a.style.cssFloat,\n\n\t\t// Will be defined later\n\t\tscriptEval: false,\n\t\tnoCloneEvent: true,\n\t\tboxModel: null\n\t};\n\t\n\tscript.type = \"text/javascript\";\n\ttry {\n\t\tscript.appendChild( document.createTextNode( \"window.\" + id + \"=1;\" ) );\n\t} catch(e){}\n\n\troot.insertBefore( script, root.firstChild );\n\t\n\t// Make sure that the execution of code works by injecting a script\n\t// tag with appendChild/createTextNode\n\t// (IE doesn't support this, fails, and uses .text instead)\n\tif ( window[ id ] ) {\n\t\tjQuery.support.scriptEval = true;\n\t\tdelete window[ id ];\n\t}\n\n\troot.removeChild( script );\n\n\tif ( div.attachEvent && div.fireEvent ) {\n\t\tdiv.attachEvent(\"onclick\", function(){\n\t\t\t// Cloning a node shouldn't copy over any\n\t\t\t// bound event handlers (IE does this)\n\t\t\tjQuery.support.noCloneEvent = false;\n\t\t\tdiv.detachEvent(\"onclick\", arguments.callee);\n\t\t});\n\t\tdiv.cloneNode(true).fireEvent(\"onclick\");\n\t}\n\n\t// Figure out if the W3C box model works as expected\n\t// document.body must exist before we can do this\n\tjQuery(function(){\n\t\tvar div = document.createElement(\"div\");\n\t\tdiv.style.width = \"1px\";\n\t\tdiv.style.paddingLeft = \"1px\";\n\n\t\tdocument.body.appendChild( div );\n\t\tjQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;\n\t\tdocument.body.removeChild( div );\n\t});\n})();\n\nvar styleFloat = jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\";\n\njQuery.props = {\n\t\"for\": \"htmlFor\",\n\t\"class\": \"className\",\n\t\"float\": styleFloat,\n\tcssFloat: styleFloat,\n\tstyleFloat: styleFloat,\n\treadonly: \"readOnly\",\n\tmaxlength: \"maxLength\",\n\tcellspacing: \"cellSpacing\",\n\trowspan: \"rowSpan\",\n\ttabindex: \"tabIndex\"\n};\njQuery.fn.extend({\n\t// Keep a copy of the old load\n\t_load: jQuery.fn.load,\n\n\tload: function( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" )\n\t\t\treturn this._load( url );\n\n\t\tvar off = url.indexOf(\" \");\n\t\tif ( off >= 0 ) {\n\t\t\tvar selector = url.slice(off, url.length);\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// Default to a GET request\n\t\tvar type = \"GET\";\n\n\t\t// If the second parameter was provided\n\t\tif ( params )\n\t\t\t// If it's a function\n\t\t\tif ( jQuery.isFunction( params ) ) {\n\t\t\t\t// We assume that it's the callback\n\t\t\t\tcallback = params;\n\t\t\t\tparams = null;\n\n\t\t\t// Otherwise, build a param string\n\t\t\t} else if( typeof params === \"object\" ) {\n\t\t\t\tparams = jQuery.param( params );\n\t\t\t\ttype = \"POST\";\n\t\t\t}\n\n\t\tvar self = this;\n\n\t\t// Request the remote document\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params,\n\t\t\tcomplete: function(res, status){\n\t\t\t\t// If successful, inject the HTML into all the matched elements\n\t\t\t\tif ( status == \"success\" || status == \"notmodified\" )\n\t\t\t\t\t// See if a selector was specified\n\t\t\t\t\tself.html( selector ?\n\t\t\t\t\t\t// Create a dummy div to hold the results\n\t\t\t\t\t\tjQuery(\"<div/>\")\n\t\t\t\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t\t\t\t.append(res.responseText.replace(/<script(.|\\s)*?\\/script>/g, \"\"))\n\n\t\t\t\t\t\t\t// Locate the specified elements\n\t\t\t\t\t\t\t.find(selector) :\n\n\t\t\t\t\t\t// If not, just inject the full result\n\t\t\t\t\t\tres.responseText );\n\n\t\t\t\tif( callback )\n\t\t\t\t\tself.each( callback, [res.responseText, status, res] );\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\n\tserialize: function() {\n\t\treturn jQuery.param(this.serializeArray());\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\treturn this.elements ? jQuery.makeArray(this.elements) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t(this.checked || /select|textarea/i.test(this.nodeName) ||\n\t\t\t\t\t/text|hidden|password/i.test(this.type));\n\t\t})\n\t\t.map(function(i, elem){\n\t\t\tvar val = jQuery(this).val();\n\t\t\treturn val == null ? null :\n\t\t\t\tjQuery.isArray(val) ?\n\t\t\t\t\tjQuery.map( val, function(val, i){\n\t\t\t\t\t\treturn {name: elem.name, value: val};\n\t\t\t\t\t}) :\n\t\t\t\t\t{name: elem.name, value: val};\n\t\t}).get();\n\t}\n});\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( \"ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend\".split(\",\"), function(i,o){\n\tjQuery.fn[o] = function(f){\n\t\treturn this.bind(o, f);\n\t};\n});\n\nvar jsc = now();\n\njQuery.extend({\n  \n\tget: function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was ommited\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\tcallback = data;\n\t\t\tdata = null;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\ttype: \"GET\",\n\t\t\turl: url,\n\t\t\tdata: data,\n\t\t\tsuccess: callback,\n\t\t\tdataType: type\n\t\t});\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get(url, null, callback, \"script\");\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get(url, data, callback, \"json\");\n\t},\n\n\tpost: function( url, data, callback, type ) {\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\tcallback = data;\n\t\t\tdata = {};\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: url,\n\t\t\tdata: data,\n\t\t\tsuccess: callback,\n\t\t\tdataType: type\n\t\t});\n\t},\n\n\tajaxSetup: function( settings ) {\n\t\tjQuery.extend( jQuery.ajaxSettings, settings );\n\t},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\tglobal: true,\n\t\ttype: \"GET\",\n\t\tcontentType: \"application/x-www-form-urlencoded\",\n\t\tprocessData: true,\n\t\tasync: true,\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\t*/\n\t\t// Create the request object; Microsoft failed to properly\n\t\t// implement the XMLHttpRequest in IE7, so we use the ActiveXObject when it is available\n\t\t// This function can be overriden by calling jQuery.ajaxSetup\n\t\txhr:function(){\n\t\t\treturn window.ActiveXObject ? new ActiveXObject(\"Microsoft.XMLHTTP\") : new XMLHttpRequest();\n\t\t},\n\t\taccepts: {\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\thtml: \"text/html\",\n\t\t\tscript: \"text/javascript, application/javascript\",\n\t\t\tjson: \"application/json, text/javascript\",\n\t\t\ttext: \"text/plain\",\n\t\t\t_default: \"*/*\"\n\t\t}\n\t},\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\n\tajax: function( s ) {\n\t\t// Extend the settings, but re-extend 's' so that it can be\n\t\t// checked again later (in the test suite, specifically)\n\t\ts = jQuery.extend(true, s, jQuery.extend(true, {}, jQuery.ajaxSettings, s));\n\n\t\tvar jsonp, jsre = /=\\?(&|$)/g, status, data,\n\t\t\ttype = s.type.toUpperCase();\n\n\t\t// convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" )\n\t\t\ts.data = jQuery.param(s.data);\n\n\t\t// Handle JSONP Parameter Callbacks\n\t\tif ( s.dataType == \"jsonp\" ) {\n\t\t\tif ( type == \"GET\" ) {\n\t\t\t\tif ( !s.url.match(jsre) )\n\t\t\t\t\ts.url += (s.url.match(/\\?/) ? \"&\" : \"?\") + (s.jsonp || \"callback\") + \"=?\";\n\t\t\t} else if ( !s.data || !s.data.match(jsre) )\n\t\t\t\ts.data = (s.data ? s.data + \"&\" : \"\") + (s.jsonp || \"callback\") + \"=?\";\n\t\t\ts.dataType = \"json\";\n\t\t}\n\n\t\t// Build temporary JSONP function\n\t\tif ( s.dataType == \"json\" && (s.data && s.data.match(jsre) || s.url.match(jsre)) ) {\n\t\t\tjsonp = \"jsonp\" + jsc++;\n\n\t\t\t// Replace the =? sequence both in the query string and the data\n\t\t\tif ( s.data )\n\t\t\t\ts.data = (s.data + \"\").replace(jsre, \"=\" + jsonp + \"$1\");\n\t\t\ts.url = s.url.replace(jsre, \"=\" + jsonp + \"$1\");\n\n\t\t\t// We need to make sure\n\t\t\t// that a JSONP style response is executed properly\n\t\t\ts.dataType = \"script\";\n\n\t\t\t// Handle JSONP-style loading\n\t\t\twindow[ jsonp ] = function(tmp){\n\t\t\t\tdata = tmp;\n\t\t\t\tsuccess();\n\t\t\t\tcomplete();\n\t\t\t\t// Garbage collect\n\t\t\t\twindow[ jsonp ] = undefined;\n\t\t\t\ttry{ delete window[ jsonp ]; } catch(e){}\n\t\t\t\tif ( head )\n\t\t\t\t\thead.removeChild( script );\n\t\t\t};\n\t\t}\n\n\t\tif ( s.dataType == \"script\" && s.cache == null )\n\t\t\ts.cache = false;\n\n\t\tif ( s.cache === false && type == \"GET\" ) {\n\t\t\tvar ts = now();\n\t\t\t// try replacing _= if it is there\n\t\t\tvar ret = s.url.replace(/(\\?|&)_=.*?(&|$)/, \"$1_=\" + ts + \"$2\");\n\t\t\t// if nothing was replaced, add timestamp to the end\n\t\t\ts.url = ret + ((ret == s.url) ? (s.url.match(/\\?/) ? \"&\" : \"?\") + \"_=\" + ts : \"\");\n\t\t}\n\n\t\t// If data is available, append data to url for get requests\n\t\tif ( s.data && type == \"GET\" ) {\n\t\t\ts.url += (s.url.match(/\\?/) ? \"&\" : \"?\") + s.data;\n\n\t\t\t// IE likes to send both get and post data, prevent this\n\t\t\ts.data = null;\n\t\t}\n\n\t\t// Watch for a new set of requests\n\t\tif ( s.global && ! jQuery.active++ )\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\n\t\t// Matches an absolute URL, and saves the domain\n\t\tvar parts = /^(\\w+:)?\\/\\/([^\\/?#]+)/.exec( s.url );\n\n\t\t// If we're requesting a remote document\n\t\t// and trying to load JSON or Script with a GET\n\t\tif ( s.dataType == \"script\" && type == \"GET\" && parts\n\t\t\t&& ( parts[1] && parts[1] != location.protocol || parts[2] != location.host )){\n\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\n\t\t\tvar script = document.createElement(\"script\");\n\t\t\tscript.src = s.url;\n\t\t\tif (s.scriptCharset)\n\t\t\t\tscript.charset = s.scriptCharset;\n\n\t\t\t// Handle Script loading\n\t\t\tif ( !jsonp ) {\n\t\t\t\tvar done = false;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function(){\n\t\t\t\t\tif ( !done && (!this.readyState ||\n\t\t\t\t\t\t\tthis.readyState == \"loaded\" || this.readyState == \"complete\") ) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tsuccess();\n\t\t\t\t\t\tcomplete();\n\t\t\t\t\t\thead.removeChild( script );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\thead.appendChild(script);\n\n\t\t\t// We handle everything using the script element injection\n\t\t\treturn undefined;\n\t\t}\n\n\t\tvar requestDone = false;\n\n\t\t// Create the request object\n\t\tvar xhr = s.xhr();\n\n\t\t// Open the socket\n\t\t// Passing null username, generates a login popup on Opera (#2865)\n\t\tif( s.username )\n\t\t\txhr.open(type, s.url, s.async, s.username, s.password);\n\t\telse\n\t\t\txhr.open(type, s.url, s.async);\n\n\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\t\ttry {\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data )\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", s.contentType);\n\n\t\t\t// Set the If-Modified-Since header, if ifModified mode.\n\t\t\tif ( s.ifModified )\n\t\t\t\txhr.setRequestHeader(\"If-Modified-Since\",\n\t\t\t\t\tjQuery.lastModified[s.url] || \"Thu, 01 Jan 1970 00:00:00 GMT\" );\n\n\t\t\t// Set header so the called script knows that it's an XMLHttpRequest\n\t\t\txhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\txhr.setRequestHeader(\"Accept\", s.dataType && s.accepts[ s.dataType ] ?\n\t\t\t\ts.accepts[ s.dataType ] + \", */*\" :\n\t\t\t\ts.accepts._default );\n\t\t} catch(e){}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && s.beforeSend(xhr, s) === false ) {\n\t\t\t// Handle the global AJAX counter\n\t\t\tif ( s.global && ! --jQuery.active )\n\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t// close opended socket\n\t\t\txhr.abort();\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( s.global )\n\t\t\tjQuery.event.trigger(\"ajaxSend\", [xhr, s]);\n\n\t\t// Wait for a response to come back\n\t\tvar onreadystatechange = function(isTimeout){\n\t\t\t// The request was aborted, clear the interval and decrement jQuery.active\n\t\t\tif (xhr.readyState == 0) {\n\t\t\t\tif (ival) {\n\t\t\t\t\t// clear poll interval\n\t\t\t\t\tclearInterval(ival);\n\t\t\t\t\tival = null;\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( s.global && ! --jQuery.active )\n\t\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t// The transfer is complete and the data is available, or the request timed out\n\t\t\t} else if ( !requestDone && xhr && (xhr.readyState == 4 || isTimeout == \"timeout\") ) {\n\t\t\t\trequestDone = true;\n\n\t\t\t\t// clear poll interval\n\t\t\t\tif (ival) {\n\t\t\t\t\tclearInterval(ival);\n\t\t\t\t\tival = null;\n\t\t\t\t}\n\n\t\t\t\tstatus = isTimeout == \"timeout\" ? \"timeout\" :\n\t\t\t\t\t!jQuery.httpSuccess( xhr ) ? \"error\" :\n\t\t\t\t\ts.ifModified && jQuery.httpNotModified( xhr, s.url ) ? \"notmodified\" :\n\t\t\t\t\t\"success\";\n\n\t\t\t\tif ( status == \"success\" ) {\n\t\t\t\t\t// Watch for, and catch, XML document parse errors\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// process the data (runs the xml through httpData regardless of callback)\n\t\t\t\t\t\tdata = jQuery.httpData( xhr, s.dataType, s );\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tstatus = \"parsererror\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Make sure that the request was successful or notmodified\n\t\t\t\tif ( status == \"success\" ) {\n\t\t\t\t\t// Cache Last-Modified header, if ifModified mode.\n\t\t\t\t\tvar modRes;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmodRes = xhr.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\t} catch(e) {} // swallow exception thrown by FF if header is not available\n\n\t\t\t\t\tif ( s.ifModified && modRes )\n\t\t\t\t\t\tjQuery.lastModified[s.url] = modRes;\n\n\t\t\t\t\t// JSONP handles its own success callback\n\t\t\t\t\tif ( !jsonp )\n\t\t\t\t\t\tsuccess();\n\t\t\t\t} else\n\t\t\t\t\tjQuery.handleError(s, xhr, status);\n\n\t\t\t\t// Fire the complete handlers\n\t\t\t\tcomplete();\n\n\t\t\t\tif ( isTimeout )\n\t\t\t\t\txhr.abort();\n\n\t\t\t\t// Stop memory leaks\n\t\t\t\tif ( s.async )\n\t\t\t\t\txhr = null;\n\t\t\t}\n\t\t};\n\n\t\tif ( s.async ) {\n\t\t\t// don't attach the handler to the request, just poll it instead\n\t\t\tvar ival = setInterval(onreadystatechange, 13);\n\n\t\t\t// Timeout checker\n\t\t\tif ( s.timeout > 0 )\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t// Check to see if the request is still happening\n\t\t\t\t\tif ( xhr && !requestDone )\n\t\t\t\t\t\tonreadystatechange( \"timeout\" );\n\t\t\t\t}, s.timeout);\n\t\t}\n\n\t\t// Send the data\n\t\ttry {\n\t\t\txhr.send(s.data);\n\t\t} catch(e) {\n\t\t\tjQuery.handleError(s, xhr, null, e);\n\t\t}\n\n\t\t// firefox 1.5 doesn't fire statechange for sync requests\n\t\tif ( !s.async )\n\t\t\tonreadystatechange();\n\n\t\tfunction success(){\n\t\t\t// If a local callback was specified, fire it and pass it the data\n\t\t\tif ( s.success )\n\t\t\t\ts.success( data, status );\n\n\t\t\t// Fire the global callback\n\t\t\tif ( s.global )\n\t\t\t\tjQuery.event.trigger( \"ajaxSuccess\", [xhr, s] );\n\t\t}\n\n\t\tfunction complete(){\n\t\t\t// Process result\n\t\t\tif ( s.complete )\n\t\t\t\ts.complete(xhr, status);\n\n\t\t\t// The request was completed\n\t\t\tif ( s.global )\n\t\t\t\tjQuery.event.trigger( \"ajaxComplete\", [xhr, s] );\n\n\t\t\t// Handle the global AJAX counter\n\t\t\tif ( s.global && ! --jQuery.active )\n\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t}\n\n\t\t// return XMLHttpRequest to allow aborting the request etc.\n\t\treturn xhr;\n\t},\n\n\thandleError: function( s, xhr, status, e ) {\n\t\t// If a local callback was specified, fire it\n\t\tif ( s.error ) s.error( xhr, status, e );\n\n\t\t// Fire the global callback\n\t\tif ( s.global )\n\t\t\tjQuery.event.trigger( \"ajaxError\", [xhr, s, e] );\n\t},\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Determines if an XMLHttpRequest was successful or not\n\thttpSuccess: function( xhr ) {\n\t\ttry {\n\t\t\t// IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450\n\t\t\treturn !xhr.status && location.protocol == \"file:\" ||\n\t\t\t\t( xhr.status >= 200 && xhr.status < 300 ) || xhr.status == 304 || xhr.status == 1223;\n\t\t} catch(e){}\n\t\treturn false;\n\t},\n\n\t// Determines if an XMLHttpRequest returns NotModified\n\thttpNotModified: function( xhr, url ) {\n\t\ttry {\n\t\t\tvar xhrRes = xhr.getResponseHeader(\"Last-Modified\");\n\n\t\t\t// Firefox always returns 200. check Last-Modified date\n\t\t\treturn xhr.status == 304 || xhrRes == jQuery.lastModified[url];\n\t\t} catch(e){}\n\t\treturn false;\n\t},\n\n\thttpData: function( xhr, type, s ) {\n\t\tvar ct = xhr.getResponseHeader(\"content-type\"),\n\t\t\txml = type == \"xml\" || !type && ct && ct.indexOf(\"xml\") >= 0,\n\t\t\tdata = xml ? xhr.responseXML : xhr.responseText;\n\n\t\tif ( xml && data.documentElement.tagName == \"parsererror\" )\n\t\t\tthrow \"parsererror\";\n\t\t\t\n\t\t// Allow a pre-filtering function to sanitize the response\n\t\t// s != null is checked to keep backwards compatibility\n\t\tif( s && s.dataFilter )\n\t\t\tdata = s.dataFilter( data, type );\n\n\t\t// The filter can actually parse the response\n\t\tif( typeof data === \"string\" ){\n\n\t\t\t// If the type is \"script\", eval it in global context\n\t\t\tif ( type == \"script\" )\n\t\t\t\tjQuery.globalEval( data );\n\n\t\t\t// Get the JavaScript object, if JSON is used.\n\t\t\tif ( type == \"json\" )\n\t\t\t\tdata = window[\"eval\"](\"(\" + data + \")\");\n\t\t}\n\t\t\n\t\treturn data;\n\t},\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tparam: function( a ) {\n\t\tvar s = [ ];\n\n\t\tfunction add( key, value ){\n\t\t\ts[ s.length ] = encodeURIComponent(key) + '=' + encodeURIComponent(value);\n\t\t};\n\n\t\t// If an array was passed in, assume that it is an array\n\t\t// of form elements\n\t\tif ( jQuery.isArray(a) || a.jquery )\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function(){\n\t\t\t\tadd( this.name, this.value );\n\t\t\t});\n\n\t\t// Otherwise, assume that it's an object of key/value pairs\n\t\telse\n\t\t\t// Serialize the key/values\n\t\t\tfor ( var j in a )\n\t\t\t\t// If the value is an array then the key names need to be repeated\n\t\t\t\tif ( jQuery.isArray(a[j]) )\n\t\t\t\t\tjQuery.each( a[j], function(){\n\t\t\t\t\t\tadd( j, this );\n\t\t\t\t\t});\n\t\t\t\telse\n\t\t\t\t\tadd( j, jQuery.isFunction(a[j]) ? a[j]() : a[j] );\n\n\t\t// Return the resulting serialization\n\t\treturn s.join(\"&\").replace(/%20/g, \"+\");\n\t}\n\n});\nvar elemdisplay = {},\n\ttimerId,\n\tfxAttrs = [\n\t\t// height animations\n\t\t[ \"height\", \"marginTop\", \"marginBottom\", \"paddingTop\", \"paddingBottom\" ],\n\t\t// width animations\n\t\t[ \"width\", \"marginLeft\", \"marginRight\", \"paddingLeft\", \"paddingRight\" ],\n\t\t// opacity animations\n\t\t[ \"opacity\" ]\n\t];\n\nfunction genFx( type, num ){\n\tvar obj = {};\n\tjQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function(){\n\t\tobj[ this ] = type;\n\t});\n\treturn obj;\n}\n\njQuery.fn.extend({\n\tshow: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"show\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\t\n\t\t\t\tthis[i].style.display = old || \"\";\n\t\t\t\t\n\t\t\t\tif ( jQuery.css(this[i], \"display\") === \"none\" ) {\n\t\t\t\t\tvar tagName = this[i].tagName, display;\n\t\t\t\t\t\n\t\t\t\t\tif ( elemdisplay[ tagName ] ) {\n\t\t\t\t\t\tdisplay = elemdisplay[ tagName ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar elem = jQuery(\"<\" + tagName + \" />\").appendTo(\"body\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tdisplay = elem.css(\"display\");\n\t\t\t\t\t\tif ( display === \"none\" )\n\t\t\t\t\t\t\tdisplay = \"block\";\n\t\t\t\t\t\t\n\t\t\t\t\t\telem.remove();\n\t\t\t\t\t\t\n\t\t\t\t\t\telemdisplay[ tagName ] = display;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis[i].style.display = jQuery.data(this[i], \"olddisplay\", display);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t}\n\t},\n\n\thide: function(speed,callback){\n\t\tif ( speed ) {\n\t\t\treturn this.animate( genFx(\"hide\", 3), speed, callback);\n\t\t} else {\n\t\t\tfor ( var i = 0, l = this.length; i < l; i++ ){\n\t\t\t\tvar old = jQuery.data(this[i], \"olddisplay\");\n\t\t\t\tif ( !old && old !== \"none\" )\n\t\t\t\t\tjQuery.data(this[i], \"olddisplay\", jQuery.css(this[i], \"display\"));\n\t\t\t\tthis[i].style.display = \"none\";\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// Save the old toggle function\n\t_toggle: jQuery.fn.toggle,\n\n\ttoggle: function( fn, fn2 ){\n\t\tvar bool = typeof fn === \"boolean\";\n\n\t\treturn jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?\n\t\t\tthis._toggle.apply( this, arguments ) :\n\t\t\tfn == null || bool ?\n\t\t\t\tthis.each(function(){\n\t\t\t\t\tvar state = bool ? fn : jQuery(this).is(\":hidden\");\n\t\t\t\t\tjQuery(this)[ state ? \"show\" : \"hide\" ]();\n\t\t\t\t}) :\n\t\t\t\tthis.animate(genFx(\"toggle\", 3), fn, fn2);\n\t},\n\n\tfadeTo: function(speed,to,callback){\n\t\treturn this.animate({opacity: to}, speed, callback);\n\t},\n\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar optall = jQuery.speed(speed, easing, callback);\n\n\t\treturn this[ optall.queue === false ? \"each\" : \"queue\" ](function(){\n\t\t\n\t\t\tvar opt = jQuery.extend({}, optall), p,\n\t\t\t\thidden = this.nodeType == 1 && jQuery(this).is(\":hidden\"),\n\t\t\t\tself = this;\n\t\n\t\t\tfor ( p in prop ) {\n\t\t\t\tif ( prop[p] == \"hide\" && hidden || prop[p] == \"show\" && !hidden )\n\t\t\t\t\treturn opt.complete.call(this);\n\n\t\t\t\tif ( ( p == \"height\" || p == \"width\" ) && this.style ) {\n\t\t\t\t\t// Store display property\n\t\t\t\t\topt.display = jQuery.css(this, \"display\");\n\n\t\t\t\t\t// Make sure that nothing sneaks out\n\t\t\t\t\topt.overflow = this.style.overflow;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( opt.overflow != null )\n\t\t\t\tthis.style.overflow = \"hidden\";\n\n\t\t\topt.curAnim = jQuery.extend({}, prop);\n\n\t\t\tjQuery.each( prop, function(name, val){\n\t\t\t\tvar e = new jQuery.fx( self, opt, name );\n\n\t\t\t\tif ( /toggle|show|hide/.test(val) )\n\t\t\t\t\te[ val == \"toggle\" ? hidden ? \"show\" : \"hide\" : val ]( prop );\n\t\t\t\telse {\n\t\t\t\t\tvar parts = val.toString().match(/^([+-]=)?([\\d+-.]+)(.*)$/),\n\t\t\t\t\t\tstart = e.cur(true) || 0;\n\n\t\t\t\t\tif ( parts ) {\n\t\t\t\t\t\tvar end = parseFloat(parts[2]),\n\t\t\t\t\t\t\tunit = parts[3] || \"px\";\n\n\t\t\t\t\t\t// We need to compute starting value\n\t\t\t\t\t\tif ( unit != \"px\" ) {\n\t\t\t\t\t\t\tself.style[ name ] = (end || 1) + unit;\n\t\t\t\t\t\t\tstart = ((end || 1) / e.cur(true)) * start;\n\t\t\t\t\t\t\tself.style[ name ] = start + unit;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\t\t\tif ( parts[1] )\n\t\t\t\t\t\t\tend = ((parts[1] == \"-=\" ? -1 : 1) * end) + start;\n\n\t\t\t\t\t\te.custom( start, end, unit );\n\t\t\t\t\t} else\n\t\t\t\t\t\te.custom( start, val, \"\" );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// For JS strict compliance\n\t\t\treturn true;\n\t\t});\n\t},\n\n\tstop: function(clearQueue, gotoEnd){\n\t\tvar timers = jQuery.timers;\n\n\t\tif (clearQueue)\n\t\t\tthis.queue([]);\n\n\t\tthis.each(function(){\n\t\t\t// go in reverse order so anything added to the queue during the loop is ignored\n\t\t\tfor ( var i = timers.length - 1; i >= 0; i-- )\n\t\t\t\tif ( timers[i].elem == this ) {\n\t\t\t\t\tif (gotoEnd)\n\t\t\t\t\t\t// force the next step to be the last\n\t\t\t\t\t\ttimers[i](true);\n\t\t\t\t\ttimers.splice(i, 1);\n\t\t\t\t}\n\t\t});\n\n\t\t// start the next in the queue if the last step wasn't forced\n\t\tif (!gotoEnd)\n\t\t\tthis.dequeue();\n\n\t\treturn this;\n\t}\n\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\", 1),\n\tslideUp: genFx(\"hide\", 1),\n\tslideToggle: genFx(\"toggle\", 1),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" }\n}, function( name, props ){\n\tjQuery.fn[ name ] = function( speed, callback ){\n\t\treturn this.animate( props, speed, callback );\n\t};\n});\n\njQuery.extend({\n\n\tspeed: function(speed, easing, fn) {\n\t\tvar opt = typeof speed === \"object\" ? speed : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n\t\t};\n\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\t\tjQuery.fx.speeds[opt.duration] || jQuery.fx.speeds._default;\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\t\topt.complete = function(){\n\t\t\tif ( opt.queue !== false )\n\t\t\t\tjQuery(this).dequeue();\n\t\t\tif ( jQuery.isFunction( opt.old ) )\n\t\t\t\topt.old.call( this );\n\t\t};\n\n\t\treturn opt;\n\t},\n\n\teasing: {\n\t\tlinear: function( p, n, firstNum, diff ) {\n\t\t\treturn firstNum + diff * p;\n\t\t},\n\t\tswing: function( p, n, firstNum, diff ) {\n\t\t\treturn ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;\n\t\t}\n\t},\n\n\ttimers: [],\n\n\tfx: function( elem, options, prop ){\n\t\tthis.options = options;\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\n\t\tif ( !options.orig )\n\t\t\toptions.orig = {};\n\t}\n\n});\n\njQuery.fx.prototype = {\n\n\t// Simple function for setting a style value\n\tupdate: function(){\n\t\tif ( this.options.step )\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\n\t\t(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );\n\n\t\t// Set display property to block for height/width animations\n\t\tif ( ( this.prop == \"height\" || this.prop == \"width\" ) && this.elem.style )\n\t\t\tthis.elem.style.display = \"block\";\n\t},\n\n\t// Get the current size\n\tcur: function(force){\n\t\tif ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) )\n\t\t\treturn this.elem[ this.prop ];\n\n\t\tvar r = parseFloat(jQuery.css(this.elem, this.prop, force));\n\t\treturn r && r > -10000 ? r : parseFloat(jQuery.curCSS(this.elem, this.prop)) || 0;\n\t},\n\n\t// Start an animation from one number to another\n\tcustom: function(from, to, unit){\n\t\tthis.startTime = now();\n\t\tthis.start = from;\n\t\tthis.end = to;\n\t\tthis.unit = unit || this.unit || \"px\";\n\t\tthis.now = this.start;\n\t\tthis.pos = this.state = 0;\n\n\t\tvar self = this;\n\t\tfunction t(gotoEnd){\n\t\t\treturn self.step(gotoEnd);\n\t\t}\n\n\t\tt.elem = this.elem;\n\n\t\tif ( t() && jQuery.timers.push(t) == 1 ) {\n\t\t\ttimerId = setInterval(function(){\n\t\t\t\tvar timers = jQuery.timers;\n\n\t\t\t\tfor ( var i = 0; i < timers.length; i++ )\n\t\t\t\t\tif ( !timers[i]() )\n\t\t\t\t\t\ttimers.splice(i--, 1);\n\n\t\t\t\tif ( !timers.length ) {\n\t\t\t\t\tclearInterval( timerId );\n\t\t\t\t}\n\t\t\t}, 13);\n\t\t}\n\t},\n\n\t// Simple 'show' function\n\tshow: function(){\n\t\t// Remember where we started, so that we can go back to it later\n\t\tthis.options.orig[this.prop] = jQuery.attr( this.elem.style, this.prop );\n\t\tthis.options.show = true;\n\n\t\t// Begin the animation\n\t\t// Make sure that we start at a small width/height to avoid any\n\t\t// flash of content\n\t\tthis.custom(this.prop == \"width\" || this.prop == \"height\" ? 1 : 0, this.cur());\n\n\t\t// Start by showing the element\n\t\tjQuery(this.elem).show();\n\t},\n\n\t// Simple 'hide' function\n\thide: function(){\n\t\t// Remember where we started, so that we can go back to it later\n\t\tthis.options.orig[this.prop] = jQuery.attr( this.elem.style, this.prop );\n\t\tthis.options.hide = true;\n\n\t\t// Begin the animation\n\t\tthis.custom(this.cur(), 0);\n\t},\n\n\t// Each step of an animation\n\tstep: function(gotoEnd){\n\t\tvar t = now();\n\n\t\tif ( gotoEnd || t >= this.options.duration + this.startTime ) {\n\t\t\tthis.now = this.end;\n\t\t\tthis.pos = this.state = 1;\n\t\t\tthis.update();\n\n\t\t\tthis.options.curAnim[ this.prop ] = true;\n\n\t\t\tvar done = true;\n\t\t\tfor ( var i in this.options.curAnim )\n\t\t\t\tif ( this.options.curAnim[i] !== true )\n\t\t\t\t\tdone = false;\n\n\t\t\tif ( done ) {\n\t\t\t\tif ( this.options.display != null ) {\n\t\t\t\t\t// Reset the overflow\n\t\t\t\t\tthis.elem.style.overflow = this.options.overflow;\n\n\t\t\t\t\t// Reset the display\n\t\t\t\t\tthis.elem.style.display = this.options.display;\n\t\t\t\t\tif ( jQuery.css(this.elem, \"display\") == \"none\" )\n\t\t\t\t\t\tthis.elem.style.display = \"block\";\n\t\t\t\t}\n\n\t\t\t\t// Hide the element if the \"hide\" operation was done\n\t\t\t\tif ( this.options.hide )\n\t\t\t\t\tjQuery(this.elem).hide();\n\n\t\t\t\t// Reset the properties, if the item has been hidden or shown\n\t\t\t\tif ( this.options.hide || this.options.show )\n\t\t\t\t\tfor ( var p in this.options.curAnim )\n\t\t\t\t\t\tjQuery.attr(this.elem.style, p, this.options.orig[p]);\n\t\t\t\t\t\n\t\t\t\t// Execute the complete function\n\t\t\t\tthis.options.complete.call( this.elem );\n\t\t\t}\n\n\t\t\treturn false;\n\t\t} else {\n\t\t\tvar n = t - this.startTime;\n\t\t\tthis.state = n / this.options.duration;\n\n\t\t\t// Perform the easing function, defaults to swing\n\t\t\tthis.pos = jQuery.easing[this.options.easing || (jQuery.easing.swing ? \"swing\" : \"linear\")](this.state, n, 0, 1, this.options.duration);\n\t\t\tthis.now = this.start + ((this.end - this.start) * this.pos);\n\n\t\t\t// Perform the next step of the animation\n\t\t\tthis.update();\n\t\t}\n\n\t\treturn true;\n\t}\n\n};\n\njQuery.extend( jQuery.fx, {\n\tspeeds:{\n\t\tslow: 600,\n \t\tfast: 200,\n \t\t// Default speed\n \t\t_default: 400\n\t},\n\tstep: {\n\n\t\topacity: function(fx){\n\t\t\tjQuery.attr(fx.elem.style, \"opacity\", fx.now);\n\t\t},\n\n\t\t_default: function(fx){\n\t\t\tif ( fx.elem.style && fx.elem.style[ fx.prop ] != null )\n\t\t\t\tfx.elem.style[ fx.prop ] = fx.now + fx.unit;\n\t\t\telse\n\t\t\t\tfx.elem[ fx.prop ] = fx.now;\n\t\t}\n\t}\n});\nif ( document.documentElement[\"getBoundingClientRect\"] )\n\tjQuery.fn.offset = function() {\n\t\tif ( !this[0] ) return { top: 0, left: 0 };\n\t\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );\n\t\tvar box  = this[0].getBoundingClientRect(), doc = this[0].ownerDocument, body = doc.body, docElem = doc.documentElement,\n\t\t\tclientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t\t\ttop  = box.top  + (self.pageYOffset || jQuery.boxModel && docElem.scrollTop  || body.scrollTop ) - clientTop,\n\t\t\tleft = box.left + (self.pageXOffset || jQuery.boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t\treturn { top: top, left: left };\n\t};\nelse \n\tjQuery.fn.offset = function() {\n\t\tif ( !this[0] ) return { top: 0, left: 0 };\n\t\tif ( this[0] === this[0].ownerDocument.body ) return jQuery.offset.bodyOffset( this[0] );\n\t\tjQuery.offset.initialized || jQuery.offset.initialize();\n\n\t\tvar elem = this[0], offsetParent = elem.offsetParent, prevOffsetParent = elem,\n\t\t\tdoc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,\n\t\t\tbody = doc.body, defaultView = doc.defaultView,\n\t\t\tprevComputedStyle = defaultView.getComputedStyle(elem, null),\n\t\t\ttop = elem.offsetTop, left = elem.offsetLeft;\n\n\t\twhile ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {\n\t\t\tcomputedStyle = defaultView.getComputedStyle(elem, null);\n\t\t\ttop -= elem.scrollTop, left -= elem.scrollLeft;\n\t\t\tif ( elem === offsetParent ) {\n\t\t\t\ttop += elem.offsetTop, left += elem.offsetLeft;\n\t\t\t\tif ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && /^t(able|d|h)$/i.test(elem.tagName)) )\n\t\t\t\t\ttop  += parseInt( computedStyle.borderTopWidth,  10) || 0,\n\t\t\t\t\tleft += parseInt( computedStyle.borderLeftWidth, 10) || 0;\n\t\t\t\tprevOffsetParent = offsetParent, offsetParent = elem.offsetParent;\n\t\t\t}\n\t\t\tif ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== \"visible\" )\n\t\t\t\ttop  += parseInt( computedStyle.borderTopWidth,  10) || 0,\n\t\t\t\tleft += parseInt( computedStyle.borderLeftWidth, 10) || 0;\n\t\t\tprevComputedStyle = computedStyle;\n\t\t}\n\n\t\tif ( prevComputedStyle.position === \"relative\" || prevComputedStyle.position === \"static\" )\n\t\t\ttop  += body.offsetTop,\n\t\t\tleft += body.offsetLeft;\n\n\t\tif ( prevComputedStyle.position === \"fixed\" )\n\t\t\ttop  += Math.max(docElem.scrollTop, body.scrollTop),\n\t\t\tleft += Math.max(docElem.scrollLeft, body.scrollLeft);\n\n\t\treturn { top: top, left: left };\n\t};\n\njQuery.offset = {\n\tinitialize: function() {\n\t\tif ( this.initialized ) return;\n\t\tvar body = document.body, container = document.createElement('div'), innerDiv, checkDiv, table, td, rules, prop, bodyMarginTop = body.style.marginTop,\n\t\t\thtml = '<div style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\"><div></div></div><table style=\"position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;\" cellpadding=\"0\" cellspacing=\"0\"><tr><td></td></tr></table>';\n\n\t\trules = { position: 'absolute', top: 0, left: 0, margin: 0, border: 0, width: '1px', height: '1px', visibility: 'hidden' };\n\t\tfor ( prop in rules ) container.style[prop] = rules[prop];\n\n\t\tcontainer.innerHTML = html;\n\t\tbody.insertBefore(container, body.firstChild);\n\t\tinnerDiv = container.firstChild, checkDiv = innerDiv.firstChild, td = innerDiv.nextSibling.firstChild.firstChild;\n\n\t\tthis.doesNotAddBorder = (checkDiv.offsetTop !== 5);\n\t\tthis.doesAddBorderForTableAndCells = (td.offsetTop === 5);\n\n\t\tinnerDiv.style.overflow = 'hidden', innerDiv.style.position = 'relative';\n\t\tthis.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);\n\n\t\tbody.style.marginTop = '1px';\n\t\tthis.doesNotIncludeMarginInBodyOffset = (body.offsetTop === 0);\n\t\tbody.style.marginTop = bodyMarginTop;\n\n\t\tbody.removeChild(container);\n\t\tthis.initialized = true;\n\t},\n\n\tbodyOffset: function(body) {\n\t\tjQuery.offset.initialized || jQuery.offset.initialize();\n\t\tvar top = body.offsetTop, left = body.offsetLeft;\n\t\tif ( jQuery.offset.doesNotIncludeMarginInBodyOffset )\n\t\t\ttop  += parseInt( jQuery.curCSS(body, 'marginTop',  true), 10 ) || 0,\n\t\t\tleft += parseInt( jQuery.curCSS(body, 'marginLeft', true), 10 ) || 0;\n\t\treturn { top: top, left: left };\n\t}\n};\n\n\njQuery.fn.extend({\n\tposition: function() {\n\t\tvar left = 0, top = 0, results;\n\n\t\tif ( this[0] ) {\n\t\t\t// Get *real* offsetParent\n\t\t\tvar offsetParent = this.offsetParent(),\n\n\t\t\t// Get correct offsets\n\t\t\toffset       = this.offset(),\n\t\t\tparentOffset = /^body|html$/i.test(offsetParent[0].tagName) ? { top: 0, left: 0 } : offsetParent.offset();\n\n\t\t\t// Subtract element margins\n\t\t\t// note: when an element has margin: auto the offsetLeft and marginLeft \n\t\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\t\toffset.top  -= num( this, 'marginTop'  );\n\t\t\toffset.left -= num( this, 'marginLeft' );\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top  += num( offsetParent, 'borderTopWidth'  );\n\t\t\tparentOffset.left += num( offsetParent, 'borderLeftWidth' );\n\n\t\t\t// Subtract the two offsets\n\t\t\tresults = {\n\t\t\t\ttop:  offset.top  - parentOffset.top,\n\t\t\t\tleft: offset.left - parentOffset.left\n\t\t\t};\n\t\t}\n\n\t\treturn results;\n\t},\n\n\toffsetParent: function() {\n\t\tvar offsetParent = this[0].offsetParent || document.body;\n\t\twhile ( offsetParent && (!/^body|html$/i.test(offsetParent.tagName) && jQuery.css(offsetParent, 'position') == 'static') )\n\t\t\toffsetParent = offsetParent.offsetParent;\n\t\treturn jQuery(offsetParent);\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( ['Left', 'Top'], function(i, name) {\n\tvar method = 'scroll' + name;\n\t\n\tjQuery.fn[ method ] = function(val) {\n\t\tif (!this[0]) return null;\n\n\t\treturn val !== undefined ?\n\n\t\t\t// Set the scroll offset\n\t\t\tthis.each(function() {\n\t\t\t\tthis == window || this == document ?\n\t\t\t\t\twindow.scrollTo(\n\t\t\t\t\t\t!i ? val : jQuery(window).scrollLeft(),\n\t\t\t\t\t\t i ? val : jQuery(window).scrollTop()\n\t\t\t\t\t) :\n\t\t\t\t\tthis[ method ] = val;\n\t\t\t}) :\n\n\t\t\t// Return the scroll offset\n\t\t\tthis[0] == window || this[0] == document ?\n\t\t\t\tself[ i ? 'pageYOffset' : 'pageXOffset' ] ||\n\t\t\t\t\tjQuery.boxModel && document.documentElement[ method ] ||\n\t\t\t\t\tdocument.body[ method ] :\n\t\t\t\tthis[0][ method ];\n\t};\n});\n// Create innerHeight, innerWidth, outerHeight and outerWidth methods\njQuery.each([ \"Height\", \"Width\" ], function(i, name){\n\n\tvar tl = i ? \"Left\"  : \"Top\",  // top or left\n\t\tbr = i ? \"Right\" : \"Bottom\"; // bottom or right\n\n\t// innerHeight and innerWidth\n\tjQuery.fn[\"inner\" + name] = function(){\n\t\treturn this[ name.toLowerCase() ]() +\n\t\t\tnum(this, \"padding\" + tl) +\n\t\t\tnum(this, \"padding\" + br);\n\t};\n\n\t// outerHeight and outerWidth\n\tjQuery.fn[\"outer\" + name] = function(margin) {\n\t\treturn this[\"inner\" + name]() +\n\t\t\tnum(this, \"border\" + tl + \"Width\") +\n\t\t\tnum(this, \"border\" + br + \"Width\") +\n\t\t\t(margin ?\n\t\t\t\tnum(this, \"margin\" + tl) + num(this, \"margin\" + br) : 0);\n\t};\n\t\n\tvar type = name.toLowerCase();\n\n\tjQuery.fn[ type ] = function( size ) {\n\t\t// Get window width or height\n\t\treturn this[0] == window ?\n\t\t\t// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode\n\t\t\tdocument.compatMode == \"CSS1Compat\" && document.documentElement[ \"client\" + name ] ||\n\t\t\tdocument.body[ \"client\" + name ] :\n\n\t\t\t// Get document width or height\n\t\t\tthis[0] == document ?\n\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height], whichever is greater\n\t\t\t\tMath.max(\n\t\t\t\t\tdocument.documentElement[\"client\" + name],\n\t\t\t\t\tdocument.body[\"scroll\" + name], document.documentElement[\"scroll\" + name],\n\t\t\t\t\tdocument.body[\"offset\" + name], document.documentElement[\"offset\" + name]\n\t\t\t\t) :\n\n\t\t\t\t// Get or set width or height on the element\n\t\t\t\tsize === undefined ?\n\t\t\t\t\t// Get width or height on the element\n\t\t\t\t\t(this.length ? jQuery.css( this[0], type ) : null) :\n\n\t\t\t\t\t// Set the width or height on the element (default to pixels if value is unitless)\n\t\t\t\t\tthis.css( type, typeof size === \"string\" ? size : size + \"px\" );\n\t};\n\n});})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvdW5pdC9qcXVlcnktMS4zLjEuanM/YjI5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSw4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsU0FBUztBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHFCQUFxQiw4REFBOEQ7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsWUFBWTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hELHlCQUF5QixzQ0FBc0M7QUFDL0Qsc0JBQXNCLHlDQUF5QztBQUMvRCxzQkFBc0IsNkNBQTZDO0FBQ25FLHlCQUF5Qix1Q0FBdUM7QUFDaEUseUJBQXlCLDJDQUEyQztBQUNwRSwwQkFBMEIsd0RBQXdEO0FBQ2xGLDBCQUEwQix3Q0FBd0M7QUFDbEUsMEJBQTBCO0FBQzFCLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsSUFBSSwwQ0FBMEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxLQUFLO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNEJBQTRCO0FBQ25DLFlBQVksZUFBZTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEc7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0EsbUVBQW1FLHVDQUF1QztBQUMxRztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxXQUFXLFdBQVc7O0FBRS9GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ04sTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxPQUFPO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLHVCQUF1QixZQUFZO0FBQ25DLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixXQUFXO0FBQ1gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTSxPQUFPLFNBQVMsc0JBQXNCLFVBQVUsVUFBVSxXQUFXLG1EQUFtRCxNQUFNLE9BQU8sU0FBUyxzQkFBc0IsVUFBVSxVQUFVLFdBQVc7O0FBRWxQLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLGtCQUFrQjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuMy4xXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDkgSm9obiBSZXNpZ1xuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG4gKiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL0xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDA5LTAxLTIxIDIwOjQyOjE2IC0wNTAwIChXZWQsIDIxIEphbiAyMDA5KVxuICogUmV2aXNpb246IDYxNThcbiAqL1xuKGZ1bmN0aW9uKCl7XG5cbnZhciBcblx0Ly8gV2lsbCBzcGVlZCB1cCByZWZlcmVuY2VzIHRvIHdpbmRvdywgYW5kIGFsbG93cyBtdW5naW5nIGl0cyBuYW1lLlxuXHR3aW5kb3cgPSB0aGlzLFxuXHQvLyBXaWxsIHNwZWVkIHVwIHJlZmVyZW5jZXMgdG8gdW5kZWZpbmVkLCBhbmQgYWxsb3dzIG11bmdpbmcgaXRzIG5hbWUuXG5cdHVuZGVmaW5lZCxcblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kLFxuXG5cdGpRdWVyeSA9IHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzIG9yIElEIHN0cmluZ3Ncblx0Ly8gKGJvdGggb2Ygd2hpY2ggd2Ugb3B0aW1pemUgZm9yKVxuXHRxdWlja0V4cHIgPSAvXltePF0qKDwoLnxcXHMpKz4pW14+XSokfF4jKFtcXHctXSspJC8sXG5cdC8vIElzIGl0IGEgc2ltcGxlIHNlbGVjdG9yXG5cdGlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXHRpbml0OiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgYSBzZWxlY3Rpb24gd2FzIHByb3ZpZGVkXG5cdFx0c2VsZWN0b3IgPSBzZWxlY3RvciB8fCBkb2N1bWVudDtcblxuXHRcdC8vIEhhbmRsZSAkKERPTUVsZW1lbnQpXG5cdFx0aWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbMF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHRoaXMuY29udGV4dCA9IHNlbGVjdG9yO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdC8vIEFyZSB3ZSBkZWFsaW5nIHdpdGggSFRNTCBzdHJpbmcgb3IgYW4gSUQ/XG5cdFx0XHR2YXIgbWF0Y2ggPSBxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gVmVyaWZ5IGEgbWF0Y2gsIGFuZCB0aGF0IG5vIGNvbnRleHQgd2FzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbMV0gKVxuXHRcdFx0XHRcdHNlbGVjdG9yID0galF1ZXJ5LmNsZWFuKCBbIG1hdGNoWzFdIF0sIGNvbnRleHQgKTtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoXCIjaWRcIilcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbM10gKTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0Ly8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0uaWQgIT0gbWF0Y2hbM10gKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGpRdWVyeSgpLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHdlIGluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0dmFyIHJldCA9IGpRdWVyeSggZWxlbSB8fCBbXSApO1xuXHRcdFx0XHRcdHJldC5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0cmV0LnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgW2NvbnRleHRdKVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZW50KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cmV0dXJuIGpRdWVyeSggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKVxuXHRcdFx0cmV0dXJuIGpRdWVyeSggZG9jdW1lbnQgKS5yZWFkeSggc2VsZWN0b3IgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG9sZCBzZWxlY3RvciBzdGF0ZSBpcyBwYXNzZWQgYWxvbmdcblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICYmIHNlbGVjdG9yLmNvbnRleHQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnNldEFycmF5KGpRdWVyeS5tYWtlQXJyYXkoc2VsZWN0b3IpKTtcblx0fSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiBcIjEuMy4xXCIsXG5cblx0Ly8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcblx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdC8vIFJldHVybiBhICdjbGVhbicgYXJyYXlcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIHRoaXMgKSA6XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvYmplY3Rcblx0XHRcdHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zLCBuYW1lLCBzZWxlY3RvciApIHtcblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkoIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0aWYgKCBuYW1lID09PSBcImZpbmRcIiApXG5cdFx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICsgKHRoaXMuc2VsZWN0b3IgPyBcIiBcIiA6IFwiXCIpICsgc2VsZWN0b3I7XG5cdFx0ZWxzZSBpZiAoIG5hbWUgKVxuXHRcdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArIFwiLlwiICsgbmFtZSArIFwiKFwiICsgc2VsZWN0b3IgKyBcIilcIjtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBGb3JjZSB0aGUgY3VycmVudCBtYXRjaGVkIHNldCBvZiBlbGVtZW50cyB0byBiZWNvbWVcblx0Ly8gdGhlIHNwZWNpZmllZCBhcnJheSBvZiBlbGVtZW50cyAoZGVzdHJveWluZyB0aGUgc3RhY2sgaW4gdGhlIHByb2Nlc3MpXG5cdC8vIFlvdSBzaG91bGQgdXNlIHB1c2hTdGFjaygpIGluIG9yZGVyIHRvIGRvIHRoaXMsIGJ1dCBtYWludGFpbiB0aGUgc3RhY2tcblx0c2V0QXJyYXk6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHQvLyBSZXNldHRpbmcgdGhlIGxlbmd0aCB0byAwLCB0aGVuIHVzaW5nIHRoZSBuYXRpdmUgQXJyYXkgcHVzaFxuXHRcdC8vIGlzIGEgc3VwZXItZmFzdCB3YXkgdG8gcG9wdWxhdGUgYW4gb2JqZWN0IHdpdGggYXJyYXktbGlrZSBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCB0aGlzLCBlbGVtcyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0Ly8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcblx0Ly8gb25seSB1c2VkIGludGVybmFsbHkuKVxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjaywgYXJncyApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cblx0Ly8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4galF1ZXJ5LmluQXJyYXkoXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0gJiYgZWxlbS5qcXVlcnkgPyBlbGVtWzBdIDogZWxlbVxuXHRcdCwgdGhpcyApO1xuXHR9LFxuXG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSwgdHlwZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IG5hbWU7XG5cblx0XHQvLyBMb29rIGZvciB0aGUgY2FzZSB3aGVyZSB3ZSdyZSBhY2Nlc3NpbmcgYSBzdHlsZSB2YWx1ZVxuXHRcdGlmICggdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgKVxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIClcblx0XHRcdFx0cmV0dXJuIHRoaXNbMF0gJiYgalF1ZXJ5WyB0eXBlIHx8IFwiYXR0clwiIF0oIHRoaXNbMF0sIG5hbWUgKTtcblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdFx0b3B0aW9uc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHQvLyBDaGVjayB0byBzZWUgaWYgd2UncmUgc2V0dGluZyBzdHlsZSB2YWx1ZXNcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpe1xuXHRcdFx0Ly8gU2V0IGFsbCB0aGUgc3R5bGVzXG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKVxuXHRcdFx0XHRqUXVlcnkuYXR0cihcblx0XHRcdFx0XHR0eXBlID9cblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUgOlxuXHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRuYW1lLCBqUXVlcnkucHJvcCggdGhpcywgb3B0aW9uc1sgbmFtZSBdLCB0eXBlLCBpLCBuYW1lIClcblx0XHRcdFx0KTtcblx0XHR9KTtcblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIGlnbm9yZSBuZWdhdGl2ZSB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlc1xuXHRcdGlmICggKGtleSA9PSAnd2lkdGgnIHx8IGtleSA9PSAnaGVpZ2h0JykgJiYgcGFyc2VGbG9hdCh2YWx1ZSkgPCAwIClcblx0XHRcdHZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiB0aGlzLmF0dHIoIGtleSwgdmFsdWUsIFwiY3VyQ1NTXCIgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiB0ZXh0ICE9PSBcIm9iamVjdFwiICYmIHRleHQgIT0gbnVsbCApXG5cdFx0XHRyZXR1cm4gdGhpcy5lbXB0eSgpLmFwcGVuZCggKHRoaXNbMF0gJiYgdGhpc1swXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZSggdGV4dCApICk7XG5cblx0XHR2YXIgcmV0ID0gXCJcIjtcblxuXHRcdGpRdWVyeS5lYWNoKCB0ZXh0IHx8IHRoaXMsIGZ1bmN0aW9uKCl7XG5cdFx0XHRqUXVlcnkuZWFjaCggdGhpcy5jaGlsZE5vZGVzLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT0gOCApXG5cdFx0XHRcdFx0cmV0ICs9IHRoaXMubm9kZVR5cGUgIT0gMSA/XG5cdFx0XHRcdFx0XHR0aGlzLm5vZGVWYWx1ZSA6XG5cdFx0XHRcdFx0XHRqUXVlcnkuZm4udGV4dCggWyB0aGlzIF0gKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIHRoaXNbMF0gKSB7XG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0dmFyIHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbMF0ub3duZXJEb2N1bWVudCApLmNsb25lKCk7XG5cblx0XHRcdGlmICggdGhpc1swXS5wYXJlbnROb2RlIClcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbMF0gKTtcblxuXHRcdFx0d3JhcC5tYXAoZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdENoaWxkIClcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdENoaWxkO1xuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSkuYXBwZW5kKHRoaXMpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkuY29udGVudHMoKS53cmFwQWxsKCBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCB0cnVlLCBmdW5jdGlvbihlbGVtKXtcblx0XHRcdGlmICh0aGlzLm5vZGVUeXBlID09IDEpXG5cdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0aWYgKHRoaXMubm9kZVR5cGUgPT0gMSlcblx0XHRcdFx0dGhpcy5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMuZmlyc3RDaGlsZCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZmFsc2UsIGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCBqUXVlcnkoIFtdICk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyAucHVzaCBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogW10ucHVzaCxcblxuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA9PT0gMSAmJiAhLywvLnRlc3Qoc2VsZWN0b3IpICkge1xuXHRcdFx0dmFyIHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSwgXCJmaW5kXCIsIHNlbGVjdG9yICk7XG5cdFx0XHRyZXQubGVuZ3RoID0gMDtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3RvciwgdGhpc1swXSwgcmV0ICk7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZWxlbXMgPSBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBlbGVtICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCAvW14rPl0gW14rPl0vLnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlKCBlbGVtcyApIDpcblx0XHRcdFx0ZWxlbXMsIFwiZmluZFwiLCBzZWxlY3RvciApO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGV2ZW50cyApIHtcblx0XHQvLyBEbyB0aGUgY2xvbmVcblx0XHR2YXIgcmV0ID0gdGhpcy5tYXAoZnVuY3Rpb24oKXtcblx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVFdmVudCAmJiAhalF1ZXJ5LmlzWE1MRG9jKHRoaXMpICkge1xuXHRcdFx0XHQvLyBJRSBjb3BpZXMgZXZlbnRzIGJvdW5kIHZpYSBhdHRhY2hFdmVudCB3aGVuXG5cdFx0XHRcdC8vIHVzaW5nIGNsb25lTm9kZS4gQ2FsbGluZyBkZXRhY2hFdmVudCBvbiB0aGVcblx0XHRcdFx0Ly8gY2xvbmUgd2lsbCBhbHNvIHJlbW92ZSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWduYWxcblx0XHRcdFx0Ly8gSW4gb3JkZXIgdG8gZ2V0IGFyb3VuZCB0aGlzLCB3ZSB1c2UgaW5uZXJIVE1MLlxuXHRcdFx0XHQvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIG1lYW5zIHNvbWUgbW9kaWZpY2F0aW9ucyB0b1xuXHRcdFx0XHQvLyBhdHRyaWJ1dGVzIGluIElFIHRoYXQgYXJlIGFjdHVhbGx5IG9ubHkgc3RvcmVkXG5cdFx0XHRcdC8vIGFzIHByb3BlcnRpZXMgd2lsbCBub3QgYmUgY29waWVkIChzdWNoIGFzIHRoZVxuXHRcdFx0XHQvLyB0aGUgbmFtZSBhdHRyaWJ1dGUgb24gYW4gaW5wdXQpLlxuXHRcdFx0XHR2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZSh0cnVlKSxcblx0XHRcdFx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNsZWFuKFtjb250YWluZXIuaW5uZXJIVE1MXSlbMF07XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTmVlZCB0byBzZXQgdGhlIGV4cGFuZG8gdG8gbnVsbCBvbiB0aGUgY2xvbmVkIHNldCBpZiBpdCBleGlzdHNcblx0XHQvLyByZW1vdmVEYXRhIGRvZXNuJ3Qgd29yayBoZXJlLCBJRSByZW1vdmVzIGl0IGZyb20gdGhlIG9yaWdpbmFsIGFzIHdlbGxcblx0XHQvLyB0aGlzIGlzIHByaW1hcmlseSBmb3IgSUUgYnV0IHRoZSBkYXRhIGV4cGFuZG8gc2hvdWxkbid0IGJlIGNvcGllZCBvdmVyIGluIGFueSBicm93c2VyXG5cdFx0dmFyIGNsb25lID0gcmV0LmZpbmQoXCIqXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIHRoaXNbIGV4cGFuZG8gXSAhPT0gdW5kZWZpbmVkIClcblx0XHRcdFx0dGhpc1sgZXhwYW5kbyBdID0gbnVsbDtcblx0XHR9KTtcblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGV2ZW50cyA9PT0gdHJ1ZSApXG5cdFx0XHR0aGlzLmZpbmQoXCIqXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uKGkpe1xuXHRcdFx0XHRpZiAodGhpcy5ub2RlVHlwZSA9PSAzKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0dmFyIGV2ZW50cyA9IGpRdWVyeS5kYXRhKCB0aGlzLCBcImV2ZW50c1wiICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIHR5cGUgaW4gZXZlbnRzIClcblx0XHRcdFx0XHRmb3IgKCB2YXIgaGFuZGxlciBpbiBldmVudHNbIHR5cGUgXSApXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBjbG9uZVsgaSBdLCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaGFuZGxlciBdLCBldmVudHNbIHR5cGUgXVsgaGFuZGxlciBdLmRhdGEgKTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSAmJlxuXHRcdFx0alF1ZXJ5LmdyZXAodGhpcywgZnVuY3Rpb24oZWxlbSwgaSl7XG5cdFx0XHRcdHJldHVybiBzZWxlY3Rvci5jYWxsKCBlbGVtLCBpICk7XG5cdFx0XHR9KSB8fFxuXG5cdFx0XHRqUXVlcnkubXVsdGlGaWx0ZXIoIHNlbGVjdG9yLCBqUXVlcnkuZ3JlcCh0aGlzLCBmdW5jdGlvbihlbGVtKXtcblx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0XHR9KSApLCBcImZpbHRlclwiLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgcG9zID0galF1ZXJ5LmV4cHIubWF0Y2guUE9TLnRlc3QoIHNlbGVjdG9yICkgPyBqUXVlcnkoc2VsZWN0b3IpIDogbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGN1ciA9IHRoaXM7XG5cdFx0XHR3aGlsZSAoIGN1ciAmJiBjdXIub3duZXJEb2N1bWVudCApIHtcblx0XHRcdFx0aWYgKCBwb3MgPyBwb3MuaW5kZXgoY3VyKSA+IC0xIDogalF1ZXJ5KGN1cikuaXMoc2VsZWN0b3IpIClcblx0XHRcdFx0XHRyZXR1cm4gY3VyO1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApXG5cdFx0XHQvLyB0ZXN0IHNwZWNpYWwgY2FzZSB3aGVyZSBqdXN0IG9uZSBzZWxlY3RvciBpcyBwYXNzZWQgaW5cblx0XHRcdGlmICggaXNTaW1wbGUudGVzdCggc2VsZWN0b3IgKSApXG5cdFx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm11bHRpRmlsdGVyKCBzZWxlY3RvciwgdGhpcywgdHJ1ZSApLCBcIm5vdFwiLCBzZWxlY3RvciApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzZWxlY3RvciA9IGpRdWVyeS5tdWx0aUZpbHRlciggc2VsZWN0b3IsIHRoaXMgKTtcblxuXHRcdHZhciBpc0FycmF5TGlrZSA9IHNlbGVjdG9yLmxlbmd0aCAmJiBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSAhPT0gdW5kZWZpbmVkICYmICFzZWxlY3Rvci5ub2RlVHlwZTtcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaXNBcnJheUxpa2UgPyBqUXVlcnkuaW5BcnJheSggdGhpcywgc2VsZWN0b3IgKSA8IDAgOiB0aGlzICE9IHNlbGVjdG9yO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LnVuaXF1ZSggalF1ZXJ5Lm1lcmdlKFxuXHRcdFx0dGhpcy5nZXQoKSxcblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yIClcblx0XHQpKSk7XG5cdH0sXG5cblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISFzZWxlY3RvciAmJiBqUXVlcnkubXVsdGlGaWx0ZXIoIHNlbGVjdG9yLCB0aGlzICkubGVuZ3RoID4gMDtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXNlbGVjdG9yICYmIHRoaXMuaXMoIFwiLlwiICsgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XHRcdFx0XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbMF07XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aWYoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgJ29wdGlvbicgKSApXG5cdFx0XHRcdFx0cmV0dXJuIChlbGVtLmF0dHJpYnV0ZXMudmFsdWUgfHwge30pLnNwZWNpZmllZCA/IGVsZW0udmFsdWUgOiBlbGVtLnRleHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIGhhbmRsZSBzZWxlY3QgYm94ZXMgc3BlY2lhbFxuXHRcdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJzZWxlY3RcIiApICkge1xuXHRcdFx0XHRcdHZhciBpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRcdHZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PSBcInNlbGVjdC1vbmVcIjtcblxuXHRcdFx0XHRcdC8vIE5vdGhpbmcgd2FzIHNlbGVjdGVkXG5cdFx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBvbmUgPyBpbmRleCA6IDAsIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZjIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KG9wdGlvbikudmFsKCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdFx0aWYgKCBvbmUgKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWVzO1x0XHRcdFx0XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFdmVyeXRoaW5nIGVsc2UsIHdlIGp1c3QgZ3JhYiB0aGUgdmFsdWVcblx0XHRcdFx0cmV0dXJuIChlbGVtLnZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoL1xcci9nLCBcIlwiKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIClcblx0XHRcdHZhbHVlICs9ICcnO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9IDEgKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkodmFsdWUpICYmIC9yYWRpb3xjaGVja2JveC8udGVzdCggdGhpcy50eXBlICkgKVxuXHRcdFx0XHR0aGlzLmNoZWNrZWQgPSAoalF1ZXJ5LmluQXJyYXkodGhpcy52YWx1ZSwgdmFsdWUpID49IDAgfHxcblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSh0aGlzLm5hbWUsIHZhbHVlKSA+PSAwKTtcblxuXHRcdFx0ZWxzZSBpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJzZWxlY3RcIiApICkge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSh2YWx1ZSk7XG5cblx0XHRcdFx0alF1ZXJ5KCBcIm9wdGlvblwiLCB0aGlzICkuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWQgPSAoalF1ZXJ5LmluQXJyYXkoIHRoaXMudmFsdWUsIHZhbHVlcyApID49IDAgfHxcblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCB0aGlzLnRleHQsIHZhbHVlcyApID49IDApO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoICF2YWx1ZXMubGVuZ3RoIClcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcblxuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0KHRoaXNbMF0gP1xuXHRcdFx0XHR0aGlzWzBdLmlubmVySFRNTCA6XG5cdFx0XHRcdG51bGwpIDpcblx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gdGhpcy5hZnRlciggdmFsdWUgKS5yZW1vdmUoKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2xpY2UoIGksICtpICsgMSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICksXG5cdFx0XHRcInNsaWNlXCIsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIixcIikgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oZWxlbSwgaSl7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0pKTtcblx0fSxcblxuXHRhbmRTZWxmOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHRoaXMucHJldk9iamVjdCApO1xuXHR9LFxuXG5cdGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgdGFibGUsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdGhpc1swXSApIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICh0aGlzWzBdLm93bmVyRG9jdW1lbnQgfHwgdGhpc1swXSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdFx0XHRzY3JpcHRzID0galF1ZXJ5LmNsZWFuKCBhcmdzLCAodGhpc1swXS5vd25lckRvY3VtZW50IHx8IHRoaXNbMF0pLCBmcmFnbWVudCApLFxuXHRcdFx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQsXG5cdFx0XHRcdGV4dHJhID0gdGhpcy5sZW5ndGggPiAxID8gZnJhZ21lbnQuY2xvbmVOb2RlKHRydWUpIDogZnJhZ21lbnQ7XG5cblx0XHRcdGlmICggZmlyc3QgKVxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggcm9vdCh0aGlzW2ldLCBmaXJzdCksIGkgPiAwID8gZXh0cmEuY2xvbmVOb2RlKHRydWUpIDogZnJhZ21lbnQgKTtcblx0XHRcdFxuXHRcdFx0aWYgKCBzY3JpcHRzIClcblx0XHRcdFx0alF1ZXJ5LmVhY2goIHNjcmlwdHMsIGV2YWxTY3JpcHQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0XHRcblx0XHRmdW5jdGlvbiByb290KCBlbGVtLCBjdXIgKSB7XG5cdFx0XHRyZXR1cm4gdGFibGUgJiYgalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwidGFibGVcIikgJiYgalF1ZXJ5Lm5vZGVOYW1lKGN1ciwgXCJ0clwiKSA/XG5cdFx0XHRcdChlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHxcblx0XHRcdFx0ZWxlbS5hcHBlbmRDaGlsZChlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKSkgOlxuXHRcdFx0XHRlbGVtO1xuXHRcdH1cblx0fVxufTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxualF1ZXJ5LmZuLmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG5mdW5jdGlvbiBldmFsU2NyaXB0KCBpLCBlbGVtICkge1xuXHRpZiAoIGVsZW0uc3JjIClcblx0XHRqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IGVsZW0uc3JjLFxuXHRcdFx0YXN5bmM6IGZhbHNlLFxuXHRcdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCJcblx0XHR9KTtcblxuXHRlbHNlXG5cdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIGVsZW0udGV4dCB8fCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJIVE1MIHx8IFwiXCIgKTtcblxuXHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApXG5cdFx0ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbGVtICk7XG59XG5cbmZ1bmN0aW9uIG5vdygpe1xuXHRyZXR1cm4gK25ldyBEYXRlO1xufVxuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBjb3B5IHJlZmVyZW5jZSB0byB0YXJnZXQgb2JqZWN0XG5cdHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBkZWVwID0gZmFsc2UsIG9wdGlvbnM7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKVxuXHRcdHRhcmdldCA9IHt9O1xuXG5cdC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGxlbmd0aCA9PSBpICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0LS1pO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKVxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKVxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIHNyYyA9IHRhcmdldFsgbmFtZSBdLCBjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBvYmplY3QgdmFsdWVzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmIHR5cGVvZiBjb3B5ID09PSBcIm9iamVjdFwiICYmICFjb3B5Lm5vZGVUeXBlIClcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIFxuXHRcdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0XHRzcmMgfHwgKCBjb3B5Lmxlbmd0aCAhPSBudWxsID8gWyBdIDogeyB9IClcblx0XHRcdFx0XHQsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblxuXHRcdFx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4vLyBleGNsdWRlIHRoZSBmb2xsb3dpbmcgY3NzIHByb3BlcnRpZXMgdG8gYWRkIHB4XG52YXJcdGV4Y2x1ZGUgPSAvei0/aW5kZXh8Zm9udC0/d2VpZ2h0fG9wYWNpdHl8em9vbXxsaW5lLT9oZWlnaHQvaSxcblx0Ly8gY2FjaGUgZGVmYXVsdFZpZXdcblx0ZGVmYXVsdFZpZXcgPSBkb2N1bWVudC5kZWZhdWx0VmlldyB8fCB7fSxcblx0dG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0bm9Db25mbGljdDogZnVuY3Rpb24oIGRlZXAgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblxuXHRcdGlmICggZGVlcCApXG5cdFx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblxuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0sXG5cblx0Ly8gU2VlIHRlc3QvdW5pdC9jb3JlLmpzIGZvciBkZXRhaWxzIGNvbmNlcm5pbmcgaXNGdW5jdGlvbi5cblx0Ly8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxuXHQvLyBhcmVuJ3Qgc3VwcG9ydGVkLiBUaGV5IHJldHVybiBmYWxzZSBvbiBJRSAoIzI5NjgpLlxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcblx0fSxcblxuXHRpc0FycmF5OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcblx0fSxcblxuXHQvLyBjaGVjayBpZiBhbiBlbGVtZW50IGlzIGluIGEgKG9yIGlzIGFuKSBYTUwgZG9jdW1lbnRcblx0aXNYTUxEb2M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiB8fFxuXHRcdFx0ISFlbGVtLm93bmVyRG9jdW1lbnQgJiYgalF1ZXJ5LmlzWE1MRG9jKCBlbGVtLm93bmVyRG9jdW1lbnQgKTtcblx0fSxcblxuXHQvLyBFdmFsdWxhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0ZGF0YSA9IGpRdWVyeS50cmltKCBkYXRhICk7XG5cblx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHQvLyBJbnNwaXJlZCBieSBjb2RlIGJ5IEFuZHJlYSBHaWFtbWFyY2hpXG5cdFx0XHQvLyBodHRwOi8vd2VicmVmbGVjdGlvbi5ibG9nc3BvdC5jb20vMjAwNy8wOC9nbG9iYWwtc2NvcGUtZXZhbHVhdGlvbi1hbmQtZG9tLmh0bWxcblx0XHRcdHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblxuXHRcdFx0c2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuXHRcdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5zY3JpcHRFdmFsIClcblx0XHRcdFx0c2NyaXB0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggZGF0YSApICk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gZGF0YTtcblxuXHRcdFx0Ly8gVXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIGFwcGVuZENoaWxkICB0byBjaXJjdW12ZW50IGFuIElFNiBidWcuXG5cdFx0XHQvLyBUaGlzIGFyaXNlcyB3aGVuIGEgYmFzZSBub2RlIGlzIHVzZWQgKCMyNzA5KS5cblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApO1xuXHRcdFx0aGVhZC5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iamVjdCwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIG5hbWUsIGkgPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuXG5cdFx0aWYgKCBhcmdzICkge1xuXHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Zm9yICggbmFtZSBpbiBvYmplY3QgKVxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9iamVjdFsgbmFtZSBdLCBhcmdzICkgPT09IGZhbHNlIClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgKVxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9iamVjdFsgaSsrIF0sIGFyZ3MgKSA9PT0gZmFsc2UgKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRmb3IgKCBuYW1lIGluIG9iamVjdCApXG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmplY3RbIG5hbWUgXSwgbmFtZSwgb2JqZWN0WyBuYW1lIF0gKSA9PT0gZmFsc2UgKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0Zm9yICggdmFyIHZhbHVlID0gb2JqZWN0WzBdO1xuXHRcdFx0XHRcdGkgPCBsZW5ndGggJiYgY2FsbGJhY2suY2FsbCggdmFsdWUsIGksIHZhbHVlICkgIT09IGZhbHNlOyB2YWx1ZSA9IG9iamVjdFsrK2ldICl7fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3Q7XG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCB0eXBlLCBpLCBuYW1lICkge1xuXHRcdC8vIEhhbmRsZSBleGVjdXRhYmxlIGZ1bmN0aW9uc1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKVxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5jYWxsKCBlbGVtLCBpICk7XG5cblx0XHQvLyBIYW5kbGUgcGFzc2luZyBpbiBhIG51bWJlciB0byBhIENTUyBwcm9wZXJ0eVxuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdHlwZSA9PSBcImN1ckNTU1wiICYmICFleGNsdWRlLnRlc3QoIG5hbWUgKSA/XG5cdFx0XHR2YWx1ZSArIFwicHhcIiA6XG5cdFx0XHR2YWx1ZTtcblx0fSxcblxuXHRjbGFzc05hbWU6IHtcblx0XHQvLyBpbnRlcm5hbCBvbmx5LCB1c2UgYWRkQ2xhc3MoXCJjbGFzc1wiKVxuXHRcdGFkZDogZnVuY3Rpb24oIGVsZW0sIGNsYXNzTmFtZXMgKSB7XG5cdFx0XHRqUXVlcnkuZWFjaCgoY2xhc3NOYW1lcyB8fCBcIlwiKS5zcGxpdCgvXFxzKy8pLCBmdW5jdGlvbihpLCBjbGFzc05hbWUpe1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT0gMSAmJiAhalF1ZXJ5LmNsYXNzTmFtZS5oYXMoIGVsZW0uY2xhc3NOYW1lLCBjbGFzc05hbWUgKSApXG5cdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgKz0gKGVsZW0uY2xhc3NOYW1lID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTmFtZTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyBpbnRlcm5hbCBvbmx5LCB1c2UgcmVtb3ZlQ2xhc3MoXCJjbGFzc1wiKVxuXHRcdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIGNsYXNzTmFtZXMgKSB7XG5cdFx0XHRpZiAoZWxlbS5ub2RlVHlwZSA9PSAxKVxuXHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0alF1ZXJ5LmdyZXAoZWxlbS5jbGFzc05hbWUuc3BsaXQoL1xccysvKSwgZnVuY3Rpb24oY2xhc3NOYW1lKXtcblx0XHRcdFx0XHRcdHJldHVybiAhalF1ZXJ5LmNsYXNzTmFtZS5oYXMoIGNsYXNzTmFtZXMsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0pLmpvaW4oXCIgXCIpIDpcblx0XHRcdFx0XHRcIlwiO1xuXHRcdH0sXG5cblx0XHQvLyBpbnRlcm5hbCBvbmx5LCB1c2UgaGFzQ2xhc3MoXCJjbGFzc1wiKVxuXHRcdGhhczogZnVuY3Rpb24oIGVsZW0sIGNsYXNzTmFtZSApIHtcblx0XHRcdHJldHVybiBlbGVtICYmIGpRdWVyeS5pbkFycmF5KCBjbGFzc05hbWUsIChlbGVtLmNsYXNzTmFtZSB8fCBlbGVtKS50b1N0cmluZygpLnNwbGl0KC9cXHMrLykgKSA+IC0xO1xuXHRcdH1cblx0fSxcblxuXHQvLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zXG5cdHN3YXA6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0XHR2YXIgb2xkID0ge307XG5cdFx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHRcdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRcdGZvciAoIHZhciBuYW1lIGluIG9wdGlvbnMgKVxuXHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZm9yY2UgKSB7XG5cdFx0aWYgKCBuYW1lID09IFwid2lkdGhcIiB8fCBuYW1lID09IFwiaGVpZ2h0XCIgKSB7XG5cdFx0XHR2YXIgdmFsLCBwcm9wcyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTpcImJsb2NrXCIgfSwgd2hpY2ggPSBuYW1lID09IFwid2lkdGhcIiA/IFsgXCJMZWZ0XCIsIFwiUmlnaHRcIiBdIDogWyBcIlRvcFwiLCBcIkJvdHRvbVwiIF07XG5cblx0XHRcdGZ1bmN0aW9uIGdldFdIKCkge1xuXHRcdFx0XHR2YWwgPSBuYW1lID09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodDtcblx0XHRcdFx0dmFyIHBhZGRpbmcgPSAwLCBib3JkZXIgPSAwO1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggd2hpY2gsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHBhZGRpbmcgKz0gcGFyc2VGbG9hdChqUXVlcnkuY3VyQ1NTKCBlbGVtLCBcInBhZGRpbmdcIiArIHRoaXMsIHRydWUpKSB8fCAwO1xuXHRcdFx0XHRcdGJvcmRlciArPSBwYXJzZUZsb2F0KGpRdWVyeS5jdXJDU1MoIGVsZW0sIFwiYm9yZGVyXCIgKyB0aGlzICsgXCJXaWR0aFwiLCB0cnVlKSkgfHwgMDtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHZhbCAtPSBNYXRoLnJvdW5kKHBhZGRpbmcgKyBib3JkZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpRdWVyeShlbGVtKS5pcyhcIjp2aXNpYmxlXCIpIClcblx0XHRcdFx0Z2V0V0goKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIHByb3BzLCBnZXRXSCApO1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgdmFsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmN1ckNTUyggZWxlbSwgbmFtZSwgZm9yY2UgKTtcblx0fSxcblxuXHRjdXJDU1M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBmb3JjZSApIHtcblx0XHR2YXIgcmV0LCBzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGhhbmRsZSBvcGFjaXR5IHNwZWNpYWwgaW4gSUVcblx0XHRpZiAoIG5hbWUgPT0gXCJvcGFjaXR5XCIgJiYgIWpRdWVyeS5zdXBwb3J0Lm9wYWNpdHkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuYXR0ciggc3R5bGUsIFwib3BhY2l0eVwiICk7XG5cblx0XHRcdHJldHVybiByZXQgPT0gXCJcIiA/XG5cdFx0XHRcdFwiMVwiIDpcblx0XHRcdFx0cmV0O1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSdyZSB1c2luZyB0aGUgcmlnaHQgbmFtZSBmb3IgZ2V0dGluZyB0aGUgZmxvYXQgdmFsdWVcblx0XHRpZiAoIG5hbWUubWF0Y2goIC9mbG9hdC9pICkgKVxuXHRcdFx0bmFtZSA9IHN0eWxlRmxvYXQ7XG5cblx0XHRpZiAoICFmb3JjZSAmJiBzdHlsZSAmJiBzdHlsZVsgbmFtZSBdIClcblx0XHRcdHJldCA9IHN0eWxlWyBuYW1lIF07XG5cblx0XHRlbHNlIGlmICggZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblxuXHRcdFx0Ly8gT25seSBcImZsb2F0XCIgaXMgbmVlZGVkIGhlcmVcblx0XHRcdGlmICggbmFtZS5tYXRjaCggL2Zsb2F0L2kgKSApXG5cdFx0XHRcdG5hbWUgPSBcImZsb2F0XCI7XG5cblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoIC8oW0EtWl0pL2csIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHR2YXIgY29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblxuXHRcdFx0aWYgKCBjb21wdXRlZFN0eWxlIClcblx0XHRcdFx0cmV0ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICk7XG5cblx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRpZiAoIG5hbWUgPT0gXCJvcGFjaXR5XCIgJiYgcmV0ID09IFwiXCIgKVxuXHRcdFx0XHRyZXQgPSBcIjFcIjtcblxuXHRcdH0gZWxzZSBpZiAoIGVsZW0uY3VycmVudFN0eWxlICkge1xuXHRcdFx0dmFyIGNhbWVsQ2FzZSA9IG5hbWUucmVwbGFjZSgvXFwtKFxcdykvZywgZnVuY3Rpb24oYWxsLCBsZXR0ZXIpe1xuXHRcdFx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0ID0gZWxlbS5jdXJyZW50U3R5bGVbIG5hbWUgXSB8fCBlbGVtLmN1cnJlbnRTdHlsZVsgY2FtZWxDYXNlIF07XG5cblx0XHRcdC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcblx0XHRcdC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcblxuXHRcdFx0Ly8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG5cdFx0XHQvLyBidXQgYSBudW1iZXIgdGhhdCBoYXMgYSB3ZWlyZCBlbmRpbmcsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBwaXhlbHNcblx0XHRcdGlmICggIS9eXFxkKyhweCk/JC9pLnRlc3QoIHJldCApICYmIC9eXFxkLy50ZXN0KCByZXQgKSApIHtcblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0XHR2YXIgbGVmdCA9IHN0eWxlLmxlZnQsIHJzTGVmdCA9IGVsZW0ucnVudGltZVN0eWxlLmxlZnQ7XG5cblx0XHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0XHRlbGVtLnJ1bnRpbWVTdHlsZS5sZWZ0ID0gZWxlbS5jdXJyZW50U3R5bGUubGVmdDtcblx0XHRcdFx0c3R5bGUubGVmdCA9IHJldCB8fCAwO1xuXHRcdFx0XHRyZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cblx0XHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0XHRzdHlsZS5sZWZ0ID0gbGVmdDtcblx0XHRcdFx0ZWxlbS5ydW50aW1lU3R5bGUubGVmdCA9IHJzTGVmdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGNsZWFuOiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIGZyYWdtZW50ICkge1xuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gIWNvbnRleHQuY3JlYXRlRWxlbWVudCBmYWlscyBpbiBJRSB3aXRoIGFuIGVycm9yIGJ1dCByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuY3JlYXRlRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiApXG5cdFx0XHRjb250ZXh0ID0gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHRbMF0gJiYgY29udGV4dFswXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gSWYgYSBzaW5nbGUgc3RyaW5nIGlzIHBhc3NlZCBpbiBhbmQgaXQncyBhIHNpbmdsZSB0YWdcblx0XHQvLyBqdXN0IGRvIGEgY3JlYXRlRWxlbWVudCBhbmQgc2tpcCB0aGUgcmVzdFxuXHRcdGlmICggIWZyYWdtZW50ICYmIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZWxlbXNbMF0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSAvXjwoXFx3KylcXHMqXFwvPz4kLy5leGVjKGVsZW1zWzBdKTtcblx0XHRcdGlmICggbWF0Y2ggKVxuXHRcdFx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIG1hdGNoWzFdICkgXTtcblx0XHR9XG5cblx0XHR2YXIgcmV0ID0gW10sIHNjcmlwdHMgPSBbXSwgZGl2ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdFx0alF1ZXJ5LmVhY2goZWxlbXMsIGZ1bmN0aW9uKGksIGVsZW0pe1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJudW1iZXJcIiApXG5cdFx0XHRcdGVsZW0gKz0gJyc7XG5cblx0XHRcdGlmICggIWVsZW0gKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBzdHJpbmcgaW50byBET00gbm9kZXNcblx0XHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vIEZpeCBcIlhIVE1MXCItc3R5bGUgdGFncyBpbiBhbGwgYnJvd3NlcnNcblx0XHRcdFx0ZWxlbSA9IGVsZW0ucmVwbGFjZSgvKDwoXFx3KylbXj5dKj8pXFwvPi9nLCBmdW5jdGlvbihhbGwsIGZyb250LCB0YWcpe1xuXHRcdFx0XHRcdHJldHVybiB0YWcubWF0Y2goL14oYWJicnxicnxjb2x8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbXxocnxhcmVhfGVtYmVkKSQvaSkgP1xuXHRcdFx0XHRcdFx0YWxsIDpcblx0XHRcdFx0XHRcdGZyb250ICsgXCI+PC9cIiArIHRhZyArIFwiPlwiO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBUcmltIHdoaXRlc3BhY2UsIG90aGVyd2lzZSBpbmRleE9mIHdvbid0IHdvcmsgYXMgZXhwZWN0ZWRcblx0XHRcdFx0dmFyIHRhZ3MgPSBqUXVlcnkudHJpbSggZWxlbSApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0dmFyIHdyYXAgPVxuXHRcdFx0XHRcdC8vIG9wdGlvbiBvciBvcHRncm91cFxuXHRcdFx0XHRcdCF0YWdzLmluZGV4T2YoXCI8b3B0XCIpICYmXG5cdFx0XHRcdFx0WyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdIHx8XG5cblx0XHRcdFx0XHQhdGFncy5pbmRleE9mKFwiPGxlZ1wiKSAmJlxuXHRcdFx0XHRcdFsgMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIiBdIHx8XG5cblx0XHRcdFx0XHR0YWdzLm1hdGNoKC9ePCh0aGVhZHx0Ym9keXx0Zm9vdHxjb2xnfGNhcCkvKSAmJlxuXHRcdFx0XHRcdFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdIHx8XG5cblx0XHRcdFx0XHQhdGFncy5pbmRleE9mKFwiPHRyXCIpICYmXG5cdFx0XHRcdFx0WyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0gfHxcblxuXHRcdFx0XHQgXHQvLyA8dGhlYWQ+IG1hdGNoZWQgYWJvdmVcblx0XHRcdFx0XHQoIXRhZ3MuaW5kZXhPZihcIjx0ZFwiKSB8fCAhdGFncy5pbmRleE9mKFwiPHRoXCIpKSAmJlxuXHRcdFx0XHRcdFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdIHx8XG5cblx0XHRcdFx0XHQhdGFncy5pbmRleE9mKFwiPGNvbFwiKSAmJlxuXHRcdFx0XHRcdFsgMiwgXCI8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdIHx8XG5cblx0XHRcdFx0XHQvLyBJRSBjYW4ndCBzZXJpYWxpemUgPGxpbms+IGFuZCA8c2NyaXB0PiB0YWdzIG5vcm1hbGx5XG5cdFx0XHRcdFx0IWpRdWVyeS5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgJiZcblx0XHRcdFx0XHRbIDEsIFwiZGl2PGRpdj5cIiwgXCI8L2Rpdj5cIiBdIHx8XG5cblx0XHRcdFx0XHRbIDAsIFwiXCIsIFwiXCIgXTtcblxuXHRcdFx0XHQvLyBHbyB0byBodG1sIGFuZCBiYWNrLCB0aGVuIHBlZWwgb2ZmIGV4dHJhIHdyYXBwZXJzXG5cdFx0XHRcdGRpdi5pbm5lckhUTUwgPSB3cmFwWzFdICsgZWxlbSArIHdyYXBbMl07XG5cblx0XHRcdFx0Ly8gTW92ZSB0byB0aGUgcmlnaHQgZGVwdGhcblx0XHRcdFx0d2hpbGUgKCB3cmFwWzBdLS0gKVxuXHRcdFx0XHRcdGRpdiA9IGRpdi5sYXN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIElFJ3MgYXV0b2luc2VydGVkIDx0Ym9keT4gZnJvbSB0YWJsZSBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQudGJvZHkgKSB7XG5cblx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgPHRhYmxlPiwgKm1heSogaGF2ZSBzcHVyaW91cyA8dGJvZHk+XG5cdFx0XHRcdFx0dmFyIHRib2R5ID0gIXRhZ3MuaW5kZXhPZihcIjx0YWJsZVwiKSAmJiB0YWdzLmluZGV4T2YoXCI8dGJvZHlcIikgPCAwID9cblx0XHRcdFx0XHRcdGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLmNoaWxkTm9kZXMgOlxuXG5cdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgYmFyZSA8dGhlYWQ+IG9yIDx0Zm9vdD5cblx0XHRcdFx0XHRcdHdyYXBbMV0gPT0gXCI8dGFibGU+XCIgJiYgdGFncy5pbmRleE9mKFwiPHRib2R5XCIpIDwgMCA/XG5cdFx0XHRcdFx0XHRcdGRpdi5jaGlsZE5vZGVzIDpcblx0XHRcdFx0XHRcdFx0W107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IHRib2R5Lmxlbmd0aCAtIDE7IGogPj0gMCA7IC0taiApXG5cdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGJvZHlbIGogXSwgXCJ0Ym9keVwiICkgJiYgIXRib2R5WyBqIF0uY2hpbGROb2Rlcy5sZW5ndGggKVxuXHRcdFx0XHRcdFx0XHR0Ym9keVsgaiBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRib2R5WyBqIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJRSBjb21wbGV0ZWx5IGtpbGxzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIGlubmVySFRNTCBpcyB1c2VkXG5cdFx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIC9eXFxzLy50ZXN0KCBlbGVtICkgKVxuXHRcdFx0XHRcdGRpdi5pbnNlcnRCZWZvcmUoIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0ubWF0Y2goL15cXHMqLylbMF0gKSwgZGl2LmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0XG5cdFx0XHRcdGVsZW0gPSBqUXVlcnkubWFrZUFycmF5KCBkaXYuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgKVxuXHRcdFx0XHRyZXQucHVzaCggZWxlbSApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXQgPSBqUXVlcnkubWVyZ2UoIHJldCwgZWxlbSApO1xuXG5cdFx0fSk7XG5cblx0XHRpZiAoIGZyYWdtZW50ICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyByZXRbaV07IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHJldFtpXSwgXCJzY3JpcHRcIiApICYmICghcmV0W2ldLnR5cGUgfHwgcmV0W2ldLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIikgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCByZXRbaV0ucGFyZW50Tm9kZSA/IHJldFtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCByZXRbaV0gKSA6IHJldFtpXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggcmV0W2ldLm5vZGVUeXBlID09PSAxIClcblx0XHRcdFx0XHRcdHJldC5zcGxpY2UuYXBwbHkoIHJldCwgW2kgKyAxLCAwXS5jb25jYXQoalF1ZXJ5Lm1ha2VBcnJheShyZXRbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpKSApO1xuXHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKCByZXRbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gc2NyaXB0cztcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHQvLyBkb24ndCBzZXQgYXR0cmlidXRlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT0gMyB8fCBlbGVtLm5vZGVUeXBlID09IDgpXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0dmFyIG5vdHhtbCA9ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSxcblx0XHRcdC8vIFdoZXRoZXIgd2UgYXJlIHNldHRpbmcgKG9yIGdldHRpbmcpXG5cdFx0XHRzZXQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0Ly8gVHJ5IHRvIG5vcm1hbGl6ZS9maXggdGhlIG5hbWVcblx0XHRuYW1lID0gbm90eG1sICYmIGpRdWVyeS5wcm9wc1sgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHQvLyBPbmx5IGRvIGFsbCB0aGUgZm9sbG93aW5nIGlmIHRoaXMgaXMgYSBub2RlIChmYXN0ZXIgZm9yIHN0eWxlKVxuXHRcdC8vIElFIGVsZW0uZ2V0QXR0cmlidXRlIHBhc3NlcyBldmVuIGZvciBzdHlsZVxuXHRcdGlmICggZWxlbS50YWdOYW1lICkge1xuXG5cdFx0XHQvLyBUaGVzZSBhdHRyaWJ1dGVzIHJlcXVpcmUgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRcdHZhciBzcGVjaWFsID0gL2hyZWZ8c3JjfHN0eWxlLy50ZXN0KCBuYW1lICk7XG5cblx0XHRcdC8vIFNhZmFyaSBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhIGhpZGRlbiBvcHRpb25cblx0XHRcdC8vIEFjY2Vzc2luZyB0aGUgcGFyZW50J3Mgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBmaXhlcyBpdFxuXHRcdFx0aWYgKCBuYW1lID09IFwic2VsZWN0ZWRcIiAmJiBlbGVtLnBhcmVudE5vZGUgKVxuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0Ly8gSWYgYXBwbGljYWJsZSwgYWNjZXNzIHRoZSBhdHRyaWJ1dGUgdmlhIHRoZSBET00gMCB3YXlcblx0XHRcdGlmICggbmFtZSBpbiBlbGVtICYmIG5vdHhtbCAmJiAhc3BlY2lhbCApIHtcblx0XHRcdFx0aWYgKCBzZXQgKXtcblx0XHRcdFx0XHQvLyBXZSBjYW4ndCBhbGxvdyB0aGUgdHlwZSBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkIChzaW5jZSBpdCBjYXVzZXMgcHJvYmxlbXMgaW4gSUUpXG5cdFx0XHRcdFx0aWYgKCBuYW1lID09IFwidHlwZVwiICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgJiYgZWxlbS5wYXJlbnROb2RlIClcblx0XHRcdFx0XHRcdHRocm93IFwidHlwZSBwcm9wZXJ0eSBjYW4ndCBiZSBjaGFuZ2VkXCI7XG5cblx0XHRcdFx0XHRlbGVtWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGJyb3dzZXJzIGluZGV4IGVsZW1lbnRzIGJ5IGlkL25hbWUgb24gZm9ybXMsIGdpdmUgcHJpb3JpdHkgdG8gYXR0cmlidXRlcy5cblx0XHRcdFx0aWYoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJmb3JtXCIgKSAmJiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkgKVxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKS5ub2RlVmFsdWU7XG5cblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHRpZiAoIG5hbWUgPT0gXCJ0YWJJbmRleFwiICkge1xuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVOb2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcInRhYkluZGV4XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gYXR0cmlidXRlTm9kZSAmJiBhdHRyaWJ1dGVOb2RlLnNwZWNpZmllZFxuXHRcdFx0XHRcdFx0PyBhdHRyaWJ1dGVOb2RlLnZhbHVlXG5cdFx0XHRcdFx0XHQ6IGVsZW0ubm9kZU5hbWUubWF0Y2goLyhidXR0b258aW5wdXR8b2JqZWN0fHNlbGVjdHx0ZXh0YXJlYSkvaSlcblx0XHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHRcdDogZWxlbS5ub2RlTmFtZS5tYXRjaCgvXihhfGFyZWEpJC9pKSAmJiBlbGVtLmhyZWZcblx0XHRcdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdFx0XHQ6IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LnN0eWxlICYmIG5vdHhtbCAmJiAgbmFtZSA9PSBcInN0eWxlXCIgKVxuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmF0dHIoIGVsZW0uc3R5bGUsIFwiY3NzVGV4dFwiLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIHNldCApXG5cdFx0XHRcdC8vIGNvbnZlcnQgdGhlIHZhbHVlIHRvIGEgc3RyaW5nIChhbGwgYnJvd3NlcnMgZG8gdGhpcyBidXQgSUUpIHNlZSAjMTA3MFxuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgXCJcIiArIHZhbHVlICk7XG5cblx0XHRcdHZhciBhdHRyID0gIWpRdWVyeS5zdXBwb3J0LmhyZWZOb3JtYWxpemVkICYmIG5vdHhtbCAmJiBzcGVjaWFsXG5cdFx0XHRcdFx0Ly8gU29tZSBhdHRyaWJ1dGVzIHJlcXVpcmUgYSBzcGVjaWFsIGNhbGwgb24gSUVcblx0XHRcdFx0XHQ/IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCAyIClcblx0XHRcdFx0XHQ6IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gYXR0ciA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGF0dHI7XG5cdFx0fVxuXG5cdFx0Ly8gZWxlbSBpcyBhY3R1YWxseSBlbGVtLnN0eWxlIC4uLiBzZXQgdGhlIHN0eWxlXG5cblx0XHQvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcblx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC5vcGFjaXR5ICYmIG5hbWUgPT0gXCJvcGFjaXR5XCIgKSB7XG5cdFx0XHRpZiAoIHNldCApIHtcblx0XHRcdFx0Ly8gSUUgaGFzIHRyb3VibGUgd2l0aCBvcGFjaXR5IGlmIGl0IGRvZXMgbm90IGhhdmUgbGF5b3V0XG5cdFx0XHRcdC8vIEZvcmNlIGl0IGJ5IHNldHRpbmcgdGhlIHpvb20gbGV2ZWxcblx0XHRcdFx0ZWxlbS56b29tID0gMTtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIGFscGhhIGZpbHRlciB0byBzZXQgdGhlIG9wYWNpdHlcblx0XHRcdFx0ZWxlbS5maWx0ZXIgPSAoZWxlbS5maWx0ZXIgfHwgXCJcIikucmVwbGFjZSggL2FscGhhXFwoW14pXSpcXCkvLCBcIlwiICkgK1xuXHRcdFx0XHRcdChwYXJzZUludCggdmFsdWUgKSArICcnID09IFwiTmFOXCIgPyBcIlwiIDogXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmZpbHRlciAmJiBlbGVtLmZpbHRlci5pbmRleE9mKFwib3BhY2l0eT1cIikgPj0gMCA/XG5cdFx0XHRcdChwYXJzZUZsb2F0KCBlbGVtLmZpbHRlci5tYXRjaCgvb3BhY2l0eT0oW14pXSopLylbMV0gKSAvIDEwMCkgKyAnJzpcblx0XHRcdFx0XCJcIjtcblx0XHR9XG5cblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC8tKFthLXpdKS9pZywgZnVuY3Rpb24oYWxsLCBsZXR0ZXIpe1xuXHRcdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCBzZXQgKVxuXHRcdFx0ZWxlbVsgbmFtZSBdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiAodGV4dCB8fCBcIlwiKS5yZXBsYWNlKCAvXlxccyt8XFxzKyQvZywgXCJcIiApO1xuXHR9LFxuXG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdHZhciByZXQgPSBbXTtcblxuXHRcdGlmKCBhcnJheSAhPSBudWxsICl7XG5cdFx0XHR2YXIgaSA9IGFycmF5Lmxlbmd0aDtcblx0XHRcdC8vIFRoZSB3aW5kb3csIHN0cmluZ3MgKGFuZCBmdW5jdGlvbnMpIGFsc28gaGF2ZSAnbGVuZ3RoJ1xuXHRcdFx0aWYoIGkgPT0gbnVsbCB8fCB0eXBlb2YgYXJyYXkgPT09IFwic3RyaW5nXCIgfHwgalF1ZXJ5LmlzRnVuY3Rpb24oYXJyYXkpIHx8IGFycmF5LnNldEludGVydmFsIClcblx0XHRcdFx0cmV0WzBdID0gYXJyYXk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHdoaWxlKCBpIClcblx0XHRcdFx0XHRyZXRbLS1pXSA9IGFycmF5W2ldO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFycmF5ICkge1xuXHRcdGZvciAoIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKVxuXHRcdC8vIFVzZSA9PT0gYmVjYXVzZSBvbiBJRSwgd2luZG93ID09IGRvY3VtZW50XG5cdFx0XHRpZiAoIGFycmF5WyBpIF0gPT09IGVsZW0gKVxuXHRcdFx0XHRyZXR1cm4gaTtcblxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0Ly8gV2UgaGF2ZSB0byBsb29wIHRoaXMgd2F5IGJlY2F1c2UgSUUgJiBPcGVyYSBvdmVyd3JpdGUgdGhlIGxlbmd0aFxuXHRcdC8vIGV4cGFuZG8gb2YgZ2V0RWxlbWVudHNCeVRhZ05hbWVcblx0XHR2YXIgaSA9IDAsIGVsZW0sIHBvcyA9IGZpcnN0Lmxlbmd0aDtcblx0XHQvLyBBbHNvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb3JyZWN0IGVsZW1lbnRzIGFyZSBiZWluZyByZXR1cm5lZFxuXHRcdC8vIChJRSByZXR1cm5zIGNvbW1lbnQgbm9kZXMgaW4gYSAnKicgcXVlcnkpXG5cdFx0aWYgKCAhalF1ZXJ5LnN1cHBvcnQuZ2V0QWxsICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IHNlY29uZFsgaSsrIF0pICE9IG51bGwgKVxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgIT0gOCApXG5cdFx0XHRcdFx0Zmlyc3RbIHBvcysrIF0gPSBlbGVtO1xuXG5cdFx0fSBlbHNlXG5cdFx0XHR3aGlsZSAoIChlbGVtID0gc2Vjb25kWyBpKysgXSkgIT0gbnVsbCApXG5cdFx0XHRcdGZpcnN0WyBwb3MrKyBdID0gZWxlbTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHR1bmlxdWU6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHR2YXIgcmV0ID0gW10sIGRvbmUgPSB7fTtcblxuXHRcdHRyeSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhciBpZCA9IGpRdWVyeS5kYXRhKCBhcnJheVsgaSBdICk7XG5cblx0XHRcdFx0aWYgKCAhZG9uZVsgaWQgXSApIHtcblx0XHRcdFx0XHRkb25lWyBpZCBdID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXQucHVzaCggYXJyYXlbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGNhdGNoKCBlICkge1xuXHRcdFx0cmV0ID0gYXJyYXk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnYgKSB7XG5cdFx0dmFyIHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsZW5ndGggPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyApXG5cdFx0XHRpZiAoICFpbnYgIT0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICkgKVxuXHRcdFx0XHRyZXQucHVzaCggZWxlbXNbIGkgXSApO1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyXG5cdFx0Ly8gbmV3IHZhbHVlIChvciB2YWx1ZXMpLlxuXHRcdGZvciAoIHZhciBpID0gMCwgbGVuZ3RoID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXG5cdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKVxuXHRcdFx0XHRyZXRbIHJldC5sZW5ndGggXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQuY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH1cbn0pO1xuXG4vLyBVc2Ugb2YgalF1ZXJ5LmJyb3dzZXIgaXMgZGVwcmVjYXRlZC5cbi8vIEl0J3MgaW5jbHVkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZCBwbHVnaW5zLFxuLy8gYWx0aG91Z2ggdGhleSBzaG91bGQgd29yayB0byBtaWdyYXRlIGF3YXkuXG5cbnZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cbi8vIEZpZ3VyZSBvdXQgd2hhdCBicm93c2VyIGlzIGJlaW5nIHVzZWRcbmpRdWVyeS5icm93c2VyID0ge1xuXHR2ZXJzaW9uOiAodXNlckFnZW50Lm1hdGNoKCAvLisoPzpydnxpdHxyYXxpZSlbXFwvOiBdKFtcXGQuXSspLyApIHx8IFswLCcwJ10pWzFdLFxuXHRzYWZhcmk6IC93ZWJraXQvLnRlc3QoIHVzZXJBZ2VudCApLFxuXHRvcGVyYTogL29wZXJhLy50ZXN0KCB1c2VyQWdlbnQgKSxcblx0bXNpZTogL21zaWUvLnRlc3QoIHVzZXJBZ2VudCApICYmICEvb3BlcmEvLnRlc3QoIHVzZXJBZ2VudCApLFxuXHRtb3ppbGxhOiAvbW96aWxsYS8udGVzdCggdXNlckFnZW50ICkgJiYgIS8oY29tcGF0aWJsZXx3ZWJraXQpLy50ZXN0KCB1c2VyQWdlbnQgKVxufTtcblxualF1ZXJ5LmVhY2goe1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKGVsZW0pe3JldHVybiBlbGVtLnBhcmVudE5vZGU7fSxcblx0cGFyZW50czogZnVuY3Rpb24oZWxlbSl7cmV0dXJuIGpRdWVyeS5kaXIoZWxlbSxcInBhcmVudE5vZGVcIik7fSxcblx0bmV4dDogZnVuY3Rpb24oZWxlbSl7cmV0dXJuIGpRdWVyeS5udGgoZWxlbSwyLFwibmV4dFNpYmxpbmdcIik7fSxcblx0cHJldjogZnVuY3Rpb24oZWxlbSl7cmV0dXJuIGpRdWVyeS5udGgoZWxlbSwyLFwicHJldmlvdXNTaWJsaW5nXCIpO30sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKGVsZW0pe3JldHVybiBqUXVlcnkuZGlyKGVsZW0sXCJuZXh0U2libGluZ1wiKTt9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbihlbGVtKXtyZXR1cm4galF1ZXJ5LmRpcihlbGVtLFwicHJldmlvdXNTaWJsaW5nXCIpO30sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbihlbGVtKXtyZXR1cm4galF1ZXJ5LnNpYmxpbmcoZWxlbS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQsZWxlbSk7fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKGVsZW0pe3JldHVybiBqUXVlcnkuc2libGluZyhlbGVtLmZpcnN0Q2hpbGQpO30sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbihlbGVtKXtyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKGVsZW0sXCJpZnJhbWVcIik/ZWxlbS5jb250ZW50RG9jdW1lbnR8fGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudDpqUXVlcnkubWFrZUFycmF5KGVsZW0uY2hpbGROb2Rlcyk7fVxufSwgZnVuY3Rpb24obmFtZSwgZm4pe1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1hcCggdGhpcywgZm4gKTtcblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09IFwic3RyaW5nXCIgKVxuXHRcdFx0cmV0ID0galF1ZXJ5Lm11bHRpRmlsdGVyKCBzZWxlY3RvciwgcmV0ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS51bmlxdWUoIHJldCApLCBuYW1lLCBzZWxlY3RvciApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5lYWNoKHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbihuYW1lLCBvcmlnaW5hbCl7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKVxuXHRcdFx0XHRqUXVlcnkoIGFyZ3NbIGkgXSApWyBvcmlnaW5hbCBdKCB0aGlzICk7XG5cdFx0fSk7XG5cdH07XG59KTtcblxualF1ZXJ5LmVhY2goe1xuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRqUXVlcnkuYXR0ciggdGhpcywgbmFtZSwgXCJcIiApO1xuXHRcdGlmICh0aGlzLm5vZGVUeXBlID09IDEpXG5cdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHR9LFxuXG5cdGFkZENsYXNzOiBmdW5jdGlvbiggY2xhc3NOYW1lcyApIHtcblx0XHRqUXVlcnkuY2xhc3NOYW1lLmFkZCggdGhpcywgY2xhc3NOYW1lcyApO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggY2xhc3NOYW1lcyApIHtcblx0XHRqUXVlcnkuY2xhc3NOYW1lLnJlbW92ZSggdGhpcywgY2xhc3NOYW1lcyApO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggY2xhc3NOYW1lcywgc3RhdGUgKSB7XG5cdFx0aWYoIHR5cGVvZiBzdGF0ZSAhPT0gXCJib29sZWFuXCIgKVxuXHRcdFx0c3RhdGUgPSAhalF1ZXJ5LmNsYXNzTmFtZS5oYXMoIHRoaXMsIGNsYXNzTmFtZXMgKTtcblx0XHRqUXVlcnkuY2xhc3NOYW1lWyBzdGF0ZSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiIF0oIHRoaXMsIGNsYXNzTmFtZXMgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRpZiAoICFzZWxlY3RvciB8fCBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgWyB0aGlzIF0gKS5sZW5ndGggKSB7XG5cdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0alF1ZXJ5KCBcIipcIiwgdGhpcyApLmFkZChbdGhpc10pLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSh0aGlzKTtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEodGhpcyk7XG5cdFx0XHR9KTtcblx0XHRcdGlmICh0aGlzLnBhcmVudE5vZGUpXG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGhpcyApO1xuXHRcdH1cblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0alF1ZXJ5KCBcIj4qXCIsIHRoaXMgKS5yZW1vdmUoKTtcblxuXHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0d2hpbGUgKCB0aGlzLmZpcnN0Q2hpbGQgKVxuXHRcdFx0dGhpcy5yZW1vdmVDaGlsZCggdGhpcy5maXJzdENoaWxkICk7XG5cdH1cbn0sIGZ1bmN0aW9uKG5hbWUsIGZuKXtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZuLCBhcmd1bWVudHMgKTtcblx0fTtcbn0pO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdXNlZCBieSB0aGUgZGltZW5zaW9ucyBhbmQgb2Zmc2V0IG1vZHVsZXNcbmZ1bmN0aW9uIG51bShlbGVtLCBwcm9wKSB7XG5cdHJldHVybiBlbGVtWzBdICYmIHBhcnNlSW50KCBqUXVlcnkuY3VyQ1NTKGVsZW1bMF0sIHByb3AsIHRydWUpLCAxMCApIHx8IDA7XG59XG52YXIgZXhwYW5kbyA9IFwialF1ZXJ5XCIgKyBub3coKSwgdXVpZCA9IDAsIHdpbmRvd0RhdGEgPSB7fTtcclxuXHJcbmpRdWVyeS5leHRlbmQoe1xyXG5cdGNhY2hlOiB7fSxcclxuXHJcblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XHJcblx0XHRlbGVtID0gZWxlbSA9PSB3aW5kb3cgP1xyXG5cdFx0XHR3aW5kb3dEYXRhIDpcclxuXHRcdFx0ZWxlbTtcclxuXHJcblx0XHR2YXIgaWQgPSBlbGVtWyBleHBhbmRvIF07XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhlIGVsZW1lbnRcclxuXHRcdGlmICggIWlkIClcclxuXHRcdFx0aWQgPSBlbGVtWyBleHBhbmRvIF0gPSArK3V1aWQ7XHJcblxyXG5cdFx0Ly8gT25seSBnZW5lcmF0ZSB0aGUgZGF0YSBjYWNoZSBpZiB3ZSdyZVxyXG5cdFx0Ly8gdHJ5aW5nIHRvIGFjY2VzcyBvciBtYW5pcHVsYXRlIGl0XHJcblx0XHRpZiAoIG5hbWUgJiYgIWpRdWVyeS5jYWNoZVsgaWQgXSApXHJcblx0XHRcdGpRdWVyeS5jYWNoZVsgaWQgXSA9IHt9O1xyXG5cclxuXHRcdC8vIFByZXZlbnQgb3ZlcnJpZGluZyB0aGUgbmFtZWQgY2FjaGUgd2l0aCB1bmRlZmluZWQgdmFsdWVzXHJcblx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApXHJcblx0XHRcdGpRdWVyeS5jYWNoZVsgaWQgXVsgbmFtZSBdID0gZGF0YTtcclxuXHJcblx0XHQvLyBSZXR1cm4gdGhlIG5hbWVkIGNhY2hlIGRhdGEsIG9yIHRoZSBJRCBmb3IgdGhlIGVsZW1lbnRcclxuXHRcdHJldHVybiBuYW1lID9cclxuXHRcdFx0alF1ZXJ5LmNhY2hlWyBpZCBdWyBuYW1lIF0gOlxyXG5cdFx0XHRpZDtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcclxuXHRcdGVsZW0gPSBlbGVtID09IHdpbmRvdyA/XHJcblx0XHRcdHdpbmRvd0RhdGEgOlxyXG5cdFx0XHRlbGVtO1xyXG5cclxuXHRcdHZhciBpZCA9IGVsZW1bIGV4cGFuZG8gXTtcclxuXHJcblx0XHQvLyBJZiB3ZSB3YW50IHRvIHJlbW92ZSBhIHNwZWNpZmljIHNlY3Rpb24gb2YgdGhlIGVsZW1lbnQncyBkYXRhXHJcblx0XHRpZiAoIG5hbWUgKSB7XHJcblx0XHRcdGlmICggalF1ZXJ5LmNhY2hlWyBpZCBdICkge1xyXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgc2VjdGlvbiBvZiBjYWNoZSBkYXRhXHJcblx0XHRcdFx0ZGVsZXRlIGpRdWVyeS5jYWNoZVsgaWQgXVsgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHQvLyBJZiB3ZSd2ZSByZW1vdmVkIGFsbCB0aGUgZGF0YSwgcmVtb3ZlIHRoZSBlbGVtZW50J3MgY2FjaGVcclxuXHRcdFx0XHRuYW1lID0gXCJcIjtcclxuXHJcblx0XHRcdFx0Zm9yICggbmFtZSBpbiBqUXVlcnkuY2FjaGVbIGlkIF0gKVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGlmICggIW5hbWUgKVxyXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdC8vIE90aGVyd2lzZSwgd2Ugd2FudCB0byByZW1vdmUgYWxsIG9mIHRoZSBlbGVtZW50J3MgZGF0YVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gQ2xlYW4gdXAgdGhlIGVsZW1lbnQgZXhwYW5kb1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGRlbGV0ZSBlbGVtWyBleHBhbmRvIF07XHJcblx0XHRcdH0gY2F0Y2goZSl7XHJcblx0XHRcdFx0Ly8gSUUgaGFzIHRyb3VibGUgZGlyZWN0bHkgcmVtb3ZpbmcgdGhlIGV4cGFuZG9cclxuXHRcdFx0XHQvLyBidXQgaXQncyBvayB3aXRoIHVzaW5nIHJlbW92ZUF0dHJpYnV0ZVxyXG5cdFx0XHRcdGlmICggZWxlbS5yZW1vdmVBdHRyaWJ1dGUgKVxyXG5cdFx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGV4cGFuZG8gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ29tcGxldGVseSByZW1vdmUgdGhlIGRhdGEgY2FjaGVcclxuXHRcdFx0ZGVsZXRlIGpRdWVyeS5jYWNoZVsgaWQgXTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcclxuXHRcdGlmICggZWxlbSApe1xyXG5cdFxyXG5cdFx0XHR0eXBlID0gKHR5cGUgfHwgXCJmeFwiKSArIFwicXVldWVcIjtcclxuXHRcclxuXHRcdFx0dmFyIHEgPSBqUXVlcnkuZGF0YSggZWxlbSwgdHlwZSApO1xyXG5cdFxyXG5cdFx0XHRpZiAoICFxIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpIClcclxuXHRcdFx0XHRxID0galF1ZXJ5LmRhdGEoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkgKTtcclxuXHRcdFx0ZWxzZSBpZiggZGF0YSApXHJcblx0XHRcdFx0cS5wdXNoKCBkYXRhICk7XHJcblx0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcTtcclxuXHR9LFxyXG5cclxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApe1xyXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXHJcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcclxuXHRcdFxyXG5cdFx0aWYoICF0eXBlIHx8IHR5cGUgPT09IFwiZnhcIiApXHJcblx0XHRcdGZuID0gcXVldWVbMF07XHJcblx0XHRcdFxyXG5cdFx0aWYoIGZuICE9PSB1bmRlZmluZWQgKVxyXG5cdFx0XHRmbi5jYWxsKGVsZW0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApe1xyXG5cdFx0dmFyIHBhcnRzID0ga2V5LnNwbGl0KFwiLlwiKTtcclxuXHRcdHBhcnRzWzFdID0gcGFydHNbMV0gPyBcIi5cIiArIHBhcnRzWzFdIDogXCJcIjtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdHZhciBkYXRhID0gdGhpcy50cmlnZ2VySGFuZGxlcihcImdldERhdGFcIiArIHBhcnRzWzFdICsgXCIhXCIsIFtwYXJ0c1swXV0pO1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgdGhpcy5sZW5ndGggKVxyXG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuZGF0YSggdGhpc1swXSwga2V5ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkICYmIHBhcnRzWzFdID9cclxuXHRcdFx0XHR0aGlzLmRhdGEoIHBhcnRzWzBdICkgOlxyXG5cdFx0XHRcdGRhdGE7XHJcblx0XHR9IGVsc2VcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJpZ2dlcihcInNldERhdGFcIiArIHBhcnRzWzFdICsgXCIhXCIsIFtwYXJ0c1swXSwgdmFsdWVdKS5lYWNoKGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0alF1ZXJ5LmRhdGEoIHRoaXMsIGtleSwgdmFsdWUgKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApe1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG5cdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggdGhpcywga2V5ICk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cdHF1ZXVlOiBmdW5jdGlvbih0eXBlLCBkYXRhKXtcclxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XHJcblx0XHRcdGRhdGEgPSB0eXBlO1xyXG5cdFx0XHR0eXBlID0gXCJmeFwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkIClcclxuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XHJcblx0XHRcdFxyXG5cdFx0XHQgaWYoIHR5cGUgPT0gXCJmeFwiICYmIHF1ZXVlLmxlbmd0aCA9PSAxIClcclxuXHRcdFx0XHRxdWV1ZVswXS5jYWxsKHRoaXMpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHRkZXF1ZXVlOiBmdW5jdGlvbih0eXBlKXtcclxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcclxuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7LyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSAtIHYwLjkuM1xuICogIENvcHlyaWdodCAyMDA5LCBUaGUgRG9qbyBGb3VuZGF0aW9uXG4gKiAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCwgQlNELCBhbmQgR1BMIExpY2Vuc2VzLlxuICogIE1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKi9cbihmdW5jdGlvbigpe1xuXG52YXIgY2h1bmtlciA9IC8oKD86XFwoKD86XFwoW14oKV0rXFwpfFteKCldKykrXFwpfFxcWyg/OlxcW1teW1xcXV0qXFxdfFsnXCJdW14nXCJdK1snXCJdfFteW1xcXSdcIl0rKStcXF18XFxcXC58W14gPit+LChcXFtdKykrfFs+K35dKShcXHMqLFxccyopPy9nLFxuXHRkb25lID0gMCxcblx0dG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgU2l6emxlID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdGlmICggY29udGV4dC5ub2RlVHlwZSAhPT0gMSAmJiBjb250ZXh0Lm5vZGVUeXBlICE9PSA5IClcblx0XHRyZXR1cm4gW107XG5cdFxuXHRpZiAoICFzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBbXSwgbSwgc2V0LCBjaGVja1NldCwgY2hlY2ssIG1vZGUsIGV4dHJhLCBwcnVuZSA9IHRydWU7XG5cdFxuXHQvLyBSZXNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNodW5rZXIgcmVnZXhwIChzdGFydCBmcm9tIGhlYWQpXG5cdGNodW5rZXIubGFzdEluZGV4ID0gMDtcblx0XG5cdHdoaWxlICggKG0gPSBjaHVua2VyLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCApIHtcblx0XHRwYXJ0cy5wdXNoKCBtWzFdICk7XG5cdFx0XG5cdFx0aWYgKCBtWzJdICkge1xuXHRcdFx0ZXh0cmEgPSBSZWdFeHAucmlnaHRDb250ZXh0O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBwYXJ0cy5sZW5ndGggPiAxICYmIG9yaWdQT1MuZXhlYyggc2VsZWN0b3IgKSApIHtcblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMiAmJiBFeHByLnJlbGF0aXZlWyBwYXJ0c1swXSBdICkge1xuXHRcdFx0c2V0ID0gcG9zUHJvY2VzcyggcGFydHNbMF0gKyBwYXJ0c1sxXSwgY29udGV4dCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXQgPSBFeHByLnJlbGF0aXZlWyBwYXJ0c1swXSBdID9cblx0XHRcdFx0WyBjb250ZXh0IF0gOlxuXHRcdFx0XHRTaXp6bGUoIHBhcnRzLnNoaWZ0KCksIGNvbnRleHQgKTtcblxuXHRcdFx0d2hpbGUgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdHNlbGVjdG9yID0gcGFydHMuc2hpZnQoKTtcblxuXHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHNlbGVjdG9yIF0gKVxuXHRcdFx0XHRcdHNlbGVjdG9yICs9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHRcdFx0c2V0ID0gcG9zUHJvY2Vzcyggc2VsZWN0b3IsIHNldCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR2YXIgcmV0ID0gc2VlZCA/XG5cdFx0XHR7IGV4cHI6IHBhcnRzLnBvcCgpLCBzZXQ6IG1ha2VBcnJheShzZWVkKSB9IDpcblx0XHRcdFNpenpsZS5maW5kKCBwYXJ0cy5wb3AoKSwgcGFydHMubGVuZ3RoID09PSAxICYmIGNvbnRleHQucGFyZW50Tm9kZSA/IGNvbnRleHQucGFyZW50Tm9kZSA6IGNvbnRleHQsIGlzWE1MKGNvbnRleHQpICk7XG5cdFx0c2V0ID0gU2l6emxlLmZpbHRlciggcmV0LmV4cHIsIHJldC5zZXQgKTtcblxuXHRcdGlmICggcGFydHMubGVuZ3RoID4gMCApIHtcblx0XHRcdGNoZWNrU2V0ID0gbWFrZUFycmF5KHNldCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBydW5lID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgY3VyID0gcGFydHMucG9wKCksIHBvcCA9IGN1cjtcblxuXHRcdFx0aWYgKCAhRXhwci5yZWxhdGl2ZVsgY3VyIF0gKSB7XG5cdFx0XHRcdGN1ciA9IFwiXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3AgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb3AgPT0gbnVsbCApIHtcblx0XHRcdFx0cG9wID0gY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0RXhwci5yZWxhdGl2ZVsgY3VyIF0oIGNoZWNrU2V0LCBwb3AsIGlzWE1MKGNvbnRleHQpICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhY2hlY2tTZXQgKSB7XG5cdFx0Y2hlY2tTZXQgPSBzZXQ7XG5cdH1cblxuXHRpZiAoICFjaGVja1NldCApIHtcblx0XHR0aHJvdyBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgKGN1ciB8fCBzZWxlY3Rvcik7XG5cdH1cblxuXHRpZiAoIHRvU3RyaW5nLmNhbGwoY2hlY2tTZXQpID09PSBcIltvYmplY3QgQXJyYXldXCIgKSB7XG5cdFx0aWYgKCAhcHJ1bmUgKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2guYXBwbHkoIHJlc3VsdHMsIGNoZWNrU2V0ICk7XG5cdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgY2hlY2tTZXRbaV0gIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNoZWNrU2V0W2ldICYmIChjaGVja1NldFtpXSA9PT0gdHJ1ZSB8fCBjaGVja1NldFtpXS5ub2RlVHlwZSA9PT0gMSAmJiBjb250YWlucyhjb250ZXh0LCBjaGVja1NldFtpXSkpICkge1xuXHRcdFx0XHRcdHJlc3VsdHMucHVzaCggc2V0W2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBjaGVja1NldFtpXSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2hlY2tTZXRbaV0gJiYgY2hlY2tTZXRbaV0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBzZXRbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRtYWtlQXJyYXkoIGNoZWNrU2V0LCByZXN1bHRzICk7XG5cdH1cblxuXHRpZiAoIGV4dHJhICkge1xuXHRcdFNpenpsZSggZXh0cmEsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbihleHByLCBzZXQpe1xuXHRyZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIHNldCk7XG59O1xuXG5TaXp6bGUuZmluZCA9IGZ1bmN0aW9uKGV4cHIsIGNvbnRleHQsIGlzWE1MKXtcblx0dmFyIHNldCwgbWF0Y2g7XG5cblx0aWYgKCAhZXhwciApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBFeHByLm9yZGVyLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHR2YXIgdHlwZSA9IEV4cHIub3JkZXJbaV0sIG1hdGNoO1xuXHRcdFxuXHRcdGlmICggKG1hdGNoID0gRXhwci5tYXRjaFsgdHlwZSBdLmV4ZWMoIGV4cHIgKSkgKSB7XG5cdFx0XHR2YXIgbGVmdCA9IFJlZ0V4cC5sZWZ0Q29udGV4dDtcblxuXHRcdFx0aWYgKCBsZWZ0LnN1YnN0ciggbGVmdC5sZW5ndGggLSAxICkgIT09IFwiXFxcXFwiICkge1xuXHRcdFx0XHRtYXRjaFsxXSA9IChtYXRjaFsxXSB8fCBcIlwiKS5yZXBsYWNlKC9cXFxcL2csIFwiXCIpO1xuXHRcdFx0XHRzZXQgPSBFeHByLmZpbmRbIHR5cGUgXSggbWF0Y2gsIGNvbnRleHQsIGlzWE1MICk7XG5cdFx0XHRcdGlmICggc2V0ICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0ZXhwciA9IGV4cHIucmVwbGFjZSggRXhwci5tYXRjaFsgdHlwZSBdLCBcIlwiICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoICFzZXQgKSB7XG5cdFx0c2V0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XG5cdH1cblxuXHRyZXR1cm4ge3NldDogc2V0LCBleHByOiBleHByfTtcbn07XG5cblNpenpsZS5maWx0ZXIgPSBmdW5jdGlvbihleHByLCBzZXQsIGlucGxhY2UsIG5vdCl7XG5cdHZhciBvbGQgPSBleHByLCByZXN1bHQgPSBbXSwgY3VyTG9vcCA9IHNldCwgbWF0Y2gsIGFueUZvdW5kO1xuXG5cdHdoaWxlICggZXhwciAmJiBzZXQubGVuZ3RoICkge1xuXHRcdGZvciAoIHZhciB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBFeHByLm1hdGNoWyB0eXBlIF0uZXhlYyggZXhwciApKSAhPSBudWxsICkge1xuXHRcdFx0XHR2YXIgZmlsdGVyID0gRXhwci5maWx0ZXJbIHR5cGUgXSwgZm91bmQsIGl0ZW07XG5cdFx0XHRcdGFueUZvdW5kID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCBjdXJMb29wID09IHJlc3VsdCApIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggRXhwci5wcmVGaWx0ZXJbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRtYXRjaCA9IEV4cHIucHJlRmlsdGVyWyB0eXBlIF0oIG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCApO1xuXG5cdFx0XHRcdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRcdFx0XHRhbnlGb3VuZCA9IGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaCA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyAoaXRlbSA9IGN1ckxvb3BbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbSApIHtcblx0XHRcdFx0XHRcdFx0Zm91bmQgPSBmaWx0ZXIoIGl0ZW0sIG1hdGNoLCBpLCBjdXJMb29wICk7XG5cdFx0XHRcdFx0XHRcdHZhciBwYXNzID0gbm90IF4gISFmb3VuZDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGlucGxhY2UgJiYgZm91bmQgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHBhc3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhbnlGb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1ckxvb3BbaV0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIGl0ZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRhbnlGb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGZvdW5kICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhaW5wbGFjZSApIHtcblx0XHRcdFx0XHRcdGN1ckxvb3AgPSByZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZXhwciA9IGV4cHIucmVwbGFjZSggRXhwci5tYXRjaFsgdHlwZSBdLCBcIlwiICk7XG5cblx0XHRcdFx0XHRpZiAoICFhbnlGb3VuZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGV4cHIgPSBleHByLnJlcGxhY2UoL1xccyosXFxzKi8sIFwiXCIpO1xuXG5cdFx0Ly8gSW1wcm9wZXIgZXhwcmVzc2lvblxuXHRcdGlmICggZXhwciA9PSBvbGQgKSB7XG5cdFx0XHRpZiAoIGFueUZvdW5kID09IG51bGwgKSB7XG5cdFx0XHRcdHRocm93IFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBleHByO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b2xkID0gZXhwcjtcblx0fVxuXG5cdHJldHVybiBjdXJMb29wO1xufTtcblxudmFyIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXHRvcmRlcjogWyBcIklEXCIsIFwiTkFNRVwiLCBcIlRBR1wiIF0sXG5cdG1hdGNoOiB7XG5cdFx0SUQ6IC8jKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZfLV18XFxcXC4pKykvLFxuXHRcdENMQVNTOiAvXFwuKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZfLV18XFxcXC4pKykvLFxuXHRcdE5BTUU6IC9cXFtuYW1lPVsnXCJdKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXy1dfFxcXFwuKSspWydcIl0qXFxdLyxcblx0XHRBVFRSOiAvXFxbXFxzKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXy1dfFxcXFwuKSspXFxzKig/OihcXFM/PSlcXHMqKFsnXCJdKikoLio/KVxcM3wpXFxzKlxcXS8sXG5cdFx0VEFHOiAvXigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwqXy1dfFxcXFwuKSspLyxcblx0XHRDSElMRDogLzoob25seXxudGh8bGFzdHxmaXJzdCktY2hpbGQoPzpcXCgoZXZlbnxvZGR8W1xcZG4rLV0qKVxcKSk/Lyxcblx0XHRQT1M6IC86KG50aHxlcXxndHxsdHxmaXJzdHxsYXN0fGV2ZW58b2RkKSg/OlxcKChcXGQqKVxcKSk/KD89W14tXXwkKS8sXG5cdFx0UFNFVURPOiAvOigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXy1dfFxcXFwuKSspKD86XFwoKFsnXCJdKikoKD86XFwoW15cXCldK1xcKXxbXlxcMlxcKFxcKV0qKSspXFwyXFwpKT8vXG5cdH0sXG5cdGF0dHJNYXA6IHtcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCJcblx0fSxcblx0YXR0ckhhbmRsZToge1xuXHRcdGhyZWY6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcblx0XHR9XG5cdH0sXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCIrXCI6IGZ1bmN0aW9uKGNoZWNrU2V0LCBwYXJ0KXtcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjaGVja1NldFtpXTtcblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRcdHZhciBjdXIgPSBlbGVtLnByZXZpb3VzU2libGluZztcblx0XHRcdFx0XHR3aGlsZSAoIGN1ciAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0XHRjdXIgPSBjdXIucHJldmlvdXNTaWJsaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGVja1NldFtpXSA9IHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdGN1ciB8fCBmYWxzZSA6XG5cdFx0XHRcdFx0XHRjdXIgPT09IHBhcnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0U2l6emxlLmZpbHRlciggcGFydCwgY2hlY2tTZXQsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiPlwiOiBmdW5jdGlvbihjaGVja1NldCwgcGFydCwgaXNYTUwpe1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAhL1xcVy8udGVzdChwYXJ0KSApIHtcblx0XHRcdFx0cGFydCA9IGlzWE1MID8gcGFydCA6IHBhcnQudG9VcHBlckNhc2UoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBjaGVja1NldFtpXTtcblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0Y2hlY2tTZXRbaV0gPSBwYXJlbnQubm9kZU5hbWUgPT09IHBhcnQgPyBwYXJlbnQgOiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSA9IGNoZWNrU2V0W2ldO1xuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0XHRcdGNoZWNrU2V0W2ldID0gdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUgOlxuXHRcdFx0XHRcdFx0XHRlbGVtLnBhcmVudE5vZGUgPT09IHBhcnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRTaXp6bGUuZmlsdGVyKCBwYXJ0LCBjaGVja1NldCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcIlwiOiBmdW5jdGlvbihjaGVja1NldCwgcGFydCwgaXNYTUwpe1xuXHRcdFx0dmFyIGRvbmVOYW1lID0gXCJkb25lXCIgKyAoZG9uZSsrKSwgY2hlY2tGbiA9IGRpckNoZWNrO1xuXG5cdFx0XHRpZiAoICFwYXJ0Lm1hdGNoKC9cXFcvKSApIHtcblx0XHRcdFx0dmFyIG5vZGVDaGVjayA9IHBhcnQgPSBpc1hNTCA/IHBhcnQgOiBwYXJ0LnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdGNoZWNrRm4gPSBkaXJOb2RlQ2hlY2s7XG5cdFx0XHR9XG5cblx0XHRcdGNoZWNrRm4oXCJwYXJlbnROb2RlXCIsIHBhcnQsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCk7XG5cdFx0fSxcblx0XHRcIn5cIjogZnVuY3Rpb24oY2hlY2tTZXQsIHBhcnQsIGlzWE1MKXtcblx0XHRcdHZhciBkb25lTmFtZSA9IFwiZG9uZVwiICsgKGRvbmUrKyksIGNoZWNrRm4gPSBkaXJDaGVjaztcblxuXHRcdFx0aWYgKCB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAhcGFydC5tYXRjaCgvXFxXLykgKSB7XG5cdFx0XHRcdHZhciBub2RlQ2hlY2sgPSBwYXJ0ID0gaXNYTUwgPyBwYXJ0IDogcGFydC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRjaGVja0ZuID0gZGlyTm9kZUNoZWNrO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGVja0ZuKFwicHJldmlvdXNTaWJsaW5nXCIsIHBhcnQsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCk7XG5cdFx0fVxuXHR9LFxuXHRmaW5kOiB7XG5cdFx0SUQ6IGZ1bmN0aW9uKG1hdGNoLCBjb250ZXh0LCBpc1hNTCl7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG1hdGNoWzFdKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBbbV0gOiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdE5BTUU6IGZ1bmN0aW9uKG1hdGNoLCBjb250ZXh0LCBpc1hNTCl7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUobWF0Y2hbMV0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0VEFHOiBmdW5jdGlvbihtYXRjaCwgY29udGV4dCl7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShtYXRjaFsxXSk7XG5cdFx0fVxuXHR9LFxuXHRwcmVGaWx0ZXI6IHtcblx0XHRDTEFTUzogZnVuY3Rpb24obWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90KXtcblx0XHRcdG1hdGNoID0gXCIgXCIgKyBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcL2csIFwiXCIpICsgXCIgXCI7XG5cblx0XHRcdHZhciBlbGVtO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyAoZWxlbSA9IGN1ckxvb3BbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggbm90IF4gKFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIikuaW5kZXhPZihtYXRjaCkgPj0gMCApIHtcblx0XHRcdFx0XHRcdGlmICggIWlucGxhY2UgKVxuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlucGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRjdXJMb29wW2ldID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdElEOiBmdW5jdGlvbihtYXRjaCl7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXC9nLCBcIlwiKTtcblx0XHR9LFxuXHRcdFRBRzogZnVuY3Rpb24obWF0Y2gsIGN1ckxvb3Ape1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBjdXJMb29wW2ldID09PSBmYWxzZTsgaSsrICl7fVxuXHRcdFx0cmV0dXJuIGN1ckxvb3BbaV0gJiYgaXNYTUwoY3VyTG9vcFtpXSkgPyBtYXRjaFsxXSA6IG1hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSxcblx0XHRDSElMRDogZnVuY3Rpb24obWF0Y2gpe1xuXHRcdFx0aWYgKCBtYXRjaFsxXSA9PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBwYXJzZSBlcXVhdGlvbnMgbGlrZSAnZXZlbicsICdvZGQnLCAnNScsICcybicsICczbisyJywgJzRuLTEnLCAnLW4rNidcblx0XHRcdFx0dmFyIHRlc3QgPSAvKC0/KShcXGQqKW4oKD86XFwrfC0pP1xcZCopLy5leGVjKFxuXHRcdFx0XHRcdG1hdGNoWzJdID09IFwiZXZlblwiICYmIFwiMm5cIiB8fCBtYXRjaFsyXSA9PSBcIm9kZFwiICYmIFwiMm4rMVwiIHx8XG5cdFx0XHRcdFx0IS9cXEQvLnRlc3QoIG1hdGNoWzJdICkgJiYgXCIwbitcIiArIG1hdGNoWzJdIHx8IG1hdGNoWzJdKTtcblxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIG51bWJlcnMgKGZpcnN0KW4rKGxhc3QpIGluY2x1ZGluZyBpZiB0aGV5IGFyZSBuZWdhdGl2ZVxuXHRcdFx0XHRtYXRjaFsyXSA9ICh0ZXN0WzFdICsgKHRlc3RbMl0gfHwgMSkpIC0gMDtcblx0XHRcdFx0bWF0Y2hbM10gPSB0ZXN0WzNdIC0gMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogTW92ZSB0byBub3JtYWwgY2FjaGluZyBzeXN0ZW1cblx0XHRcdG1hdGNoWzBdID0gXCJkb25lXCIgKyAoZG9uZSsrKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cdFx0QVRUUjogZnVuY3Rpb24obWF0Y2gpe1xuXHRcdFx0dmFyIG5hbWUgPSBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcL2csIFwiXCIpO1xuXHRcdFx0XG5cdFx0XHRpZiAoIEV4cHIuYXR0ck1hcFtuYW1lXSApIHtcblx0XHRcdFx0bWF0Y2hbMV0gPSBFeHByLmF0dHJNYXBbbmFtZV07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbNF0gPSBcIiBcIiArIG1hdGNoWzRdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXHRcdFBTRVVETzogZnVuY3Rpb24obWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90KXtcblx0XHRcdGlmICggbWF0Y2hbMV0gPT09IFwibm90XCIgKSB7XG5cdFx0XHRcdC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGNvbXBsZXggZXhwcmVzc2lvbiwgb3IgYSBzaW1wbGUgb25lXG5cdFx0XHRcdGlmICggbWF0Y2hbM10ubWF0Y2goY2h1bmtlcikubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRtYXRjaFszXSA9IFNpenpsZShtYXRjaFszXSwgbnVsbCwgbnVsbCwgY3VyTG9vcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHJldCA9IFNpenpsZS5maWx0ZXIobWF0Y2hbM10sIGN1ckxvb3AsIGlucGxhY2UsIHRydWUgXiBub3QpO1xuXHRcdFx0XHRcdGlmICggIWlucGxhY2UgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaC5hcHBseSggcmVzdWx0LCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBFeHByLm1hdGNoLlBPUy50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cdFx0UE9TOiBmdW5jdGlvbihtYXRjaCl7XG5cdFx0XHRtYXRjaC51bnNoaWZ0KCB0cnVlICk7XG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fVxuXHR9LFxuXHRmaWx0ZXJzOiB7XG5cdFx0ZW5hYmxlZDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgZWxlbS50eXBlICE9PSBcImhpZGRlblwiO1xuXHRcdH0sXG5cdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblx0XHRjaGVja2VkOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiBlbGVtLmNoZWNrZWQgPT09IHRydWU7XG5cdFx0fSxcblx0XHRzZWxlY3RlZDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cdFx0cGFyZW50OiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiAhIWVsZW0uZmlyc3RDaGlsZDtcblx0XHR9LFxuXHRcdGVtcHR5OiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiAhZWxlbS5maXJzdENoaWxkO1xuXHRcdH0sXG5cdFx0aGFzOiBmdW5jdGlvbihlbGVtLCBpLCBtYXRjaCl7XG5cdFx0XHRyZXR1cm4gISFTaXp6bGUoIG1hdGNoWzNdLCBlbGVtICkubGVuZ3RoO1xuXHRcdH0sXG5cdFx0aGVhZGVyOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiAvaFxcZC9pLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXHRcdHRleHQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIFwidGV4dFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblx0XHRyYWRpbzogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gXCJyYWRpb1wiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblx0XHRjaGVja2JveDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gXCJjaGVja2JveFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblx0XHRmaWxlOiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiBcImZpbGVcIiA9PT0gZWxlbS50eXBlO1xuXHRcdH0sXG5cdFx0cGFzc3dvcmQ6IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIFwicGFzc3dvcmRcIiA9PT0gZWxlbS50eXBlO1xuXHRcdH0sXG5cdFx0c3VibWl0OiBmdW5jdGlvbihlbGVtKXtcblx0XHRcdHJldHVybiBcInN1Ym1pdFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblx0XHRpbWFnZTogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gXCJpbWFnZVwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblx0XHRyZXNldDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gXCJyZXNldFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblx0XHRidXR0b246IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIFwiYnV0dG9uXCIgPT09IGVsZW0udHlwZSB8fCBlbGVtLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiQlVUVE9OXCI7XG5cdFx0fSxcblx0XHRpbnB1dDogZnVuY3Rpb24oZWxlbSl7XG5cdFx0XHRyZXR1cm4gL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24vaS50ZXN0KGVsZW0ubm9kZU5hbWUpO1xuXHRcdH1cblx0fSxcblx0c2V0RmlsdGVyczoge1xuXHRcdGZpcnN0OiBmdW5jdGlvbihlbGVtLCBpKXtcblx0XHRcdHJldHVybiBpID09PSAwO1xuXHRcdH0sXG5cdFx0bGFzdDogZnVuY3Rpb24oZWxlbSwgaSwgbWF0Y2gsIGFycmF5KXtcblx0XHRcdHJldHVybiBpID09PSBhcnJheS5sZW5ndGggLSAxO1xuXHRcdH0sXG5cdFx0ZXZlbjogZnVuY3Rpb24oZWxlbSwgaSl7XG5cdFx0XHRyZXR1cm4gaSAlIDIgPT09IDA7XG5cdFx0fSxcblx0XHRvZGQ6IGZ1bmN0aW9uKGVsZW0sIGkpe1xuXHRcdFx0cmV0dXJuIGkgJSAyID09PSAxO1xuXHRcdH0sXG5cdFx0bHQ6IGZ1bmN0aW9uKGVsZW0sIGksIG1hdGNoKXtcblx0XHRcdHJldHVybiBpIDwgbWF0Y2hbM10gLSAwO1xuXHRcdH0sXG5cdFx0Z3Q6IGZ1bmN0aW9uKGVsZW0sIGksIG1hdGNoKXtcblx0XHRcdHJldHVybiBpID4gbWF0Y2hbM10gLSAwO1xuXHRcdH0sXG5cdFx0bnRoOiBmdW5jdGlvbihlbGVtLCBpLCBtYXRjaCl7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbM10gLSAwID09IGk7XG5cdFx0fSxcblx0XHRlcTogZnVuY3Rpb24oZWxlbSwgaSwgbWF0Y2gpe1xuXHRcdFx0cmV0dXJuIG1hdGNoWzNdIC0gMCA9PSBpO1xuXHRcdH1cblx0fSxcblx0ZmlsdGVyOiB7XG5cdFx0Q0hJTEQ6IGZ1bmN0aW9uKGVsZW0sIG1hdGNoKXtcblx0XHRcdHZhciB0eXBlID0gbWF0Y2hbMV0sIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuXHRcdFx0dmFyIGRvbmVOYW1lID0gbWF0Y2hbMF07XG5cdFx0XHRcblx0XHRcdGlmICggcGFyZW50ICYmICghcGFyZW50WyBkb25lTmFtZSBdIHx8ICFlbGVtLm5vZGVJbmRleCkgKSB7XG5cdFx0XHRcdHZhciBjb3VudCA9IDE7XG5cblx0XHRcdFx0Zm9yICggdmFyIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09IDEgKSB7XG5cdFx0XHRcdFx0XHRub2RlLm5vZGVJbmRleCA9IGNvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFyZW50WyBkb25lTmFtZSBdID0gY291bnQgLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUgPT0gXCJmaXJzdFwiICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlSW5kZXggPT0gMTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT0gXCJsYXN0XCIgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLm5vZGVJbmRleCA9PSBwYXJlbnRbIGRvbmVOYW1lIF07XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09IFwib25seVwiICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50WyBkb25lTmFtZSBdID09IDE7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09IFwibnRoXCIgKSB7XG5cdFx0XHRcdHZhciBhZGQgPSBmYWxzZSwgZmlyc3QgPSBtYXRjaFsyXSwgbGFzdCA9IG1hdGNoWzNdO1xuXG5cdFx0XHRcdGlmICggZmlyc3QgPT0gMSAmJiBsYXN0ID09IDAgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGZpcnN0ID09IDAgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVJbmRleCA9PSBsYXN0ICkge1xuXHRcdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIChlbGVtLm5vZGVJbmRleCAtIGxhc3QpICUgZmlyc3QgPT0gMCAmJiAoZWxlbS5ub2RlSW5kZXggLSBsYXN0KSAvIGZpcnN0ID49IDAgKSB7XG5cdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhZGQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRQU0VVRE86IGZ1bmN0aW9uKGVsZW0sIG1hdGNoLCBpLCBhcnJheSl7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzFdLCBmaWx0ZXIgPSBFeHByLmZpbHRlcnNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBmaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXIoIGVsZW0sIGksIG1hdGNoLCBhcnJheSApO1xuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gXCJjb250YWluc1wiICkge1xuXHRcdFx0XHRyZXR1cm4gKGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgXCJcIikuaW5kZXhPZihtYXRjaFszXSkgPj0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09IFwibm90XCIgKSB7XG5cdFx0XHRcdHZhciBub3QgPSBtYXRjaFszXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBub3QubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggbm90W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0SUQ6IGZ1bmN0aW9uKGVsZW0sIG1hdGNoKXtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IG1hdGNoO1xuXHRcdH0sXG5cdFx0VEFHOiBmdW5jdGlvbihlbGVtLCBtYXRjaCl7XG5cdFx0XHRyZXR1cm4gKG1hdGNoID09PSBcIipcIiAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB8fCBlbGVtLm5vZGVOYW1lID09PSBtYXRjaDtcblx0XHR9LFxuXHRcdENMQVNTOiBmdW5jdGlvbihlbGVtLCBtYXRjaCl7XG5cdFx0XHRyZXR1cm4gbWF0Y2gudGVzdCggZWxlbS5jbGFzc05hbWUgKTtcblx0XHR9LFxuXHRcdEFUVFI6IGZ1bmN0aW9uKGVsZW0sIG1hdGNoKXtcblx0XHRcdHZhciByZXN1bHQgPSBFeHByLmF0dHJIYW5kbGVbIG1hdGNoWzFdIF0gPyBFeHByLmF0dHJIYW5kbGVbIG1hdGNoWzFdIF0oIGVsZW0gKSA6IGVsZW1bIG1hdGNoWzFdIF0gfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIG1hdGNoWzFdICksIHZhbHVlID0gcmVzdWx0ICsgXCJcIiwgdHlwZSA9IG1hdGNoWzJdLCBjaGVjayA9IG1hdGNoWzRdO1xuXHRcdFx0cmV0dXJuIHJlc3VsdCA9PSBudWxsID9cblx0XHRcdFx0dHlwZSA9PT0gXCIhPVwiIDpcblx0XHRcdFx0dHlwZSA9PT0gXCI9XCIgP1xuXHRcdFx0XHR2YWx1ZSA9PT0gY2hlY2sgOlxuXHRcdFx0XHR0eXBlID09PSBcIio9XCIgP1xuXHRcdFx0XHR2YWx1ZS5pbmRleE9mKGNoZWNrKSA+PSAwIDpcblx0XHRcdFx0dHlwZSA9PT0gXCJ+PVwiID9cblx0XHRcdFx0KFwiIFwiICsgdmFsdWUgKyBcIiBcIikuaW5kZXhPZihjaGVjaykgPj0gMCA6XG5cdFx0XHRcdCFtYXRjaFs0XSA/XG5cdFx0XHRcdHJlc3VsdCA6XG5cdFx0XHRcdHR5cGUgPT09IFwiIT1cIiA/XG5cdFx0XHRcdHZhbHVlICE9IGNoZWNrIDpcblx0XHRcdFx0dHlwZSA9PT0gXCJePVwiID9cblx0XHRcdFx0dmFsdWUuaW5kZXhPZihjaGVjaykgPT09IDAgOlxuXHRcdFx0XHR0eXBlID09PSBcIiQ9XCIgP1xuXHRcdFx0XHR2YWx1ZS5zdWJzdHIodmFsdWUubGVuZ3RoIC0gY2hlY2subGVuZ3RoKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHR0eXBlID09PSBcInw9XCIgP1xuXHRcdFx0XHR2YWx1ZSA9PT0gY2hlY2sgfHwgdmFsdWUuc3Vic3RyKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0ZmFsc2U7XG5cdFx0fSxcblx0XHRQT1M6IGZ1bmN0aW9uKGVsZW0sIG1hdGNoLCBpLCBhcnJheSl7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzJdLCBmaWx0ZXIgPSBFeHByLnNldEZpbHRlcnNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBmaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXIoIGVsZW0sIGksIG1hdGNoLCBhcnJheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIG9yaWdQT1MgPSBFeHByLm1hdGNoLlBPUztcblxuZm9yICggdmFyIHR5cGUgaW4gRXhwci5tYXRjaCApIHtcblx0RXhwci5tYXRjaFsgdHlwZSBdID0gUmVnRXhwKCBFeHByLm1hdGNoWyB0eXBlIF0uc291cmNlICsgLyg/IVteXFxbXSpcXF0pKD8hW15cXChdKlxcKSkvLnNvdXJjZSApO1xufVxuXG52YXIgbWFrZUFycmF5ID0gZnVuY3Rpb24oYXJyYXksIHJlc3VsdHMpIHtcblx0YXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXkgKTtcblxuXHRpZiAoIHJlc3VsdHMgKSB7XG5cdFx0cmVzdWx0cy5wdXNoLmFwcGx5KCByZXN1bHRzLCBhcnJheSApO1xuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cdFxuXHRyZXR1cm4gYXJyYXk7XG59O1xuXG4vLyBQZXJmb3JtIGEgc2ltcGxlIGNoZWNrIHRvIGRldGVybWluZSBpZiB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mXG4vLyBjb252ZXJ0aW5nIGEgTm9kZUxpc3QgdG8gYW4gYXJyYXkgdXNpbmcgYnVpbHRpbiBtZXRob2RzLlxudHJ5IHtcblx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzICk7XG5cbi8vIFByb3ZpZGUgYSBmYWxsYmFjayBtZXRob2QgaWYgaXQgZG9lcyBub3Qgd29ya1xufSBjYXRjaChlKXtcblx0bWFrZUFycmF5ID0gZnVuY3Rpb24oYXJyYXksIHJlc3VsdHMpIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggdG9TdHJpbmcuY2FsbChhcnJheSkgPT09IFwiW29iamVjdCBBcnJheV1cIiApIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCByZXQsIGFycmF5ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIGFycmF5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCBhcnJheVtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGFycmF5W2ldOyBpKysgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGFycmF5W2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufVxuXG4vLyBDaGVjayB0byBzZWUgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lIHdoZW5cbi8vIHF1ZXJ5aW5nIGJ5IGdldEVsZW1lbnRCeUlkIChhbmQgcHJvdmlkZSBhIHdvcmthcm91bmQpXG4oZnVuY3Rpb24oKXtcblx0Ly8gV2UncmUgZ29pbmcgdG8gaW5qZWN0IGEgZmFrZSBpbnB1dCBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQgbmFtZVxuXHR2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLFxuXHRcdGlkID0gXCJzY3JpcHRcIiArIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuXHRmb3JtLmlubmVySFRNTCA9IFwiPGlucHV0IG5hbWU9J1wiICsgaWQgKyBcIicvPlwiO1xuXG5cdC8vIEluamVjdCBpdCBpbnRvIHRoZSByb290IGVsZW1lbnQsIGNoZWNrIGl0cyBzdGF0dXMsIGFuZCByZW1vdmUgaXQgcXVpY2tseVxuXHR2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0cm9vdC5pbnNlcnRCZWZvcmUoIGZvcm0sIHJvb3QuZmlyc3RDaGlsZCApO1xuXG5cdC8vIFRoZSB3b3JrYXJvdW5kIGhhcyB0byBkbyBhZGRpdGlvbmFsIGNoZWNrcyBhZnRlciBhIGdldEVsZW1lbnRCeUlkXG5cdC8vIFdoaWNoIHNsb3dzIHRoaW5ncyBkb3duIGZvciBvdGhlciBicm93c2VycyAoaGVuY2UgdGhlIGJyYW5jaGluZylcblx0aWYgKCAhIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpZCApICkge1xuXHRcdEV4cHIuZmluZC5JRCA9IGZ1bmN0aW9uKG1hdGNoLCBjb250ZXh0LCBpc1hNTCl7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG1hdGNoWzFdKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBtLmlkID09PSBtYXRjaFsxXSB8fCB0eXBlb2YgbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIG0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLm5vZGVWYWx1ZSA9PT0gbWF0Y2hbMV0gPyBbbV0gOiB1bmRlZmluZWQgOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0RXhwci5maWx0ZXIuSUQgPSBmdW5jdGlvbihlbGVtLCBtYXRjaCl7XG5cdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlICYmIG5vZGUubm9kZVZhbHVlID09PSBtYXRjaDtcblx0XHR9O1xuXHR9XG5cblx0cm9vdC5yZW1vdmVDaGlsZCggZm9ybSApO1xufSkoKTtcblxuKGZ1bmN0aW9uKCl7XG5cdC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgYnJvd3NlciByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0Ly8gd2hlbiBkb2luZyBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIilcblxuXHQvLyBDcmVhdGUgYSBmYWtlIGVsZW1lbnRcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXG5cdC8vIE1ha2Ugc3VyZSBubyBjb21tZW50cyBhcmUgZm91bmRcblx0aWYgKCBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aCA+IDAgKSB7XG5cdFx0RXhwci5maW5kLlRBRyA9IGZ1bmN0aW9uKG1hdGNoLCBjb250ZXh0KXtcblx0XHRcdHZhciByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShtYXRjaFsxXSk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggbWF0Y2hbMV0gPT09IFwiKlwiICkge1xuXHRcdFx0XHR2YXIgdG1wID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyByZXN1bHRzW2ldOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXN1bHRzW2ldLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIHJlc3VsdHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHRzID0gdG1wO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGFuIGF0dHJpYnV0ZSByZXR1cm5zIG5vcm1hbGl6ZWQgaHJlZiBhdHRyaWJ1dGVzXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0aWYgKCBkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpICE9PSBcIiNcIiApIHtcblx0XHRFeHByLmF0dHJIYW5kbGUuaHJlZiA9IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaHJlZlwiLCAyKTtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG5pZiAoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSAoZnVuY3Rpb24oKXtcblx0dmFyIG9sZFNpenpsZSA9IFNpenpsZSwgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiPHAgY2xhc3M9J1RFU1QnPjwvcD5cIjtcblxuXHQvLyBTYWZhcmkgY2FuJ3QgaGFuZGxlIHVwcGVyY2FzZSBvciB1bmljb2RlIGNoYXJhY3RlcnMgd2hlblxuXHQvLyBpbiBxdWlya3MgbW9kZS5cblx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbCAmJiBkaXYucXVlcnlTZWxlY3RvckFsbChcIi5URVNUXCIpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0XG5cdFNpenpsZSA9IGZ1bmN0aW9uKHF1ZXJ5LCBjb250ZXh0LCBleHRyYSwgc2VlZCl7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBPbmx5IHVzZSBxdWVyeVNlbGVjdG9yQWxsIG9uIG5vbi1YTUwgZG9jdW1lbnRzXG5cdFx0Ly8gKElEIHNlbGVjdG9ycyBkb24ndCB3b3JrIGluIG5vbi1IVE1MIGRvY3VtZW50cylcblx0XHRpZiAoICFzZWVkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgIWlzWE1MKGNvbnRleHQpICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZXh0cmEgKTtcblx0XHRcdH0gY2F0Y2goZSl7fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gb2xkU2l6emxlKHF1ZXJ5LCBjb250ZXh0LCBleHRyYSwgc2VlZCk7XG5cdH07XG5cblx0U2l6emxlLmZpbmQgPSBvbGRTaXp6bGUuZmluZDtcblx0U2l6emxlLmZpbHRlciA9IG9sZFNpenpsZS5maWx0ZXI7XG5cdFNpenpsZS5zZWxlY3RvcnMgPSBvbGRTaXp6bGUuc2VsZWN0b3JzO1xuXHRTaXp6bGUubWF0Y2hlcyA9IG9sZFNpenpsZS5tYXRjaGVzO1xufSkoKTtcblxuaWYgKCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRFeHByLm9yZGVyLnNwbGljZSgxLCAwLCBcIkNMQVNTXCIpO1xuXHRFeHByLmZpbmQuQ0xBU1MgPSBmdW5jdGlvbihtYXRjaCwgY29udGV4dCkge1xuXHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobWF0Y2hbMV0pO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBkaXJOb2RlQ2hlY2soIGRpciwgY3VyLCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHR2YXIgZWxlbSA9IGNoZWNrU2V0W2ldO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdGVsZW0gPSBlbGVtW2Rpcl07XG5cdFx0XHR2YXIgbWF0Y2ggPSBmYWxzZTtcblxuXHRcdFx0d2hpbGUgKCBlbGVtICYmIGVsZW0ubm9kZVR5cGUgKSB7XG5cdFx0XHRcdHZhciBkb25lID0gZWxlbVtkb25lTmFtZV07XG5cdFx0XHRcdGlmICggZG9uZSApIHtcblx0XHRcdFx0XHRtYXRjaCA9IGNoZWNrU2V0WyBkb25lIF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWlzWE1MIClcblx0XHRcdFx0XHRlbGVtW2RvbmVOYW1lXSA9IGk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVOYW1lID09PSBjdXIgKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBlbGVtO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbSA9IGVsZW1bZGlyXTtcblx0XHRcdH1cblxuXHRcdFx0Y2hlY2tTZXRbaV0gPSBtYXRjaDtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGlyQ2hlY2soIGRpciwgY3VyLCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHR2YXIgZWxlbSA9IGNoZWNrU2V0W2ldO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdGVsZW0gPSBlbGVtW2Rpcl07XG5cdFx0XHR2YXIgbWF0Y2ggPSBmYWxzZTtcblxuXHRcdFx0d2hpbGUgKCBlbGVtICYmIGVsZW0ubm9kZVR5cGUgKSB7XG5cdFx0XHRcdGlmICggZWxlbVtkb25lTmFtZV0gKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBjaGVja1NldFsgZWxlbVtkb25lTmFtZV0gXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRpZiAoICFpc1hNTCApXG5cdFx0XHRcdFx0XHRlbGVtW2RvbmVOYW1lXSA9IGk7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjdXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0gPT09IGN1ciApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIFNpenpsZS5maWx0ZXIoIGN1ciwgW2VsZW1dICkubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gZWxlbTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0gPSBlbGVtW2Rpcl07XG5cdFx0XHR9XG5cblx0XHRcdGNoZWNrU2V0W2ldID0gbWF0Y2g7XG5cdFx0fVxuXHR9XG59XG5cbnZhciBjb250YWlucyA9IGRvY3VtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gIGZ1bmN0aW9uKGEsIGIpe1xuXHRyZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDE2O1xufSA6IGZ1bmN0aW9uKGEsIGIpe1xuXHRyZXR1cm4gYSAhPT0gYiAmJiAoYS5jb250YWlucyA/IGEuY29udGFpbnMoYikgOiB0cnVlKTtcbn07XG5cbnZhciBpc1hNTCA9IGZ1bmN0aW9uKGVsZW0pe1xuXHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgfHxcblx0XHQhIWVsZW0ub3duZXJEb2N1bWVudCAmJiBpc1hNTCggZWxlbS5vd25lckRvY3VtZW50ICk7XG59O1xuXG52YXIgcG9zUHJvY2VzcyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcblx0dmFyIHRtcFNldCA9IFtdLCBsYXRlciA9IFwiXCIsIG1hdGNoLFxuXHRcdHJvb3QgPSBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dDtcblxuXHQvLyBQb3NpdGlvbiBzZWxlY3RvcnMgbXVzdCBiZSBkb25lIGFmdGVyIHRoZSBmaWx0ZXJcblx0Ly8gQW5kIHNvIG11c3QgOm5vdChwb3NpdGlvbmFsKSBzbyB3ZSBtb3ZlIGFsbCBQU0VVRE9zIHRvIHRoZSBlbmRcblx0d2hpbGUgKCAobWF0Y2ggPSBFeHByLm1hdGNoLlBTRVVETy5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRsYXRlciArPSBtYXRjaFswXTtcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoIEV4cHIubWF0Y2guUFNFVURPLCBcIlwiICk7XG5cdH1cblxuXHRzZWxlY3RvciA9IEV4cHIucmVsYXRpdmVbc2VsZWN0b3JdID8gc2VsZWN0b3IgKyBcIipcIiA6IHNlbGVjdG9yO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHJvb3QubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIHJvb3RbaV0sIHRtcFNldCApO1xuXHR9XG5cblx0cmV0dXJuIFNpenpsZS5maWx0ZXIoIGxhdGVyLCB0bXBTZXQgKTtcbn07XG5cbi8vIEVYUE9TRVxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZmlsdGVyID0gU2l6emxlLmZpbHRlcjtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbmpRdWVyeS5leHByW1wiOlwiXSA9IGpRdWVyeS5leHByLmZpbHRlcnM7XG5cblNpenpsZS5zZWxlY3RvcnMuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbihlbGVtKXtcblx0cmV0dXJuIFwiaGlkZGVuXCIgPT09IGVsZW0udHlwZSB8fFxuXHRcdGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIiB8fFxuXHRcdGpRdWVyeS5jc3MoZWxlbSwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiO1xufTtcblxuU2l6emxlLnNlbGVjdG9ycy5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbihlbGVtKXtcblx0cmV0dXJuIFwiaGlkZGVuXCIgIT09IGVsZW0udHlwZSAmJlxuXHRcdGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpICE9PSBcIm5vbmVcIiAmJlxuXHRcdGpRdWVyeS5jc3MoZWxlbSwgXCJ2aXNpYmlsaXR5XCIpICE9PSBcImhpZGRlblwiO1xufTtcblxuU2l6emxlLnNlbGVjdG9ycy5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oZWxlbSl7XG5cdHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbihmbil7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0pLmxlbmd0aDtcbn07XG5cbmpRdWVyeS5tdWx0aUZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIFNpenpsZS5tYXRjaGVzKGV4cHIsIGVsZW1zKTtcbn07XG5cbmpRdWVyeS5kaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyICl7XG5cdHZhciBtYXRjaGVkID0gW10sIGN1ciA9IGVsZW1bZGlyXTtcblx0d2hpbGUgKCBjdXIgJiYgY3VyICE9IGRvY3VtZW50ICkge1xuXHRcdGlmICggY3VyLm5vZGVUeXBlID09IDEgKVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRjdXIgPSBjdXJbZGlyXTtcblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cbmpRdWVyeS5udGggPSBmdW5jdGlvbihjdXIsIHJlc3VsdCwgZGlyLCBlbGVtKXtcblx0cmVzdWx0ID0gcmVzdWx0IHx8IDE7XG5cdHZhciBudW0gPSAwO1xuXG5cdGZvciAoIDsgY3VyOyBjdXIgPSBjdXJbZGlyXSApXG5cdFx0aWYgKCBjdXIubm9kZVR5cGUgPT0gMSAmJiArK251bSA9PSByZXN1bHQgKVxuXHRcdFx0YnJlYWs7XG5cblx0cmV0dXJuIGN1cjtcbn07XG5cbmpRdWVyeS5zaWJsaW5nID0gZnVuY3Rpb24obiwgZWxlbSl7XG5cdHZhciByID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT0gMSAmJiBuICE9IGVsZW0gKVxuXHRcdFx0ci5wdXNoKCBuICk7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn07XG5cbnJldHVybjtcblxud2luZG93LlNpenpsZSA9IFNpenpsZTtcblxufSkoKTtcbi8qXG4gKiBBIG51bWJlciBvZiBoZWxwZXIgZnVuY3Rpb25zIHVzZWQgZm9yIG1hbmFnaW5nIGV2ZW50cy5cbiAqIE1hbnkgb2YgdGhlIGlkZWFzIGJlaGluZCB0aGlzIGNvZGUgb3JpZ2luYXRlZCBmcm9tXG4gKiBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHQvLyBCaW5kIGFuIGV2ZW50IHRvIGFuIGVsZW1lbnRcblx0Ly8gT3JpZ2luYWwgYnkgRGVhbiBFZHdhcmRzXG5cdGFkZDogZnVuY3Rpb24oZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEpIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT0gMyB8fCBlbGVtLm5vZGVUeXBlID09IDggKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gRm9yIHdoYXRldmVyIHJlYXNvbiwgSUUgaGFzIHRyb3VibGUgcGFzc2luZyB0aGUgd2luZG93IG9iamVjdFxuXHRcdC8vIGFyb3VuZCwgY2F1c2luZyBpdCB0byBiZSBjbG9uZWQgaW4gdGhlIHByb2Nlc3Ncblx0XHRpZiAoIGVsZW0uc2V0SW50ZXJ2YWwgJiYgZWxlbSAhPSB3aW5kb3cgKVxuXHRcdFx0ZWxlbSA9IHdpbmRvdztcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBmdW5jdGlvbiBiZWluZyBleGVjdXRlZCBoYXMgYSB1bmlxdWUgSURcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKVxuXHRcdFx0aGFuZGxlci5ndWlkID0gdGhpcy5ndWlkKys7XG5cblx0XHQvLyBpZiBkYXRhIGlzIHBhc3NlZCwgYmluZCB0byBoYW5kbGVyXG5cdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBDcmVhdGUgdGVtcG9yYXJ5IGZ1bmN0aW9uIHBvaW50ZXIgdG8gb3JpZ2luYWwgaGFuZGxlclxuXHRcdFx0dmFyIGZuID0gaGFuZGxlcjtcblxuXHRcdFx0Ly8gQ3JlYXRlIHVuaXF1ZSBoYW5kbGVyIGZ1bmN0aW9uLCB3cmFwcGVkIGFyb3VuZCBvcmlnaW5hbCBoYW5kbGVyXG5cdFx0XHRoYW5kbGVyID0gdGhpcy5wcm94eSggZm4gKTtcblxuXHRcdFx0Ly8gU3RvcmUgZGF0YSBpbiB1bmlxdWUgaGFuZGxlclxuXHRcdFx0aGFuZGxlci5kYXRhID0gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlXG5cdFx0dmFyIGV2ZW50cyA9IGpRdWVyeS5kYXRhKGVsZW0sIFwiZXZlbnRzXCIpIHx8IGpRdWVyeS5kYXRhKGVsZW0sIFwiZXZlbnRzXCIsIHt9KSxcblx0XHRcdGhhbmRsZSA9IGpRdWVyeS5kYXRhKGVsZW0sIFwiaGFuZGxlXCIpIHx8IGpRdWVyeS5kYXRhKGVsZW0sIFwiaGFuZGxlXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgdHJpZ2dlciBhbmQgd2hlblxuXHRcdFx0XHQvLyBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmhhbmRsZS5hcHBseShhcmd1bWVudHMuY2FsbGVlLmVsZW0sIGFyZ3VtZW50cykgOlxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH0pO1xuXHRcdC8vIEFkZCBlbGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSBmdW5jdGlvblxuXHRcdC8vIFRoaXMgaXMgdG8gcHJldmVudCBhIG1lbW9yeSBsZWFrIHdpdGggbm9uLW5hdGl2ZVxuXHRcdC8vIGV2ZW50IGluIElFLlxuXHRcdGhhbmRsZS5lbGVtID0gZWxlbTtcblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHQvLyBqUXVlcnkoLi4uKS5iaW5kKFwibW91c2VvdmVyIG1vdXNlb3V0XCIsIGZuKTtcblx0XHRqUXVlcnkuZWFjaCh0eXBlcy5zcGxpdCgvXFxzKy8pLCBmdW5jdGlvbihpbmRleCwgdHlwZSkge1xuXHRcdFx0Ly8gTmFtZXNwYWNlZCBldmVudCBoYW5kbGVyc1xuXHRcdFx0dmFyIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRoYW5kbGVyLnR5cGUgPSBuYW1lc3BhY2VzLnNsaWNlKCkuc29ydCgpLmpvaW4oXCIuXCIpO1xuXG5cdFx0XHQvLyBHZXQgdGhlIGN1cnJlbnQgbGlzdCBvZiBmdW5jdGlvbnMgYm91bmQgdG8gdGhpcyBldmVudFxuXHRcdFx0dmFyIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdO1xuXHRcdFx0XG5cdFx0XHRpZiAoIGpRdWVyeS5ldmVudC5zcGVjaWFsQWxsW3R5cGVdIClcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxBbGxbdHlwZV0uc2V0dXAuY2FsbChlbGVtLCBkYXRhLCBuYW1lc3BhY2VzKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZVxuXHRcdFx0aWYgKCFoYW5kbGVycykge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IHt9O1xuXG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIHNwZWNpYWwgZXZlbnQgaGFuZGxlclxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyL2F0dGFjaEV2ZW50IGlmIHRoZSBzcGVjaWFsXG5cdFx0XHRcdC8vIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0uc2V0dXAuY2FsbChlbGVtLCBkYXRhLCBuYW1lc3BhY2VzKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gQmluZCB0aGUgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKVxuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZSwgZmFsc2UpO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpXG5cdFx0XHRcdFx0XHRlbGVtLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRoZSBmdW5jdGlvbiB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdFxuXHRcdFx0aGFuZGxlcnNbaGFuZGxlci5ndWlkXSA9IGhhbmRsZXI7XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgYmVlbiB1c2VkLCBmb3IgZ2xvYmFsIHRyaWdnZXJpbmdcblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0gPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTnVsbGlmeSBlbGVtIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFXG5cdFx0ZWxlbSA9IG51bGw7XG5cdH0sXG5cblx0Z3VpZDogMSxcblx0Z2xvYmFsOiB7fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbihlbGVtLCB0eXBlcywgaGFuZGxlcikge1xuXHRcdC8vIGRvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PSA4IClcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciBldmVudHMgPSBqUXVlcnkuZGF0YShlbGVtLCBcImV2ZW50c1wiKSwgcmV0LCBpbmRleDtcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoIHR5cGVzID09PSB1bmRlZmluZWQgfHwgKHR5cGVvZiB0eXBlcyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlcy5jaGFyQXQoMCkgPT0gXCIuXCIpIClcblx0XHRcdFx0Zm9yICggdmFyIHR5cGUgaW4gZXZlbnRzIClcblx0XHRcdFx0XHR0aGlzLnJlbW92ZSggZWxlbSwgdHlwZSArICh0eXBlcyB8fCBcIlwiKSApO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIHR5cGVzIGlzIGFjdHVhbGx5IGFuIGV2ZW50IG9iamVjdCBoZXJlXG5cdFx0XHRcdGlmICggdHlwZXMudHlwZSApIHtcblx0XHRcdFx0XHRoYW5kbGVyID0gdHlwZXMuaGFuZGxlcjtcblx0XHRcdFx0XHR0eXBlcyA9IHR5cGVzLnR5cGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGVyYXRlZCBieSBhIHNwYWNlXG5cdFx0XHRcdC8vIGpRdWVyeSguLi4pLnVuYmluZChcIm1vdXNlb3ZlciBtb3VzZW91dFwiLCBmbik7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKHR5cGVzLnNwbGl0KC9cXHMrLyksIGZ1bmN0aW9uKGluZGV4LCB0eXBlKXtcblx0XHRcdFx0XHQvLyBOYW1lc3BhY2VkIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRcdFx0dmFyIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0XHRcdHZhciBuYW1lc3BhY2UgPSBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuc2xpY2UoKS5zb3J0KCkuam9pbihcIi4qXFxcXC5cIikgKyBcIihcXFxcLnwkKVwiKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIHRoZSBnaXZlbiBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdHlwZVxuXHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGV2ZW50c1t0eXBlXVtoYW5kbGVyLmd1aWRdO1xuXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgYWxsIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gdHlwZVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaGFuZGxlIGluIGV2ZW50c1t0eXBlXSApXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSByZW1vdmFsIG9mIG5hbWVzcGFjZWQgZXZlbnRzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lc3BhY2UudGVzdChldmVudHNbdHlwZV1baGFuZGxlXS50eXBlKSApXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgZXZlbnRzW3R5cGVdW2hhbmRsZV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxBbGxbdHlwZV0gKVxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbEFsbFt0eXBlXS50ZWFyZG93bi5jYWxsKGVsZW0sIG5hbWVzcGFjZXMpO1xuXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdFx0XHRcdGZvciAoIHJldCBpbiBldmVudHNbdHlwZV0gKSBicmVhaztcblx0XHRcdFx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhalF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0udGVhcmRvd24uY2FsbChlbGVtLCBuYW1lc3BhY2VzKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcilcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBqUXVlcnkuZGF0YShlbGVtLCBcImhhbmRsZVwiKSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGpRdWVyeS5kYXRhKGVsZW0sIFwiaGFuZGxlXCIpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgZXZlbnRzW3R5cGVdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0XHRmb3IgKCByZXQgaW4gZXZlbnRzICkgYnJlYWs7XG5cdFx0XHRpZiAoICFyZXQgKSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBqUXVlcnkuZGF0YSggZWxlbSwgXCJoYW5kbGVcIiApO1xuXHRcdFx0XHRpZiAoIGhhbmRsZSApIGhhbmRsZS5lbGVtID0gbnVsbDtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIFwiZXZlbnRzXCIgKTtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIFwiaGFuZGxlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gYnViYmxpbmcgaXMgaW50ZXJuYWxcblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBidWJibGluZyApIHtcblx0XHQvLyBFdmVudCBvYmplY3Qgb3IgZXZlbnQgdHlwZVxuXHRcdHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudDtcblxuXHRcdGlmKCAhYnViYmxpbmcgKXtcblx0XHRcdGV2ZW50ID0gdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiID9cblx0XHRcdFx0Ly8galF1ZXJ5LkV2ZW50IG9iamVjdFxuXHRcdFx0XHRldmVudFtleHBhbmRvXSA/IGV2ZW50IDpcblx0XHRcdFx0Ly8gT2JqZWN0IGxpdGVyYWxcblx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggalF1ZXJ5LkV2ZW50KHR5cGUpLCBldmVudCApIDpcblx0XHRcdFx0Ly8gSnVzdCB0aGUgZXZlbnQgdHlwZSAoc3RyaW5nKVxuXHRcdFx0XHRqUXVlcnkuRXZlbnQodHlwZSk7XG5cblx0XHRcdGlmICggdHlwZS5pbmRleE9mKFwiIVwiKSA+PSAwICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gdHlwZSA9IHR5cGUuc2xpY2UoMCwgLTEpO1xuXHRcdFx0XHRldmVudC5leGNsdXNpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgYSBnbG9iYWwgdHJpZ2dlclxuXHRcdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgYnViYmxlIGN1c3RvbSBldmVudHMgd2hlbiBnbG9iYWwgKHRvIGF2b2lkIHRvbyBtdWNoIG92ZXJoZWFkKVxuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0Ly8gT25seSB0cmlnZ2VyIGlmIHdlJ3ZlIGV2ZXIgYm91bmQgYW4gZXZlbnQgZm9yIGl0XG5cdFx0XHRcdGlmICggdGhpcy5nbG9iYWxbdHlwZV0gKVxuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBqUXVlcnkuY2FjaGUsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzW3R5cGVdIClcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhLCB0aGlzLmhhbmRsZS5lbGVtICk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSB0cmlnZ2VyaW5nIGEgc2luZ2xlIGVsZW1lbnRcblxuXHRcdFx0Ly8gZG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT0gOCApXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcblx0XHRcdC8vIENsZWFuIHVwIGluIGNhc2UgaXQgaXMgcmV1c2VkXG5cdFx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdFx0XG5cdFx0XHQvLyBDbG9uZSB0aGUgaW5jb21pbmcgZGF0YSwgaWYgYW55XG5cdFx0XHRkYXRhID0galF1ZXJ5Lm1ha2VBcnJheShkYXRhKTtcblx0XHRcdGRhdGEudW5zaGlmdCggZXZlbnQgKTtcblx0XHR9XG5cblx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gZWxlbTtcblxuXHRcdC8vIFRyaWdnZXIgdGhlIGV2ZW50LCBpdCBpcyBhc3N1bWVkIHRoYXQgXCJoYW5kbGVcIiBpcyBhIGZ1bmN0aW9uXG5cdFx0dmFyIGhhbmRsZSA9IGpRdWVyeS5kYXRhKGVsZW0sIFwiaGFuZGxlXCIpO1xuXHRcdGlmICggaGFuZGxlIClcblx0XHRcdGhhbmRsZS5hcHBseSggZWxlbSwgZGF0YSApO1xuXG5cdFx0Ly8gSGFuZGxlIHRyaWdnZXJpbmcgbmF0aXZlIC5vbmZvbyBoYW5kbGVycyAoYW5kIG9uIGxpbmtzIHNpbmNlIHdlIGRvbid0IGNhbGwgLmNsaWNrKCkgZm9yIGxpbmtzKVxuXHRcdGlmICggKCFlbGVtW3R5cGVdIHx8IChqUXVlcnkubm9kZU5hbWUoZWxlbSwgJ2EnKSAmJiB0eXBlID09IFwiY2xpY2tcIikpICYmIGVsZW1bXCJvblwiK3R5cGVdICYmIGVsZW1bXCJvblwiK3R5cGVdLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlIClcblx0XHRcdGV2ZW50LnJlc3VsdCA9IGZhbHNlO1xuXG5cdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50cyAoZXhjZXB0IGZvciBjbGlja3Mgb24gbGlua3MpXG5cdFx0aWYgKCAhYnViYmxpbmcgJiYgZWxlbVt0eXBlXSAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgIShqUXVlcnkubm9kZU5hbWUoZWxlbSwgJ2EnKSAmJiB0eXBlID09IFwiY2xpY2tcIikgKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXJlZCA9IHRydWU7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdC8vIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBhbiBlcnJvciBmb3Igc29tZSBoaWRkZW4gZWxlbWVudHNcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcblxuXHRcdGlmICggIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIHx8IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdGlmICggcGFyZW50IClcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoZXZlbnQsIGRhdGEsIHBhcmVudCwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGhhbmRsZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyByZXR1cm5lZCB1bmRlZmluZWQgb3IgZmFsc2Vcblx0XHR2YXIgYWxsLCBoYW5kbGVycztcblxuXHRcdGV2ZW50ID0gYXJndW1lbnRzWzBdID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgfHwgd2luZG93LmV2ZW50ICk7XG5cblx0XHQvLyBOYW1lc3BhY2VkIGV2ZW50IGhhbmRsZXJzXG5cdFx0dmFyIG5hbWVzcGFjZXMgPSBldmVudC50eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRldmVudC50eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhpcyBub3csIGFsbCA9IHRydWUgbWVhbnMsIGFueSBoYW5kbGVyXG5cdFx0YWxsID0gIW5hbWVzcGFjZXMubGVuZ3RoICYmICFldmVudC5leGNsdXNpdmU7XG5cdFx0XG5cdFx0dmFyIG5hbWVzcGFjZSA9IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5zbGljZSgpLnNvcnQoKS5qb2luKFwiLipcXFxcLlwiKSArIFwiKFxcXFwufCQpXCIpO1xuXG5cdFx0aGFuZGxlcnMgPSAoIGpRdWVyeS5kYXRhKHRoaXMsIFwiZXZlbnRzXCIpIHx8IHt9IClbZXZlbnQudHlwZV07XG5cblx0XHRmb3IgKCB2YXIgaiBpbiBoYW5kbGVycyApIHtcblx0XHRcdHZhciBoYW5kbGVyID0gaGFuZGxlcnNbal07XG5cblx0XHRcdC8vIEZpbHRlciB0aGUgZnVuY3Rpb25zIGJ5IGNsYXNzXG5cdFx0XHRpZiAoIGFsbCB8fCBuYW1lc3BhY2UudGVzdChoYW5kbGVyLnR5cGUpICkge1xuXHRcdFx0XHQvLyBQYXNzIGluIGEgcmVmZXJlbmNlIHRvIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGl0c2VsZlxuXHRcdFx0XHQvLyBTbyB0aGF0IHdlIGNhbiBsYXRlciByZW1vdmUgaXRcblx0XHRcdFx0ZXZlbnQuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVyLmRhdGE7XG5cblx0XHRcdFx0dmFyIHJldCA9IGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdFx0XHRpZiggcmV0ICE9PSB1bmRlZmluZWQgKXtcblx0XHRcdFx0XHRldmVudC5yZXN1bHQgPSByZXQ7XG5cdFx0XHRcdFx0aWYgKCByZXQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpIClcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wczogXCJhbHRLZXkgYXR0ckNoYW5nZSBhdHRyTmFtZSBidWJibGVzIGJ1dHRvbiBjYW5jZWxhYmxlIGNoYXJDb2RlIGNsaWVudFggY2xpZW50WSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZGF0YSBkZXRhaWwgZXZlbnRQaGFzZSBmcm9tRWxlbWVudCBoYW5kbGVyIGtleUNvZGUgbWV0YUtleSBuZXdWYWx1ZSBvcmlnaW5hbFRhcmdldCBwYWdlWCBwYWdlWSBwcmV2VmFsdWUgcmVsYXRlZE5vZGUgcmVsYXRlZFRhcmdldCBzY3JlZW5YIHNjcmVlblkgc2hpZnRLZXkgc3JjRWxlbWVudCB0YXJnZXQgdG9FbGVtZW50IHZpZXcgd2hlZWxEZWx0YSB3aGljaFwiLnNwbGl0KFwiIFwiKSxcblxuXHRmaXg6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCBldmVudFtleHBhbmRvXSApXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cblx0XHQvLyBzdG9yZSBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdFxuXHRcdC8vIGFuZCBcImNsb25lXCIgdG8gc2V0IHJlYWQtb25seSBwcm9wZXJ0aWVzXG5cdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBldmVudDtcblx0XHRldmVudCA9IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLnByb3BzLmxlbmd0aCwgcHJvcDsgaTsgKXtcblx0XHRcdHByb3AgPSB0aGlzLnByb3BzWyAtLWkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gRml4IHRhcmdldCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0IClcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7IC8vIEZpeGVzICMxOTI1IHdoZXJlIHNyY0VsZW1lbnQgbWlnaHQgbm90IGJlIGRlZmluZWQgZWl0aGVyXG5cblx0XHQvLyBjaGVjayBpZiB0YXJnZXQgaXMgYSB0ZXh0bm9kZSAoc2FmYXJpKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09IDMgKVxuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cblx0XHQvLyBBZGQgcmVsYXRlZFRhcmdldCwgaWYgbmVjZXNzYXJ5XG5cdFx0aWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBldmVudC5mcm9tRWxlbWVudCApXG5cdFx0XHRldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT0gZXZlbnQudGFyZ2V0ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG5cblx0XHQvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG5cdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIGV2ZW50LmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXHRcdFx0ZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MuY2xpZW50TGVmdCB8fCAwKTtcblx0XHRcdGV2ZW50LnBhZ2VZID0gZXZlbnQuY2xpZW50WSArIChkb2MgJiYgZG9jLnNjcm9sbFRvcCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wIHx8IDApIC0gKGRvYy5jbGllbnRUb3AgfHwgMCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgKChldmVudC5jaGFyQ29kZSB8fCBldmVudC5jaGFyQ29kZSA9PT0gMCkgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGUpIClcblx0XHRcdGV2ZW50LndoaWNoID0gZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQua2V5Q29kZTtcblxuXHRcdC8vIEFkZCBtZXRhS2V5IHRvIG5vbi1NYWMgYnJvd3NlcnMgKHVzZSBjdHJsIGZvciBQQydzIGFuZCBNZXRhIGZvciBNYWNzKVxuXHRcdGlmICggIWV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuY3RybEtleSApXG5cdFx0XHRldmVudC5tZXRhS2V5ID0gZXZlbnQuY3RybEtleTtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT0gbGVmdDsgMiA9PSBtaWRkbGU7IDMgPT0gcmlnaHRcblx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGV2ZW50LmJ1dHRvbiApXG5cdFx0XHRldmVudC53aGljaCA9IChldmVudC5idXR0b24gJiAxID8gMSA6ICggZXZlbnQuYnV0dG9uICYgMiA/IDMgOiAoIGV2ZW50LmJ1dHRvbiAmIDQgPyAyIDogMCApICkpO1xuXG5cdFx0cmV0dXJuIGV2ZW50O1xuXHR9LFxuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIHByb3h5ICl7XG5cdFx0cHJveHkgPSBwcm94eSB8fCBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgcHJveHkuZ3VpZCB8fCB0aGlzLmd1aWQrKztcblx0XHQvLyBTbyBwcm94eSBjYW4gYmUgZGVjbGFyZWQgYXMgYW4gYXJndW1lbnRcblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdHJlYWR5OiB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhlIHJlYWR5IGV2ZW50IGlzIHNldHVwXG5cdFx0XHRzZXR1cDogYmluZFJlYWR5LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge31cblx0XHR9XG5cdH0sXG5cdFxuXHRzcGVjaWFsQWxsOiB7XG5cdFx0bGl2ZToge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBzZWxlY3RvciwgbmFtZXNwYWNlcyApe1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBuYW1lc3BhY2VzWzBdLCBsaXZlSGFuZGxlciApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiAgZnVuY3Rpb24oIG5hbWVzcGFjZXMgKXtcblx0XHRcdFx0aWYgKCBuYW1lc3BhY2VzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR2YXIgcmVtb3ZlID0gMCwgbmFtZSA9IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlc1swXSArIFwiKFxcXFwufCQpXCIpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCAoalF1ZXJ5LmRhdGEodGhpcywgXCJldmVudHNcIikubGl2ZSB8fCB7fSksIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRpZiAoIG5hbWUudGVzdCh0aGlzLnR5cGUpIClcblx0XHRcdFx0XHRcdFx0cmVtb3ZlKys7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCByZW1vdmUgPCAxIClcblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIG5hbWVzcGFjZXNbMF0sIGxpdmVIYW5kbGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMgKXtcblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmKCAhdGhpcy5wcmV2ZW50RGVmYXVsdCApXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoc3JjKTtcblx0XG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiggc3JjICYmIHNyYy50eXBlICl7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXHQvLyBFdmVudCB0eXBlXG5cdH1lbHNlXG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXG5cdC8vIHRpbWVTdGFtcCBpcyBidWdneSBmb3Igc29tZSBldmVudHMgb24gRmlyZWZveCgjMzg0Mylcblx0Ly8gU28gd2Ugd29uJ3QgcmVseSBvbiB0aGUgbmF0aXZlIHZhbHVlXG5cdHRoaXMudGltZVN0YW1wID0gbm93KCk7XG5cdFxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbZXhwYW5kb10gPSB0cnVlO1xufTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKXtcblx0cmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpe1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0XHRpZiggIWUgKVxuXHRcdFx0cmV0dXJuO1xuXHRcdC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0aWYgKGUucHJldmVudERlZmF1bHQpXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gb3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGZhbHNlIChJRSlcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0XHRpZiggIWUgKVxuXHRcdFx0cmV0dXJuO1xuXHRcdC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmIChlLnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gb3RoZXJ3aXNlIHNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlIChJRSlcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjpmdW5jdGlvbigpe1xuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0sXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG59O1xuLy8gQ2hlY2tzIGlmIGFuIGV2ZW50IGhhcHBlbmVkIG9uIGFuIGVsZW1lbnQgd2l0aGluIGFub3RoZXIgZWxlbWVudFxuLy8gVXNlZCBpbiBqUXVlcnkuZXZlbnQuc3BlY2lhbC5tb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlIGhhbmRsZXJzXG52YXIgd2l0aGluRWxlbWVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdC8vIENoZWNrIGlmIG1vdXNlKG92ZXJ8b3V0KSBhcmUgc3RpbGwgd2l0aGluIHRoZSBzYW1lIHBhcmVudCBlbGVtZW50XG5cdHZhciBwYXJlbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXHQvLyBUcmF2ZXJzZSB1cCB0aGUgdHJlZVxuXHR3aGlsZSAoIHBhcmVudCAmJiBwYXJlbnQgIT0gdGhpcyApXG5cdFx0dHJ5IHsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7IH1cblx0XHRjYXRjaChlKSB7IHBhcmVudCA9IHRoaXM7IH1cblx0XG5cdGlmKCBwYXJlbnQgIT0gdGhpcyApe1xuXHRcdC8vIHNldCB0aGUgY29ycmVjdCBldmVudCB0eXBlXG5cdFx0ZXZlbnQudHlwZSA9IGV2ZW50LmRhdGE7XG5cdFx0Ly8gaGFuZGxlIGV2ZW50IGlmIHdlIGFjdHVhbGx5IGp1c3QgbW91c2VkIG9uIHRvIGEgbm9uIHN1Yi1lbGVtZW50XG5cdFx0alF1ZXJ5LmV2ZW50LmhhbmRsZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cbn07XG5cdFxualF1ZXJ5LmVhY2goeyBcblx0bW91c2VvdmVyOiAnbW91c2VlbnRlcicsIFxuXHRtb3VzZW91dDogJ21vdXNlbGVhdmUnXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICl7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKXtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIG9yaWcsIHdpdGhpbkVsZW1lbnQsIGZpeCApO1xuXHRcdH0sXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCl7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCBvcmlnLCB3aXRoaW5FbGVtZW50ICk7XG5cdFx0fVxuXHR9O1x0XHRcdCAgIFxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRiaW5kOiBmdW5jdGlvbiggdHlwZSwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHR5cGUgPT0gXCJ1bmxvYWRcIiA/IHRoaXMub25lKHR5cGUsIGRhdGEsIGZuKSA6IHRoaXMuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZSwgZm4gfHwgZGF0YSwgZm4gJiYgZGF0YSApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdG9uZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEsIGZuICkge1xuXHRcdHZhciBvbmUgPSBqUXVlcnkuZXZlbnQucHJveHkoIGZuIHx8IGRhdGEsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRqUXVlcnkodGhpcykudW5iaW5kKGV2ZW50LCBvbmUpO1xuXHRcdFx0cmV0dXJuIChmbiB8fCBkYXRhKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZSwgb25lLCBmbiAmJiBkYXRhKTtcblx0XHR9KTtcblx0fSxcblxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlLCBmbiApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdGlmKCB0aGlzWzBdICl7XG5cdFx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuRXZlbnQodHlwZSk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZXZlbnQsIGRhdGEsIHRoaXNbMF0gKTtcblx0XHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdFx0fVx0XHRcblx0fSxcblxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHQvLyBTYXZlIHJlZmVyZW5jZSB0byBhcmd1bWVudHMgZm9yIGFjY2VzcyBpbiBjbG9zdXJlXG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsIGkgPSAxO1xuXG5cdFx0Ly8gbGluayBhbGwgdGhlIGZ1bmN0aW9ucywgc28gYW55IG9mIHRoZW0gY2FuIHVuYmluZCB0aGlzIGNsaWNrIGhhbmRsZXJcblx0XHR3aGlsZSggaSA8IGFyZ3MubGVuZ3RoIClcblx0XHRcdGpRdWVyeS5ldmVudC5wcm94eSggZm4sIGFyZ3NbaSsrXSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xpY2soIGpRdWVyeS5ldmVudC5wcm94eSggZm4sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHQvLyBGaWd1cmUgb3V0IHdoaWNoIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcblx0XHRcdHRoaXMubGFzdFRvZ2dsZSA9ICggdGhpcy5sYXN0VG9nZ2xlIHx8IDAgKSAlIGk7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGNsaWNrcyBzdG9wXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHQvLyBhbmQgZXhlY3V0ZSB0aGUgZnVuY3Rpb25cblx0XHRcdHJldHVybiBhcmdzWyB0aGlzLmxhc3RUb2dnbGUrKyBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSB8fCBmYWxzZTtcblx0XHR9KSk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKGZuT3ZlciwgZm5PdXQpIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGZuT3ZlcikubW91c2VsZWF2ZShmbk91dCk7XG5cdH0sXG5cblx0cmVhZHk6IGZ1bmN0aW9uKGZuKSB7XG5cdFx0Ly8gQXR0YWNoIHRoZSBsaXN0ZW5lcnNcblx0XHRiaW5kUmVhZHkoKTtcblxuXHRcdC8vIElmIHRoZSBET00gaXMgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggalF1ZXJ5LmlzUmVhZHkgKVxuXHRcdFx0Ly8gRXhlY3V0ZSB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHlcblx0XHRcdGZuLmNhbGwoIGRvY3VtZW50LCBqUXVlcnkgKTtcblxuXHRcdC8vIE90aGVyd2lzZSwgcmVtZW1iZXIgdGhlIGZ1bmN0aW9uIGZvciBsYXRlclxuXHRcdGVsc2Vcblx0XHRcdC8vIEFkZCB0aGUgZnVuY3Rpb24gdG8gdGhlIHdhaXQgbGlzdFxuXHRcdFx0alF1ZXJ5LnJlYWR5TGlzdC5wdXNoKCBmbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHRsaXZlOiBmdW5jdGlvbiggdHlwZSwgZm4gKXtcblx0XHR2YXIgcHJveHkgPSBqUXVlcnkuZXZlbnQucHJveHkoIGZuICk7XG5cdFx0cHJveHkuZ3VpZCArPSB0aGlzLnNlbGVjdG9yICsgdHlwZTtcblxuXHRcdGpRdWVyeShkb2N1bWVudCkuYmluZCggbGl2ZUNvbnZlcnQodHlwZSwgdGhpcy5zZWxlY3RvciksIHRoaXMuc2VsZWN0b3IsIHByb3h5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0XG5cdGRpZTogZnVuY3Rpb24oIHR5cGUsIGZuICl7XG5cdFx0alF1ZXJ5KGRvY3VtZW50KS51bmJpbmQoIGxpdmVDb252ZXJ0KHR5cGUsIHRoaXMuc2VsZWN0b3IpLCBmbiA/IHsgZ3VpZDogZm4uZ3VpZCArIHRoaXMuc2VsZWN0b3IgKyB0eXBlIH0gOiBudWxsICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBsaXZlSGFuZGxlciggZXZlbnQgKXtcblx0dmFyIGNoZWNrID0gUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBldmVudC50eXBlICsgXCIoXFxcXC58JClcIiksXG5cdFx0c3RvcCA9IHRydWUsXG5cdFx0ZWxlbXMgPSBbXTtcblxuXHRqUXVlcnkuZWFjaChqUXVlcnkuZGF0YSh0aGlzLCBcImV2ZW50c1wiKS5saXZlIHx8IFtdLCBmdW5jdGlvbihpLCBmbil7XG5cdFx0aWYgKCBjaGVjay50ZXN0KGZuLnR5cGUpICkge1xuXHRcdFx0dmFyIGVsZW0gPSBqUXVlcnkoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KGZuLmRhdGEpWzBdO1xuXHRcdFx0aWYgKCBlbGVtIClcblx0XHRcdFx0ZWxlbXMucHVzaCh7IGVsZW06IGVsZW0sIGZuOiBmbiB9KTtcblx0XHR9XG5cdH0pO1xuXG5cdGpRdWVyeS5lYWNoKGVsZW1zLCBmdW5jdGlvbigpe1xuXHRcdGlmICggdGhpcy5mbi5jYWxsKHRoaXMuZWxlbSwgZXZlbnQsIHRoaXMuZm4uZGF0YSkgPT09IGZhbHNlIClcblx0XHRcdHN0b3AgPSBmYWxzZTtcblx0fSk7XG5cblx0cmV0dXJuIHN0b3A7XG59XG5cbmZ1bmN0aW9uIGxpdmVDb252ZXJ0KHR5cGUsIHNlbGVjdG9yKXtcblx0cmV0dXJuIFtcImxpdmVcIiwgdHlwZSwgc2VsZWN0b3IucmVwbGFjZSgvXFwuL2csIFwiYFwiKS5yZXBsYWNlKC8gL2csIFwifFwiKV0uam9pbihcIi5cIik7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRpc1JlYWR5OiBmYWxzZSxcblx0cmVhZHlMaXN0OiBbXSxcblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIERPTSBpcyBub3QgYWxyZWFkeSBsb2FkZWRcblx0XHRpZiAoICFqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0XHRpZiAoIGpRdWVyeS5yZWFkeUxpc3QgKSB7XG5cdFx0XHRcdC8vIEV4ZWN1dGUgYWxsIG9mIHRoZW1cblx0XHRcdFx0alF1ZXJ5LmVhY2goIGpRdWVyeS5yZWFkeUxpc3QsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dGhpcy5jYWxsKCBkb2N1bWVudCwgalF1ZXJ5ICk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFJlc2V0IHRoZSBsaXN0IG9mIGZ1bmN0aW9uc1xuXHRcdFx0XHRqUXVlcnkucmVhZHlMaXN0ID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0XHRqUXVlcnkoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwicmVhZHlcIik7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIHJlYWR5Qm91bmQgPSBmYWxzZTtcblxuZnVuY3Rpb24gYmluZFJlYWR5KCl7XG5cdGlmICggcmVhZHlCb3VuZCApIHJldHVybjtcblx0cmVhZHlCb3VuZCA9IHRydWU7XG5cblx0Ly8gTW96aWxsYSwgT3BlcmEgYW5kIHdlYmtpdCBuaWdodGxpZXMgY3VycmVudGx5IHN1cHBvcnQgdGhpcyBldmVudFxuXHRpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbigpe1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGFyZ3VtZW50cy5jYWxsZWUsIGZhbHNlICk7XG5cdFx0XHRqUXVlcnkucmVhZHkoKTtcblx0XHR9LCBmYWxzZSApO1xuXG5cdC8vIElmIElFIGV2ZW50IG1vZGVsIGlzIHVzZWRcblx0fSBlbHNlIGlmICggZG9jdW1lbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0Ly8gZW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLFxuXHRcdC8vIG1heWJlIGxhdGUgYnV0IHNhZmUgYWxzbyBmb3IgaWZyYW1lc1xuXHRcdGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRcdFx0ZG9jdW1lbnQuZGV0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGFyZ3VtZW50cy5jYWxsZWUgKTtcblx0XHRcdFx0alF1ZXJ5LnJlYWR5KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBJZiBJRSBhbmQgbm90IGFuIGlmcmFtZVxuXHRcdC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcblx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0eXBlb2Ygd2luZG93LmZyYW1lRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiApIChmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNSZWFkeSApIHJldHVybjtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSWYgSUUgaXMgdXNlZCwgdXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcblx0XHRcdFx0Ly8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKFwibGVmdFwiKTtcblx0XHRcdH0gY2F0Y2goIGVycm9yICkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBhcmd1bWVudHMuY2FsbGVlLCAwICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG5cdFx0XHRqUXVlcnkucmVhZHkoKTtcblx0XHR9KSgpO1xuXHR9XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0alF1ZXJ5LmV2ZW50LmFkZCggd2luZG93LCBcImxvYWRcIiwgalF1ZXJ5LnJlYWR5ICk7XG59XG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyLGZvY3VzLGxvYWQscmVzaXplLHNjcm9sbCx1bmxvYWQsY2xpY2ssZGJsY2xpY2ssXCIgK1xuXHRcIm1vdXNlZG93bixtb3VzZXVwLG1vdXNlbW92ZSxtb3VzZW92ZXIsbW91c2VvdXQsbW91c2VlbnRlcixtb3VzZWxlYXZlLFwiICtcblx0XCJjaGFuZ2Usc2VsZWN0LHN1Ym1pdCxrZXlkb3duLGtleXByZXNzLGtleXVwLGVycm9yXCIpLnNwbGl0KFwiLFwiKSwgZnVuY3Rpb24oaSwgbmFtZSl7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24oZm4pe1xuXHRcdHJldHVybiBmbiA/IHRoaXMuYmluZChuYW1lLCBmbikgOiB0aGlzLnRyaWdnZXIobmFtZSk7XG5cdH07XG59KTtcblxuLy8gUHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcbi8vIEFuZCBwcmV2ZW50IGVycm9ycyBvbiByZWZyZXNoIHdpdGggZXZlbnRzIGxpa2UgbW91c2VvdmVyIGluIG90aGVyIGJyb3dzZXJzXG4vLyBXaW5kb3cgaXNuJ3QgaW5jbHVkZWQgc28gYXMgbm90IHRvIHVuYmluZCBleGlzdGluZyB1bmxvYWQgZXZlbnRzXG5qUXVlcnkoIHdpbmRvdyApLmJpbmQoICd1bmxvYWQnLCBmdW5jdGlvbigpeyBcblx0Zm9yICggdmFyIGlkIGluIGpRdWVyeS5jYWNoZSApXG5cdFx0Ly8gU2tpcCB0aGUgd2luZG93XG5cdFx0aWYgKCBpZCAhPSAxICYmIGpRdWVyeS5jYWNoZVsgaWQgXS5oYW5kbGUgKVxuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggalF1ZXJ5LmNhY2hlWyBpZCBdLmhhbmRsZS5lbGVtICk7XG59KTsgXG4oZnVuY3Rpb24oKXtcblxuXHRqUXVlcnkuc3VwcG9ydCA9IHt9O1xuXG5cdHZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0XHRpZCA9IFwic2NyaXB0XCIgKyAobmV3IERhdGUpLmdldFRpbWUoKTtcblxuXHRkaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRkaXYuaW5uZXJIVE1MID0gJyAgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPVwiL2FcIiBzdHlsZT1cImNvbG9yOnJlZDtmbG9hdDpsZWZ0O29wYWNpdHk6LjU7XCI+YTwvYT48c2VsZWN0PjxvcHRpb24+dGV4dDwvb3B0aW9uPjwvc2VsZWN0PjxvYmplY3Q+PHBhcmFtLz48L29iamVjdD4nO1xuXG5cdHZhciBhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLFxuXHRcdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWzBdO1xuXG5cdC8vIENhbid0IGdldCBiYXNpYyB0ZXN0IHN1cHBvcnRcblx0aWYgKCAhYWxsIHx8ICFhbGwubGVuZ3RoIHx8ICFhICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGpRdWVyeS5zdXBwb3J0ID0ge1xuXHRcdC8vIElFIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiAuaW5uZXJIVE1MIGlzIHVzZWRcblx0XHRsZWFkaW5nV2hpdGVzcGFjZTogZGl2LmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMyxcblx0XHRcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuXHRcdC8vIElFIHdpbGwgaW5zZXJ0IHRoZW0gaW50byBlbXB0eSB0YWJsZXNcblx0XHR0Ym9keTogIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCxcblx0XHRcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB5b3UgY2FuIGdldCBhbGwgZWxlbWVudHMgaW4gYW4gPG9iamVjdD4gZWxlbWVudFxuXHRcdC8vIElFIDcgYWx3YXlzIHJldHVybnMgbm8gcmVzdWx0c1xuXHRcdG9iamVjdEFsbDogISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJvYmplY3RcIilbMF1cblx0XHRcdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoLFxuXHRcdFxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuXHRcdC8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcblx0XHRodG1sU2VyaWFsaXplOiAhIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIikubGVuZ3RoLFxuXHRcdFxuXHRcdC8vIEdldCB0aGUgc3R5bGUgaW5mb3JtYXRpb24gZnJvbSBnZXRBdHRyaWJ1dGVcblx0XHQvLyAoSUUgdXNlcyAuY3NzVGV4dCBpbnN0ZWQpXG5cdFx0c3R5bGU6IC9yZWQvLnRlc3QoIGEuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgKSxcblx0XHRcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBVUkxzIGFyZW4ndCBtYW5pcHVsYXRlZFxuXHRcdC8vIChJRSBub3JtYWxpemVzIGl0IGJ5IGRlZmF1bHQpXG5cdFx0aHJlZk5vcm1hbGl6ZWQ6IGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIvYVwiLFxuXHRcdFxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGVsZW1lbnQgb3BhY2l0eSBleGlzdHNcblx0XHQvLyAoSUUgdXNlcyBmaWx0ZXIgaW5zdGVhZClcblx0XHRvcGFjaXR5OiBhLnN0eWxlLm9wYWNpdHkgPT09IFwiMC41XCIsXG5cdFx0XG5cdFx0Ly8gVmVyaWZ5IHN0eWxlIGZsb2F0IGV4aXN0ZW5jZVxuXHRcdC8vIChJRSB1c2VzIHN0eWxlRmxvYXQgaW5zdGVhZCBvZiBjc3NGbG9hdClcblx0XHRjc3NGbG9hdDogISFhLnN0eWxlLmNzc0Zsb2F0LFxuXG5cdFx0Ly8gV2lsbCBiZSBkZWZpbmVkIGxhdGVyXG5cdFx0c2NyaXB0RXZhbDogZmFsc2UsXG5cdFx0bm9DbG9uZUV2ZW50OiB0cnVlLFxuXHRcdGJveE1vZGVsOiBudWxsXG5cdH07XG5cdFxuXHRzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdHRyeSB7XG5cdFx0c2NyaXB0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggXCJ3aW5kb3cuXCIgKyBpZCArIFwiPTE7XCIgKSApO1xuXHR9IGNhdGNoKGUpe31cblxuXHRyb290Lmluc2VydEJlZm9yZSggc2NyaXB0LCByb290LmZpcnN0Q2hpbGQgKTtcblx0XG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBleGVjdXRpb24gb2YgY29kZSB3b3JrcyBieSBpbmplY3RpbmcgYSBzY3JpcHRcblx0Ly8gdGFnIHdpdGggYXBwZW5kQ2hpbGQvY3JlYXRlVGV4dE5vZGVcblx0Ly8gKElFIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzLCBmYWlscywgYW5kIHVzZXMgLnRleHQgaW5zdGVhZClcblx0aWYgKCB3aW5kb3dbIGlkIF0gKSB7XG5cdFx0alF1ZXJ5LnN1cHBvcnQuc2NyaXB0RXZhbCA9IHRydWU7XG5cdFx0ZGVsZXRlIHdpbmRvd1sgaWQgXTtcblx0fVxuXG5cdHJvb3QucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXG5cdGlmICggZGl2LmF0dGFjaEV2ZW50ICYmIGRpdi5maXJlRXZlbnQgKSB7XG5cdFx0ZGl2LmF0dGFjaEV2ZW50KFwib25jbGlja1wiLCBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gQ2xvbmluZyBhIG5vZGUgc2hvdWxkbid0IGNvcHkgb3ZlciBhbnlcblx0XHRcdC8vIGJvdW5kIGV2ZW50IGhhbmRsZXJzIChJRSBkb2VzIHRoaXMpXG5cdFx0XHRqUXVlcnkuc3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcblx0XHRcdGRpdi5kZXRhY2hFdmVudChcIm9uY2xpY2tcIiwgYXJndW1lbnRzLmNhbGxlZSk7XG5cdFx0fSk7XG5cdFx0ZGl2LmNsb25lTm9kZSh0cnVlKS5maXJlRXZlbnQoXCJvbmNsaWNrXCIpO1xuXHR9XG5cblx0Ly8gRmlndXJlIG91dCBpZiB0aGUgVzNDIGJveCBtb2RlbCB3b3JrcyBhcyBleHBlY3RlZFxuXHQvLyBkb2N1bWVudC5ib2R5IG11c3QgZXhpc3QgYmVmb3JlIHdlIGNhbiBkbyB0aGlzXG5cdGpRdWVyeShmdW5jdGlvbigpe1xuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cdFx0ZGl2LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIxcHhcIjtcblxuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXHRcdGpRdWVyeS5ib3hNb2RlbCA9IGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsID0gZGl2Lm9mZnNldFdpZHRoID09PSAyO1xuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHR9KTtcbn0pKCk7XG5cbnZhciBzdHlsZUZsb2F0ID0galF1ZXJ5LnN1cHBvcnQuY3NzRmxvYXQgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIjtcblxualF1ZXJ5LnByb3BzID0ge1xuXHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuXHRcImZsb2F0XCI6IHN0eWxlRmxvYXQsXG5cdGNzc0Zsb2F0OiBzdHlsZUZsb2F0LFxuXHRzdHlsZUZsb2F0OiBzdHlsZUZsb2F0LFxuXHRyZWFkb25seTogXCJyZWFkT25seVwiLFxuXHRtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG5cdGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXG5cdHJvd3NwYW46IFwicm93U3BhblwiLFxuXHR0YWJpbmRleDogXCJ0YWJJbmRleFwiXG59O1xualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZFxuXHRfbG9hZDogalF1ZXJ5LmZuLmxvYWQsXG5cblx0bG9hZDogZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2xvYWQoIHVybCApO1xuXG5cdFx0dmFyIG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcblx0XHRpZiAoIG9mZiA+PSAwICkge1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gdXJsLnNsaWNlKG9mZiwgdXJsLmxlbmd0aCk7XG5cdFx0XHR1cmwgPSB1cmwuc2xpY2UoMCwgb2ZmKTtcblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IHRvIGEgR0VUIHJlcXVlc3Rcblx0XHR2YXIgdHlwZSA9IFwiR0VUXCI7XG5cblx0XHQvLyBJZiB0aGUgc2Vjb25kIHBhcmFtZXRlciB3YXMgcHJvdmlkZWRcblx0XHRpZiAoIHBhcmFtcyApXG5cdFx0XHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXHRcdFx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHRcdFx0fSBlbHNlIGlmKCB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRwYXJhbXMgPSBqUXVlcnkucGFyYW0oIHBhcmFtcyApO1xuXHRcdFx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdFx0XHR9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBSZXF1ZXN0IHRoZSByZW1vdGUgZG9jdW1lbnRcblx0XHRqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXMsXG5cdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24ocmVzLCBzdGF0dXMpe1xuXHRcdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBpbmplY3QgdGhlIEhUTUwgaW50byBhbGwgdGhlIG1hdGNoZWQgZWxlbWVudHNcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT0gXCJzdWNjZXNzXCIgfHwgc3RhdHVzID09IFwibm90bW9kaWZpZWRcIiApXG5cdFx0XHRcdFx0Ly8gU2VlIGlmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZFxuXHRcdFx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgZGl2IHRvIGhvbGQgdGhlIHJlc3VsdHNcblx0XHRcdFx0XHRcdGpRdWVyeShcIjxkaXYvPlwiKVxuXHRcdFx0XHRcdFx0XHQvLyBpbmplY3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBkb2N1bWVudCBpbiwgcmVtb3ZpbmcgdGhlIHNjcmlwdHNcblx0XHRcdFx0XHRcdFx0Ly8gdG8gYXZvaWQgYW55ICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzIGluIElFXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQocmVzLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC88c2NyaXB0KC58XFxzKSo/XFwvc2NyaXB0Pi9nLCBcIlwiKSlcblxuXHRcdFx0XHRcdFx0XHQvLyBMb2NhdGUgdGhlIHNwZWNpZmllZCBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHQuZmluZChzZWxlY3RvcikgOlxuXG5cdFx0XHRcdFx0XHQvLyBJZiBub3QsIGp1c3QgaW5qZWN0IHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRcdFx0cmVzLnJlc3BvbnNlVGV4dCApO1xuXG5cdFx0XHRcdGlmKCBjYWxsYmFjayApXG5cdFx0XHRcdFx0c2VsZi5lYWNoKCBjYWxsYmFjaywgW3Jlcy5yZXNwb25zZVRleHQsIHN0YXR1cywgcmVzXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkodGhpcy5lbGVtZW50cykgOiB0aGlzO1xuXHRcdH0pXG5cdFx0LmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhdGhpcy5kaXNhYmxlZCAmJlxuXHRcdFx0XHQodGhpcy5jaGVja2VkIHx8IC9zZWxlY3R8dGV4dGFyZWEvaS50ZXN0KHRoaXMubm9kZU5hbWUpIHx8XG5cdFx0XHRcdFx0L3RleHR8aGlkZGVufHBhc3N3b3JkL2kudGVzdCh0aGlzLnR5cGUpKTtcblx0XHR9KVxuXHRcdC5tYXAoZnVuY3Rpb24oaSwgZWxlbSl7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KHRoaXMpLnZhbCgpO1xuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID8gbnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KHZhbCkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24odmFsLCBpKXtcblx0XHRcdFx0XHRcdHJldHVybiB7bmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsfTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0e25hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFwiYWpheFN0YXJ0LGFqYXhTdG9wLGFqYXhDb21wbGV0ZSxhamF4RXJyb3IsYWpheFN1Y2Nlc3MsYWpheFNlbmRcIi5zcGxpdChcIixcIiksIGZ1bmN0aW9uKGksbyl7XG5cdGpRdWVyeS5mbltvXSA9IGZ1bmN0aW9uKGYpe1xuXHRcdHJldHVybiB0aGlzLmJpbmQobywgZik7XG5cdH07XG59KTtcblxudmFyIGpzYyA9IG5vdygpO1xuXG5qUXVlcnkuZXh0ZW5kKHtcbiAgXG5cdGdldDogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cdFx0Ly8gc2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9tbWl0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdFx0dHlwZTogXCJHRVRcIixcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGVcblx0XHR9KTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KHVybCwgbnVsbCwgY2FsbGJhY2ssIFwic2NyaXB0XCIpO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiKTtcblx0fSxcblxuXHRwb3N0OiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHRcdHR5cGU6IFwiUE9TVFwiLFxuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2ssXG5cdFx0XHRkYXRhVHlwZTogdHlwZVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHNldHRpbmdzICk7XG5cdH0sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdCovXG5cdFx0Ly8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdDsgTWljcm9zb2Z0IGZhaWxlZCB0byBwcm9wZXJseVxuXHRcdC8vIGltcGxlbWVudCB0aGUgWE1MSHR0cFJlcXVlc3QgaW4gSUU3LCBzbyB3ZSB1c2UgdGhlIEFjdGl2ZVhPYmplY3Qgd2hlbiBpdCBpcyBhdmFpbGFibGVcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZW4gYnkgY2FsbGluZyBqUXVlcnkuYWpheFNldHVwXG5cdFx0eGhyOmZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gd2luZG93LkFjdGl2ZVhPYmplY3QgPyBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpIDogbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0fSxcblx0XHRhY2NlcHRzOiB7XG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCIsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdF9kZWZhdWx0OiBcIiovKlwiXG5cdFx0fVxuXHR9LFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblxuXHRhamF4OiBmdW5jdGlvbiggcyApIHtcblx0XHQvLyBFeHRlbmQgdGhlIHNldHRpbmdzLCBidXQgcmUtZXh0ZW5kICdzJyBzbyB0aGF0IGl0IGNhbiBiZVxuXHRcdC8vIGNoZWNrZWQgYWdhaW4gbGF0ZXIgKGluIHRoZSB0ZXN0IHN1aXRlLCBzcGVjaWZpY2FsbHkpXG5cdFx0cyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgcywgalF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgalF1ZXJ5LmFqYXhTZXR0aW5ncywgcykpO1xuXG5cdFx0dmFyIGpzb25wLCBqc3JlID0gLz1cXD8oJnwkKS9nLCBzdGF0dXMsIGRhdGEsXG5cdFx0XHR0eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBjb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKVxuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKHMuZGF0YSk7XG5cblx0XHQvLyBIYW5kbGUgSlNPTlAgUGFyYW1ldGVyIENhbGxiYWNrc1xuXHRcdGlmICggcy5kYXRhVHlwZSA9PSBcImpzb25wXCIgKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT0gXCJHRVRcIiApIHtcblx0XHRcdFx0aWYgKCAhcy51cmwubWF0Y2goanNyZSkgKVxuXHRcdFx0XHRcdHMudXJsICs9IChzLnVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiKSArIChzLmpzb25wIHx8IFwiY2FsbGJhY2tcIikgKyBcIj0/XCI7XG5cdFx0XHR9IGVsc2UgaWYgKCAhcy5kYXRhIHx8ICFzLmRhdGEubWF0Y2goanNyZSkgKVxuXHRcdFx0XHRzLmRhdGEgPSAocy5kYXRhID8gcy5kYXRhICsgXCImXCIgOiBcIlwiKSArIChzLmpzb25wIHx8IFwiY2FsbGJhY2tcIikgKyBcIj0/XCI7XG5cdFx0XHRzLmRhdGFUeXBlID0gXCJqc29uXCI7XG5cdFx0fVxuXG5cdFx0Ly8gQnVpbGQgdGVtcG9yYXJ5IEpTT05QIGZ1bmN0aW9uXG5cdFx0aWYgKCBzLmRhdGFUeXBlID09IFwianNvblwiICYmIChzLmRhdGEgJiYgcy5kYXRhLm1hdGNoKGpzcmUpIHx8IHMudXJsLm1hdGNoKGpzcmUpKSApIHtcblx0XHRcdGpzb25wID0gXCJqc29ucFwiICsganNjKys7XG5cblx0XHRcdC8vIFJlcGxhY2UgdGhlID0/IHNlcXVlbmNlIGJvdGggaW4gdGhlIHF1ZXJ5IHN0cmluZyBhbmQgdGhlIGRhdGFcblx0XHRcdGlmICggcy5kYXRhIClcblx0XHRcdFx0cy5kYXRhID0gKHMuZGF0YSArIFwiXCIpLnJlcGxhY2UoanNyZSwgXCI9XCIgKyBqc29ucCArIFwiJDFcIik7XG5cdFx0XHRzLnVybCA9IHMudXJsLnJlcGxhY2UoanNyZSwgXCI9XCIgKyBqc29ucCArIFwiJDFcIik7XG5cblx0XHRcdC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlXG5cdFx0XHQvLyB0aGF0IGEgSlNPTlAgc3R5bGUgcmVzcG9uc2UgaXMgZXhlY3V0ZWQgcHJvcGVybHlcblx0XHRcdHMuZGF0YVR5cGUgPSBcInNjcmlwdFwiO1xuXG5cdFx0XHQvLyBIYW5kbGUgSlNPTlAtc3R5bGUgbG9hZGluZ1xuXHRcdFx0d2luZG93WyBqc29ucCBdID0gZnVuY3Rpb24odG1wKXtcblx0XHRcdFx0ZGF0YSA9IHRtcDtcblx0XHRcdFx0c3VjY2VzcygpO1xuXHRcdFx0XHRjb21wbGV0ZSgpO1xuXHRcdFx0XHQvLyBHYXJiYWdlIGNvbGxlY3Rcblx0XHRcdFx0d2luZG93WyBqc29ucCBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR0cnl7IGRlbGV0ZSB3aW5kb3dbIGpzb25wIF07IH0gY2F0Y2goZSl7fVxuXHRcdFx0XHRpZiAoIGhlYWQgKVxuXHRcdFx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoIHMuZGF0YVR5cGUgPT0gXCJzY3JpcHRcIiAmJiBzLmNhY2hlID09IG51bGwgKVxuXHRcdFx0cy5jYWNoZSA9IGZhbHNlO1xuXG5cdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSAmJiB0eXBlID09IFwiR0VUXCIgKSB7XG5cdFx0XHR2YXIgdHMgPSBub3coKTtcblx0XHRcdC8vIHRyeSByZXBsYWNpbmcgXz0gaWYgaXQgaXMgdGhlcmVcblx0XHRcdHZhciByZXQgPSBzLnVybC5yZXBsYWNlKC8oXFw/fCYpXz0uKj8oJnwkKS8sIFwiJDFfPVwiICsgdHMgKyBcIiQyXCIpO1xuXHRcdFx0Ly8gaWYgbm90aGluZyB3YXMgcmVwbGFjZWQsIGFkZCB0aW1lc3RhbXAgdG8gdGhlIGVuZFxuXHRcdFx0cy51cmwgPSByZXQgKyAoKHJldCA9PSBzLnVybCkgPyAocy51cmwubWF0Y2goL1xcPy8pID8gXCImXCIgOiBcIj9cIikgKyBcIl89XCIgKyB0cyA6IFwiXCIpO1xuXHRcdH1cblxuXHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmwgZm9yIGdldCByZXF1ZXN0c1xuXHRcdGlmICggcy5kYXRhICYmIHR5cGUgPT0gXCJHRVRcIiApIHtcblx0XHRcdHMudXJsICs9IChzLnVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiKSArIHMuZGF0YTtcblxuXHRcdFx0Ly8gSUUgbGlrZXMgdG8gc2VuZCBib3RoIGdldCBhbmQgcG9zdCBkYXRhLCBwcmV2ZW50IHRoaXNcblx0XHRcdHMuZGF0YSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggcy5nbG9iYWwgJiYgISBqUXVlcnkuYWN0aXZlKysgKVxuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblxuXHRcdC8vIE1hdGNoZXMgYW4gYWJzb2x1dGUgVVJMLCBhbmQgc2F2ZXMgdGhlIGRvbWFpblxuXHRcdHZhciBwYXJ0cyA9IC9eKFxcdys6KT9cXC9cXC8oW15cXC8/I10rKS8uZXhlYyggcy51cmwgKTtcblxuXHRcdC8vIElmIHdlJ3JlIHJlcXVlc3RpbmcgYSByZW1vdGUgZG9jdW1lbnRcblx0XHQvLyBhbmQgdHJ5aW5nIHRvIGxvYWQgSlNPTiBvciBTY3JpcHQgd2l0aCBhIEdFVFxuXHRcdGlmICggcy5kYXRhVHlwZSA9PSBcInNjcmlwdFwiICYmIHR5cGUgPT0gXCJHRVRcIiAmJiBwYXJ0c1xuXHRcdFx0JiYgKCBwYXJ0c1sxXSAmJiBwYXJ0c1sxXSAhPSBsb2NhdGlvbi5wcm90b2NvbCB8fCBwYXJ0c1syXSAhPSBsb2NhdGlvbi5ob3N0ICkpe1xuXG5cdFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHRcdFx0c2NyaXB0LnNyYyA9IHMudXJsO1xuXHRcdFx0aWYgKHMuc2NyaXB0Q2hhcnNldClcblx0XHRcdFx0c2NyaXB0LmNoYXJzZXQgPSBzLnNjcmlwdENoYXJzZXQ7XG5cblx0XHRcdC8vIEhhbmRsZSBTY3JpcHQgbG9hZGluZ1xuXHRcdFx0aWYgKCAhanNvbnAgKSB7XG5cdFx0XHRcdHZhciBkb25lID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gQXR0YWNoIGhhbmRsZXJzIGZvciBhbGwgYnJvd3NlcnNcblx0XHRcdFx0c2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmICggIWRvbmUgJiYgKCF0aGlzLnJlYWR5U3RhdGUgfHxcblx0XHRcdFx0XHRcdFx0dGhpcy5yZWFkeVN0YXRlID09IFwibG9hZGVkXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikgKSB7XG5cdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHN1Y2Nlc3MoKTtcblx0XHRcdFx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHRoZWFkLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuXHRcdFx0Ly8gV2UgaGFuZGxlIGV2ZXJ5dGhpbmcgdXNpbmcgdGhlIHNjcmlwdCBlbGVtZW50IGluamVjdGlvblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdERvbmUgPSBmYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0aGUgcmVxdWVzdCBvYmplY3Rcblx0XHR2YXIgeGhyID0gcy54aHIoKTtcblxuXHRcdC8vIE9wZW4gdGhlIHNvY2tldFxuXHRcdC8vIFBhc3NpbmcgbnVsbCB1c2VybmFtZSwgZ2VuZXJhdGVzIGEgbG9naW4gcG9wdXAgb24gT3BlcmEgKCMyODY1KVxuXHRcdGlmKCBzLnVzZXJuYW1lIClcblx0XHRcdHhoci5vcGVuKHR5cGUsIHMudXJsLCBzLmFzeW5jLCBzLnVzZXJuYW1lLCBzLnBhc3N3b3JkKTtcblx0XHRlbHNlXG5cdFx0XHR4aHIub3Blbih0eXBlLCBzLnVybCwgcy5hc3luYyk7XG5cblx0XHQvLyBOZWVkIGFuIGV4dHJhIHRyeS9jYXRjaCBmb3IgY3Jvc3MgZG9tYWluIHJlcXVlc3RzIGluIEZpcmVmb3ggM1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRcdGlmICggcy5kYXRhIClcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XG5cblx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgaGVhZGVyLCBpZiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApXG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIixcblx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkW3MudXJsXSB8fCBcIlRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UXCIgKTtcblxuXHRcdFx0Ly8gU2V0IGhlYWRlciBzbyB0aGUgY2FsbGVkIHNjcmlwdCBrbm93cyB0aGF0IGl0J3MgYW4gWE1MSHR0cFJlcXVlc3Rcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuXG5cdFx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBzLmRhdGFUeXBlICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlIF0gKyBcIiwgKi8qXCIgOlxuXHRcdFx0XHRzLmFjY2VwdHMuX2RlZmF1bHQgKTtcblx0XHR9IGNhdGNoKGUpe31cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJiBzLmJlZm9yZVNlbmQoeGhyLCBzKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdGlmICggcy5nbG9iYWwgJiYgISAtLWpRdWVyeS5hY3RpdmUgKVxuXHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHQvLyBjbG9zZSBvcGVuZGVkIHNvY2tldFxuXHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBzLmdsb2JhbCApXG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTZW5kXCIsIFt4aHIsIHNdKTtcblxuXHRcdC8vIFdhaXQgZm9yIGEgcmVzcG9uc2UgdG8gY29tZSBiYWNrXG5cdFx0dmFyIG9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGlzVGltZW91dCl7XG5cdFx0XHQvLyBUaGUgcmVxdWVzdCB3YXMgYWJvcnRlZCwgY2xlYXIgdGhlIGludGVydmFsIGFuZCBkZWNyZW1lbnQgalF1ZXJ5LmFjdGl2ZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09IDApIHtcblx0XHRcdFx0aWYgKGl2YWwpIHtcblx0XHRcdFx0XHQvLyBjbGVhciBwb2xsIGludGVydmFsXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChpdmFsKTtcblx0XHRcdFx0XHRpdmFsID0gbnVsbDtcblx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0XHRpZiAoIHMuZ2xvYmFsICYmICEgLS1qUXVlcnkuYWN0aXZlIClcblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0Ly8gVGhlIHRyYW5zZmVyIGlzIGNvbXBsZXRlIGFuZCB0aGUgZGF0YSBpcyBhdmFpbGFibGUsIG9yIHRoZSByZXF1ZXN0IHRpbWVkIG91dFxuXHRcdFx0fSBlbHNlIGlmICggIXJlcXVlc3REb25lICYmIHhociAmJiAoeGhyLnJlYWR5U3RhdGUgPT0gNCB8fCBpc1RpbWVvdXQgPT0gXCJ0aW1lb3V0XCIpICkge1xuXHRcdFx0XHRyZXF1ZXN0RG9uZSA9IHRydWU7XG5cblx0XHRcdFx0Ly8gY2xlYXIgcG9sbCBpbnRlcnZhbFxuXHRcdFx0XHRpZiAoaXZhbCkge1xuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoaXZhbCk7XG5cdFx0XHRcdFx0aXZhbCA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0dXMgPSBpc1RpbWVvdXQgPT0gXCJ0aW1lb3V0XCIgPyBcInRpbWVvdXRcIiA6XG5cdFx0XHRcdFx0IWpRdWVyeS5odHRwU3VjY2VzcyggeGhyICkgPyBcImVycm9yXCIgOlxuXHRcdFx0XHRcdHMuaWZNb2RpZmllZCAmJiBqUXVlcnkuaHR0cE5vdE1vZGlmaWVkKCB4aHIsIHMudXJsICkgPyBcIm5vdG1vZGlmaWVkXCIgOlxuXHRcdFx0XHRcdFwic3VjY2Vzc1wiO1xuXG5cdFx0XHRcdGlmICggc3RhdHVzID09IFwic3VjY2Vzc1wiICkge1xuXHRcdFx0XHRcdC8vIFdhdGNoIGZvciwgYW5kIGNhdGNoLCBYTUwgZG9jdW1lbnQgcGFyc2UgZXJyb3JzXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdC8vIHByb2Nlc3MgdGhlIGRhdGEgKHJ1bnMgdGhlIHhtbCB0aHJvdWdoIGh0dHBEYXRhIHJlZ2FyZGxlc3Mgb2YgY2FsbGJhY2spXG5cdFx0XHRcdFx0XHRkYXRhID0galF1ZXJ5Lmh0dHBEYXRhKCB4aHIsIHMuZGF0YVR5cGUsIHMgKTtcblx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IFwicGFyc2VyZXJyb3JcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCBvciBub3Rtb2RpZmllZFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PSBcInN1Y2Nlc3NcIiApIHtcblx0XHRcdFx0XHQvLyBDYWNoZSBMYXN0LU1vZGlmaWVkIGhlYWRlciwgaWYgaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRcdHZhciBtb2RSZXM7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdG1vZFJlcyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XG5cdFx0XHRcdFx0fSBjYXRjaChlKSB7fSAvLyBzd2FsbG93IGV4Y2VwdGlvbiB0aHJvd24gYnkgRkYgaWYgaGVhZGVyIGlzIG5vdCBhdmFpbGFibGVcblxuXHRcdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICYmIG1vZFJlcyApXG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkW3MudXJsXSA9IG1vZFJlcztcblxuXHRcdFx0XHRcdC8vIEpTT05QIGhhbmRsZXMgaXRzIG93biBzdWNjZXNzIGNhbGxiYWNrXG5cdFx0XHRcdFx0aWYgKCAhanNvbnAgKVxuXHRcdFx0XHRcdFx0c3VjY2VzcygpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRqUXVlcnkuaGFuZGxlRXJyb3IocywgeGhyLCBzdGF0dXMpO1xuXG5cdFx0XHRcdC8vIEZpcmUgdGhlIGNvbXBsZXRlIGhhbmRsZXJzXG5cdFx0XHRcdGNvbXBsZXRlKCk7XG5cblx0XHRcdFx0aWYgKCBpc1RpbWVvdXQgKVxuXHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXG5cdFx0XHRcdC8vIFN0b3AgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGlmICggcy5hc3luYyApXG5cdFx0XHRcdFx0eGhyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKCBzLmFzeW5jICkge1xuXHRcdFx0Ly8gZG9uJ3QgYXR0YWNoIHRoZSBoYW5kbGVyIHRvIHRoZSByZXF1ZXN0LCBqdXN0IHBvbGwgaXQgaW5zdGVhZFxuXHRcdFx0dmFyIGl2YWwgPSBzZXRJbnRlcnZhbChvbnJlYWR5c3RhdGVjaGFuZ2UsIDEzKTtcblxuXHRcdFx0Ly8gVGltZW91dCBjaGVja2VyXG5cdFx0XHRpZiAoIHMudGltZW91dCA+IDAgKVxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGhhcHBlbmluZ1xuXHRcdFx0XHRcdGlmICggeGhyICYmICFyZXF1ZXN0RG9uZSApXG5cdFx0XHRcdFx0XHRvbnJlYWR5c3RhdGVjaGFuZ2UoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU2VuZCB0aGUgZGF0YVxuXHRcdHRyeSB7XG5cdFx0XHR4aHIuc2VuZChzLmRhdGEpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0alF1ZXJ5LmhhbmRsZUVycm9yKHMsIHhociwgbnVsbCwgZSk7XG5cdFx0fVxuXG5cdFx0Ly8gZmlyZWZveCAxLjUgZG9lc24ndCBmaXJlIHN0YXRlY2hhbmdlIGZvciBzeW5jIHJlcXVlc3RzXG5cdFx0aWYgKCAhcy5hc3luYyApXG5cdFx0XHRvbnJlYWR5c3RhdGVjaGFuZ2UoKTtcblxuXHRcdGZ1bmN0aW9uIHN1Y2Nlc3MoKXtcblx0XHRcdC8vIElmIGEgbG9jYWwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgZmlyZSBpdCBhbmQgcGFzcyBpdCB0aGUgZGF0YVxuXHRcdFx0aWYgKCBzLnN1Y2Nlc3MgKVxuXHRcdFx0XHRzLnN1Y2Nlc3MoIGRhdGEsIHN0YXR1cyApO1xuXG5cdFx0XHQvLyBGaXJlIHRoZSBnbG9iYWwgY2FsbGJhY2tcblx0XHRcdGlmICggcy5nbG9iYWwgKVxuXHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3VjY2Vzc1wiLCBbeGhyLCBzXSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCl7XG5cdFx0XHQvLyBQcm9jZXNzIHJlc3VsdFxuXHRcdFx0aWYgKCBzLmNvbXBsZXRlIClcblx0XHRcdFx0cy5jb21wbGV0ZSh4aHIsIHN0YXR1cyk7XG5cblx0XHRcdC8vIFRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWRcblx0XHRcdGlmICggcy5nbG9iYWwgKVxuXHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgW3hociwgc10gKTtcblxuXHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRpZiAoIHMuZ2xvYmFsICYmICEgLS1qUXVlcnkuYWN0aXZlIClcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdH1cblxuXHRcdC8vIHJldHVybiBYTUxIdHRwUmVxdWVzdCB0byBhbGxvdyBhYm9ydGluZyB0aGUgcmVxdWVzdCBldGMuXG5cdFx0cmV0dXJuIHhocjtcblx0fSxcblxuXHRoYW5kbGVFcnJvcjogZnVuY3Rpb24oIHMsIHhociwgc3RhdHVzLCBlICkge1xuXHRcdC8vIElmIGEgbG9jYWwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgZmlyZSBpdFxuXHRcdGlmICggcy5lcnJvciApIHMuZXJyb3IoIHhociwgc3RhdHVzLCBlICk7XG5cblx0XHQvLyBGaXJlIHRoZSBnbG9iYWwgY2FsbGJhY2tcblx0XHRpZiAoIHMuZ2xvYmFsIClcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhFcnJvclwiLCBbeGhyLCBzLCBlXSApO1xuXHR9LFxuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gRGV0ZXJtaW5lcyBpZiBhbiBYTUxIdHRwUmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCBvciBub3Rcblx0aHR0cFN1Y2Nlc3M6IGZ1bmN0aW9uKCB4aHIgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIElFIGVycm9yIHNvbWV0aW1lcyByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0IHNvIHRyZWF0IGl0IGFzIHN1Y2Nlc3MsIHNlZSAjMTQ1MFxuXHRcdFx0cmV0dXJuICF4aHIuc3RhdHVzICYmIGxvY2F0aW9uLnByb3RvY29sID09IFwiZmlsZTpcIiB8fFxuXHRcdFx0XHQoIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgKSB8fCB4aHIuc3RhdHVzID09IDMwNCB8fCB4aHIuc3RhdHVzID09IDEyMjM7XG5cdFx0fSBjYXRjaChlKXt9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8vIERldGVybWluZXMgaWYgYW4gWE1MSHR0cFJlcXVlc3QgcmV0dXJucyBOb3RNb2RpZmllZFxuXHRodHRwTm90TW9kaWZpZWQ6IGZ1bmN0aW9uKCB4aHIsIHVybCApIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIHhoclJlcyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XG5cblx0XHRcdC8vIEZpcmVmb3ggYWx3YXlzIHJldHVybnMgMjAwLiBjaGVjayBMYXN0LU1vZGlmaWVkIGRhdGVcblx0XHRcdHJldHVybiB4aHIuc3RhdHVzID09IDMwNCB8fCB4aHJSZXMgPT0galF1ZXJ5Lmxhc3RNb2RpZmllZFt1cmxdO1xuXHRcdH0gY2F0Y2goZSl7fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRodHRwRGF0YTogZnVuY3Rpb24oIHhociwgdHlwZSwgcyApIHtcblx0XHR2YXIgY3QgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIiksXG5cdFx0XHR4bWwgPSB0eXBlID09IFwieG1sXCIgfHwgIXR5cGUgJiYgY3QgJiYgY3QuaW5kZXhPZihcInhtbFwiKSA+PSAwLFxuXHRcdFx0ZGF0YSA9IHhtbCA/IHhoci5yZXNwb25zZVhNTCA6IHhoci5yZXNwb25zZVRleHQ7XG5cblx0XHRpZiAoIHhtbCAmJiBkYXRhLmRvY3VtZW50RWxlbWVudC50YWdOYW1lID09IFwicGFyc2VyZXJyb3JcIiApXG5cdFx0XHR0aHJvdyBcInBhcnNlcmVycm9yXCI7XG5cdFx0XHRcblx0XHQvLyBBbGxvdyBhIHByZS1maWx0ZXJpbmcgZnVuY3Rpb24gdG8gc2FuaXRpemUgdGhlIHJlc3BvbnNlXG5cdFx0Ly8gcyAhPSBudWxsIGlzIGNoZWNrZWQgdG8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdGlmKCBzICYmIHMuZGF0YUZpbHRlciApXG5cdFx0XHRkYXRhID0gcy5kYXRhRmlsdGVyKCBkYXRhLCB0eXBlICk7XG5cblx0XHQvLyBUaGUgZmlsdGVyIGNhbiBhY3R1YWxseSBwYXJzZSB0aGUgcmVzcG9uc2Vcblx0XHRpZiggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKXtcblxuXHRcdFx0Ly8gSWYgdGhlIHR5cGUgaXMgXCJzY3JpcHRcIiwgZXZhbCBpdCBpbiBnbG9iYWwgY29udGV4dFxuXHRcdFx0aWYgKCB0eXBlID09IFwic2NyaXB0XCIgKVxuXHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggZGF0YSApO1xuXG5cdFx0XHQvLyBHZXQgdGhlIEphdmFTY3JpcHQgb2JqZWN0LCBpZiBKU09OIGlzIHVzZWQuXG5cdFx0XHRpZiAoIHR5cGUgPT0gXCJqc29uXCIgKVxuXHRcdFx0XHRkYXRhID0gd2luZG93W1wiZXZhbFwiXShcIihcIiArIGRhdGEgKyBcIilcIik7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdC8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG5cdC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xuXHRwYXJhbTogZnVuY3Rpb24oIGEgKSB7XG5cdFx0dmFyIHMgPSBbIF07XG5cblx0XHRmdW5jdGlvbiBhZGQoIGtleSwgdmFsdWUgKXtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5XG5cdFx0Ly8gb2YgZm9ybSBlbGVtZW50c1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkgKVxuXHRcdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKXtcblx0XHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBhc3N1bWUgdGhhdCBpdCdzIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnNcblx0XHRlbHNlXG5cdFx0XHQvLyBTZXJpYWxpemUgdGhlIGtleS92YWx1ZXNcblx0XHRcdGZvciAoIHZhciBqIGluIGEgKVxuXHRcdFx0XHQvLyBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXkgdGhlbiB0aGUga2V5IG5hbWVzIG5lZWQgdG8gYmUgcmVwZWF0ZWRcblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheShhW2pdKSApXG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFbal0sIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRhZGQoIGosIHRoaXMgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFkZCggaiwgalF1ZXJ5LmlzRnVuY3Rpb24oYVtqXSkgPyBhW2pdKCkgOiBhW2pdICk7XG5cblx0XHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdFx0cmV0dXJuIHMuam9pbihcIiZcIikucmVwbGFjZSgvJTIwL2csIFwiK1wiKTtcblx0fVxuXG59KTtcbnZhciBlbGVtZGlzcGxheSA9IHt9LFxuXHR0aW1lcklkLFxuXHRmeEF0dHJzID0gW1xuXHRcdC8vIGhlaWdodCBhbmltYXRpb25zXG5cdFx0WyBcImhlaWdodFwiLCBcIm1hcmdpblRvcFwiLCBcIm1hcmdpbkJvdHRvbVwiLCBcInBhZGRpbmdUb3BcIiwgXCJwYWRkaW5nQm90dG9tXCIgXSxcblx0XHQvLyB3aWR0aCBhbmltYXRpb25zXG5cdFx0WyBcIndpZHRoXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwicGFkZGluZ0xlZnRcIiwgXCJwYWRkaW5nUmlnaHRcIiBdLFxuXHRcdC8vIG9wYWNpdHkgYW5pbWF0aW9uc1xuXHRcdFsgXCJvcGFjaXR5XCIgXVxuXHRdO1xuXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgbnVtICl7XG5cdHZhciBvYmogPSB7fTtcblx0alF1ZXJ5LmVhY2goIGZ4QXR0cnMuY29uY2F0LmFwcGx5KFtdLCBmeEF0dHJzLnNsaWNlKDAsbnVtKSksIGZ1bmN0aW9uKCl7XG5cdFx0b2JqWyB0aGlzIF0gPSB0eXBlO1xuXHR9KTtcblx0cmV0dXJuIG9iajtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHNob3c6IGZ1bmN0aW9uKHNwZWVkLGNhbGxiYWNrKXtcblx0XHRpZiAoIHNwZWVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggZ2VuRngoXCJzaG93XCIsIDMpLCBzcGVlZCwgY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuXHRcdFx0XHR2YXIgb2xkID0galF1ZXJ5LmRhdGEodGhpc1tpXSwgXCJvbGRkaXNwbGF5XCIpO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gb2xkIHx8IFwiXCI7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIGpRdWVyeS5jc3ModGhpc1tpXSwgXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0XHR2YXIgdGFnTmFtZSA9IHRoaXNbaV0udGFnTmFtZSwgZGlzcGxheTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIGVsZW1kaXNwbGF5WyB0YWdOYW1lIF0gKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIHRhZ05hbWUgXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGVsZW0gPSBqUXVlcnkoXCI8XCIgKyB0YWdOYW1lICsgXCIgLz5cIikuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gZWxlbS5jc3MoXCJkaXNwbGF5XCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApXG5cdFx0XHRcdFx0XHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGVsZW1kaXNwbGF5WyB0YWdOYW1lIF0gPSBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSBqUXVlcnkuZGF0YSh0aGlzW2ldLCBcIm9sZGRpc3BsYXlcIiwgZGlzcGxheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZGU6IGZ1bmN0aW9uKHNwZWVkLGNhbGxiYWNrKXtcblx0XHRpZiAoIHNwZWVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggZ2VuRngoXCJoaWRlXCIsIDMpLCBzcGVlZCwgY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuXHRcdFx0XHR2YXIgb2xkID0galF1ZXJ5LmRhdGEodGhpc1tpXSwgXCJvbGRkaXNwbGF5XCIpO1xuXHRcdFx0XHRpZiAoICFvbGQgJiYgb2xkICE9PSBcIm5vbmVcIiApXG5cdFx0XHRcdFx0alF1ZXJ5LmRhdGEodGhpc1tpXSwgXCJvbGRkaXNwbGF5XCIsIGpRdWVyeS5jc3ModGhpc1tpXSwgXCJkaXNwbGF5XCIpKTtcblx0XHRcdFx0dGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gU2F2ZSB0aGUgb2xkIHRvZ2dsZSBmdW5jdGlvblxuXHRfdG9nZ2xlOiBqUXVlcnkuZm4udG9nZ2xlLFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24oIGZuLCBmbjIgKXtcblx0XHR2YXIgYm9vbCA9IHR5cGVvZiBmbiA9PT0gXCJib29sZWFuXCI7XG5cblx0XHRyZXR1cm4galF1ZXJ5LmlzRnVuY3Rpb24oZm4pICYmIGpRdWVyeS5pc0Z1bmN0aW9uKGZuMikgP1xuXHRcdFx0dGhpcy5fdG9nZ2xlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHRmbiA9PSBudWxsIHx8IGJvb2wgP1xuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgc3RhdGUgPSBib29sID8gZm4gOiBqUXVlcnkodGhpcykuaXMoXCI6aGlkZGVuXCIpO1xuXHRcdFx0XHRcdGpRdWVyeSh0aGlzKVsgc3RhdGUgPyBcInNob3dcIiA6IFwiaGlkZVwiIF0oKTtcblx0XHRcdFx0fSkgOlxuXHRcdFx0XHR0aGlzLmFuaW1hdGUoZ2VuRngoXCJ0b2dnbGVcIiwgMyksIGZuLCBmbjIpO1xuXHR9LFxuXG5cdGZhZGVUbzogZnVuY3Rpb24oc3BlZWQsdG8sY2FsbGJhY2spe1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoe29wYWNpdHk6IHRvfSwgc3BlZWQsIGNhbGxiYWNrKTtcblx0fSxcblxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIG9wdGFsbCA9IGpRdWVyeS5zcGVlZChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG5cblx0XHRyZXR1cm4gdGhpc1sgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/IFwiZWFjaFwiIDogXCJxdWV1ZVwiIF0oZnVuY3Rpb24oKXtcblx0XHRcblx0XHRcdHZhciBvcHQgPSBqUXVlcnkuZXh0ZW5kKHt9LCBvcHRhbGwpLCBwLFxuXHRcdFx0XHRoaWRkZW4gPSB0aGlzLm5vZGVUeXBlID09IDEgJiYgalF1ZXJ5KHRoaXMpLmlzKFwiOmhpZGRlblwiKSxcblx0XHRcdFx0c2VsZiA9IHRoaXM7XG5cdFxuXHRcdFx0Zm9yICggcCBpbiBwcm9wICkge1xuXHRcdFx0XHRpZiAoIHByb3BbcF0gPT0gXCJoaWRlXCIgJiYgaGlkZGVuIHx8IHByb3BbcF0gPT0gXCJzaG93XCIgJiYgIWhpZGRlbiApXG5cdFx0XHRcdFx0cmV0dXJuIG9wdC5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0XHRcdGlmICggKCBwID09IFwiaGVpZ2h0XCIgfHwgcCA9PSBcIndpZHRoXCIgKSAmJiB0aGlzLnN0eWxlICkge1xuXHRcdFx0XHRcdC8vIFN0b3JlIGRpc3BsYXkgcHJvcGVydHlcblx0XHRcdFx0XHRvcHQuZGlzcGxheSA9IGpRdWVyeS5jc3ModGhpcywgXCJkaXNwbGF5XCIpO1xuXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0XHRcdFx0b3B0Lm92ZXJmbG93ID0gdGhpcy5zdHlsZS5vdmVyZmxvdztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdC5vdmVyZmxvdyAhPSBudWxsIClcblx0XHRcdFx0dGhpcy5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cblx0XHRcdG9wdC5jdXJBbmltID0galF1ZXJ5LmV4dGVuZCh7fSwgcHJvcCk7XG5cblx0XHRcdGpRdWVyeS5lYWNoKCBwcm9wLCBmdW5jdGlvbihuYW1lLCB2YWwpe1xuXHRcdFx0XHR2YXIgZSA9IG5ldyBqUXVlcnkuZngoIHNlbGYsIG9wdCwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggL3RvZ2dsZXxzaG93fGhpZGUvLnRlc3QodmFsKSApXG5cdFx0XHRcdFx0ZVsgdmFsID09IFwidG9nZ2xlXCIgPyBoaWRkZW4gPyBcInNob3dcIiA6IFwiaGlkZVwiIDogdmFsIF0oIHByb3AgKTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHBhcnRzID0gdmFsLnRvU3RyaW5nKCkubWF0Y2goL14oWystXT0pPyhbXFxkKy0uXSspKC4qKSQvKSxcblx0XHRcdFx0XHRcdHN0YXJ0ID0gZS5jdXIodHJ1ZSkgfHwgMDtcblxuXHRcdFx0XHRcdGlmICggcGFydHMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgZW5kID0gcGFyc2VGbG9hdChwYXJ0c1syXSksXG5cdFx0XHRcdFx0XHRcdHVuaXQgPSBwYXJ0c1szXSB8fCBcInB4XCI7XG5cblx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBzdGFydGluZyB2YWx1ZVxuXHRcdFx0XHRcdFx0aWYgKCB1bml0ICE9IFwicHhcIiApIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5zdHlsZVsgbmFtZSBdID0gKGVuZCB8fCAxKSArIHVuaXQ7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0ID0gKChlbmQgfHwgMSkgLyBlLmN1cih0cnVlKSkgKiBzdGFydDtcblx0XHRcdFx0XHRcdFx0c2VsZi5zdHlsZVsgbmFtZSBdID0gc3RhcnQgKyB1bml0O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0XHRcdGlmICggcGFydHNbMV0gKVxuXHRcdFx0XHRcdFx0XHRlbmQgPSAoKHBhcnRzWzFdID09IFwiLT1cIiA/IC0xIDogMSkgKiBlbmQpICsgc3RhcnQ7XG5cblx0XHRcdFx0XHRcdGUuY3VzdG9tKCBzdGFydCwgZW5kLCB1bml0ICk7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRlLmN1c3RvbSggc3RhcnQsIHZhbCwgXCJcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRm9yIEpTIHN0cmljdCBjb21wbGlhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbihjbGVhclF1ZXVlLCBnb3RvRW5kKXtcblx0XHR2YXIgdGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRcdGlmIChjbGVhclF1ZXVlKVxuXHRcdFx0dGhpcy5xdWV1ZShbXSk7XG5cblx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKXtcblx0XHRcdC8vIGdvIGluIHJldmVyc2Ugb3JkZXIgc28gYW55dGhpbmcgYWRkZWQgdG8gdGhlIHF1ZXVlIGR1cmluZyB0aGUgbG9vcCBpcyBpZ25vcmVkXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRpbWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApXG5cdFx0XHRcdGlmICggdGltZXJzW2ldLmVsZW0gPT0gdGhpcyApIHtcblx0XHRcdFx0XHRpZiAoZ290b0VuZClcblx0XHRcdFx0XHRcdC8vIGZvcmNlIHRoZSBuZXh0IHN0ZXAgdG8gYmUgdGhlIGxhc3Rcblx0XHRcdFx0XHRcdHRpbWVyc1tpXSh0cnVlKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkXG5cdFx0aWYgKCFnb3RvRW5kKVxuXHRcdFx0dGhpcy5kZXF1ZXVlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goe1xuXHRzbGlkZURvd246IGdlbkZ4KFwic2hvd1wiLCAxKSxcblx0c2xpZGVVcDogZ2VuRngoXCJoaWRlXCIsIDEpLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoXCJ0b2dnbGVcIiwgMSksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApe1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgY2FsbGJhY2sgKXtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0c3BlZWQ6IGZ1bmN0aW9uKHNwZWVkLCBlYXNpbmcsIGZuKSB7XG5cdFx0dmFyIG9wdCA9IHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IHNwZWVkIDoge1xuXHRcdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKGVhc2luZykgJiYgZWFzaW5nXG5cdFx0fTtcblxuXHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0XHRqUXVlcnkuZnguc3BlZWRzW29wdC5kdXJhdGlvbl0gfHwgalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHRcdC8vIFF1ZXVlaW5nXG5cdFx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblx0XHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCBvcHQucXVldWUgIT09IGZhbHNlIClcblx0XHRcdFx0alF1ZXJ5KHRoaXMpLmRlcXVldWUoKTtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApXG5cdFx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gb3B0O1xuXHR9LFxuXG5cdGVhc2luZzoge1xuXHRcdGxpbmVhcjogZnVuY3Rpb24oIHAsIG4sIGZpcnN0TnVtLCBkaWZmICkge1xuXHRcdFx0cmV0dXJuIGZpcnN0TnVtICsgZGlmZiAqIHA7XG5cdFx0fSxcblx0XHRzd2luZzogZnVuY3Rpb24oIHAsIG4sIGZpcnN0TnVtLCBkaWZmICkge1xuXHRcdFx0cmV0dXJuICgoLU1hdGguY29zKHAqTWF0aC5QSSkvMikgKyAwLjUpICogZGlmZiArIGZpcnN0TnVtO1xuXHRcdH1cblx0fSxcblxuXHR0aW1lcnM6IFtdLFxuXG5cdGZ4OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCApe1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXG5cdFx0aWYgKCAhb3B0aW9ucy5vcmlnIClcblx0XHRcdG9wdGlvbnMub3JpZyA9IHt9O1xuXHR9XG5cbn0pO1xuXG5qUXVlcnkuZngucHJvdG90eXBlID0ge1xuXG5cdC8vIFNpbXBsZSBmdW5jdGlvbiBmb3Igc2V0dGluZyBhIHN0eWxlIHZhbHVlXG5cdHVwZGF0ZTogZnVuY3Rpb24oKXtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwIClcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblxuXHRcdChqUXVlcnkuZnguc3RlcFt0aGlzLnByb3BdIHx8IGpRdWVyeS5meC5zdGVwLl9kZWZhdWx0KSggdGhpcyApO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gYmxvY2sgZm9yIGhlaWdodC93aWR0aCBhbmltYXRpb25zXG5cdFx0aWYgKCAoIHRoaXMucHJvcCA9PSBcImhlaWdodFwiIHx8IHRoaXMucHJvcCA9PSBcIndpZHRoXCIgKSAmJiB0aGlzLmVsZW0uc3R5bGUgKVxuXHRcdFx0dGhpcy5lbGVtLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjdXJyZW50IHNpemVcblx0Y3VyOiBmdW5jdGlvbihmb3JjZSl7XG5cdFx0aWYgKCB0aGlzLmVsZW1bdGhpcy5wcm9wXSAhPSBudWxsICYmICghdGhpcy5lbGVtLnN0eWxlIHx8IHRoaXMuZWxlbS5zdHlsZVt0aGlzLnByb3BdID09IG51bGwpIClcblx0XHRcdHJldHVybiB0aGlzLmVsZW1bIHRoaXMucHJvcCBdO1xuXG5cdFx0dmFyIHIgPSBwYXJzZUZsb2F0KGpRdWVyeS5jc3ModGhpcy5lbGVtLCB0aGlzLnByb3AsIGZvcmNlKSk7XG5cdFx0cmV0dXJuIHIgJiYgciA+IC0xMDAwMCA/IHIgOiBwYXJzZUZsb2F0KGpRdWVyeS5jdXJDU1ModGhpcy5lbGVtLCB0aGlzLnByb3ApKSB8fCAwO1xuXHR9LFxuXG5cdC8vIFN0YXJ0IGFuIGFuaW1hdGlvbiBmcm9tIG9uZSBudW1iZXIgdG8gYW5vdGhlclxuXHRjdXN0b206IGZ1bmN0aW9uKGZyb20sIHRvLCB1bml0KXtcblx0XHR0aGlzLnN0YXJ0VGltZSA9IG5vdygpO1xuXHRcdHRoaXMuc3RhcnQgPSBmcm9tO1xuXHRcdHRoaXMuZW5kID0gdG87XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCB0aGlzLnVuaXQgfHwgXCJweFwiO1xuXHRcdHRoaXMubm93ID0gdGhpcy5zdGFydDtcblx0XHR0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAwO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGZ1bmN0aW9uIHQoZ290b0VuZCl7XG5cdFx0XHRyZXR1cm4gc2VsZi5zdGVwKGdvdG9FbmQpO1xuXHRcdH1cblxuXHRcdHQuZWxlbSA9IHRoaXMuZWxlbTtcblxuXHRcdGlmICggdCgpICYmIGpRdWVyeS50aW1lcnMucHVzaCh0KSA9PSAxICkge1xuXHRcdFx0dGltZXJJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciB0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApXG5cdFx0XHRcdFx0aWYgKCAhdGltZXJzW2ldKCkgKVxuXHRcdFx0XHRcdFx0dGltZXJzLnNwbGljZShpLS0sIDEpO1xuXG5cdFx0XHRcdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxMyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNpbXBsZSAnc2hvdycgZnVuY3Rpb25cblx0c2hvdzogZnVuY3Rpb24oKXtcblx0XHQvLyBSZW1lbWJlciB3aGVyZSB3ZSBzdGFydGVkLCBzbyB0aGF0IHdlIGNhbiBnbyBiYWNrIHRvIGl0IGxhdGVyXG5cdFx0dGhpcy5vcHRpb25zLm9yaWdbdGhpcy5wcm9wXSA9IGpRdWVyeS5hdHRyKCB0aGlzLmVsZW0uc3R5bGUsIHRoaXMucHJvcCApO1xuXHRcdHRoaXMub3B0aW9ucy5zaG93ID0gdHJ1ZTtcblxuXHRcdC8vIEJlZ2luIHRoZSBhbmltYXRpb25cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSBzdGFydCBhdCBhIHNtYWxsIHdpZHRoL2hlaWdodCB0byBhdm9pZCBhbnlcblx0XHQvLyBmbGFzaCBvZiBjb250ZW50XG5cdFx0dGhpcy5jdXN0b20odGhpcy5wcm9wID09IFwid2lkdGhcIiB8fCB0aGlzLnByb3AgPT0gXCJoZWlnaHRcIiA/IDEgOiAwLCB0aGlzLmN1cigpKTtcblxuXHRcdC8vIFN0YXJ0IGJ5IHNob3dpbmcgdGhlIGVsZW1lbnRcblx0XHRqUXVlcnkodGhpcy5lbGVtKS5zaG93KCk7XG5cdH0sXG5cblx0Ly8gU2ltcGxlICdoaWRlJyBmdW5jdGlvblxuXHRoaWRlOiBmdW5jdGlvbigpe1xuXHRcdC8vIFJlbWVtYmVyIHdoZXJlIHdlIHN0YXJ0ZWQsIHNvIHRoYXQgd2UgY2FuIGdvIGJhY2sgdG8gaXQgbGF0ZXJcblx0XHR0aGlzLm9wdGlvbnMub3JpZ1t0aGlzLnByb3BdID0galF1ZXJ5LmF0dHIoIHRoaXMuZWxlbS5zdHlsZSwgdGhpcy5wcm9wICk7XG5cdFx0dGhpcy5vcHRpb25zLmhpZGUgPSB0cnVlO1xuXG5cdFx0Ly8gQmVnaW4gdGhlIGFuaW1hdGlvblxuXHRcdHRoaXMuY3VzdG9tKHRoaXMuY3VyKCksIDApO1xuXHR9LFxuXG5cdC8vIEVhY2ggc3RlcCBvZiBhbiBhbmltYXRpb25cblx0c3RlcDogZnVuY3Rpb24oZ290b0VuZCl7XG5cdFx0dmFyIHQgPSBub3coKTtcblxuXHRcdGlmICggZ290b0VuZCB8fCB0ID49IHRoaXMub3B0aW9ucy5kdXJhdGlvbiArIHRoaXMuc3RhcnRUaW1lICkge1xuXHRcdFx0dGhpcy5ub3cgPSB0aGlzLmVuZDtcblx0XHRcdHRoaXMucG9zID0gdGhpcy5zdGF0ZSA9IDE7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR0aGlzLm9wdGlvbnMuY3VyQW5pbVsgdGhpcy5wcm9wIF0gPSB0cnVlO1xuXG5cdFx0XHR2YXIgZG9uZSA9IHRydWU7XG5cdFx0XHRmb3IgKCB2YXIgaSBpbiB0aGlzLm9wdGlvbnMuY3VyQW5pbSApXG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmN1ckFuaW1baV0gIT09IHRydWUgKVxuXHRcdFx0XHRcdGRvbmUgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBkb25lICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIG92ZXJmbG93XG5cdFx0XHRcdFx0dGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93ID0gdGhpcy5vcHRpb25zLm92ZXJmbG93O1xuXG5cdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGRpc3BsYXlcblx0XHRcdFx0XHR0aGlzLmVsZW0uc3R5bGUuZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNzcyh0aGlzLmVsZW0sIFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIiApXG5cdFx0XHRcdFx0XHR0aGlzLmVsZW0uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhpZGUgdGhlIGVsZW1lbnQgaWYgdGhlIFwiaGlkZVwiIG9wZXJhdGlvbiB3YXMgZG9uZVxuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5oaWRlIClcblx0XHRcdFx0XHRqUXVlcnkodGhpcy5lbGVtKS5oaWRlKCk7XG5cblx0XHRcdFx0Ly8gUmVzZXQgdGhlIHByb3BlcnRpZXMsIGlmIHRoZSBpdGVtIGhhcyBiZWVuIGhpZGRlbiBvciBzaG93blxuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5oaWRlIHx8IHRoaXMub3B0aW9ucy5zaG93IClcblx0XHRcdFx0XHRmb3IgKCB2YXIgcCBpbiB0aGlzLm9wdGlvbnMuY3VyQW5pbSApXG5cdFx0XHRcdFx0XHRqUXVlcnkuYXR0cih0aGlzLmVsZW0uc3R5bGUsIHAsIHRoaXMub3B0aW9ucy5vcmlnW3BdKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgY29tcGxldGUgZnVuY3Rpb25cblx0XHRcdFx0dGhpcy5vcHRpb25zLmNvbXBsZXRlLmNhbGwoIHRoaXMuZWxlbSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBuID0gdCAtIHRoaXMuc3RhcnRUaW1lO1xuXHRcdFx0dGhpcy5zdGF0ZSA9IG4gLyB0aGlzLm9wdGlvbnMuZHVyYXRpb247XG5cblx0XHRcdC8vIFBlcmZvcm0gdGhlIGVhc2luZyBmdW5jdGlvbiwgZGVmYXVsdHMgdG8gc3dpbmdcblx0XHRcdHRoaXMucG9zID0galF1ZXJ5LmVhc2luZ1t0aGlzLm9wdGlvbnMuZWFzaW5nIHx8IChqUXVlcnkuZWFzaW5nLnN3aW5nID8gXCJzd2luZ1wiIDogXCJsaW5lYXJcIildKHRoaXMuc3RhdGUsIG4sIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvbik7XG5cdFx0XHR0aGlzLm5vdyA9IHRoaXMuc3RhcnQgKyAoKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0aGlzLnBvcyk7XG5cblx0XHRcdC8vIFBlcmZvcm0gdGhlIG5leHQgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cbn07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5meCwge1xuXHRzcGVlZHM6e1xuXHRcdHNsb3c6IDYwMCxcbiBcdFx0ZmFzdDogMjAwLFxuIFx0XHQvLyBEZWZhdWx0IHNwZWVkXG4gXHRcdF9kZWZhdWx0OiA0MDBcblx0fSxcblx0c3RlcDoge1xuXG5cdFx0b3BhY2l0eTogZnVuY3Rpb24oZngpe1xuXHRcdFx0alF1ZXJ5LmF0dHIoZnguZWxlbS5zdHlsZSwgXCJvcGFjaXR5XCIsIGZ4Lm5vdyk7XG5cdFx0fSxcblxuXHRcdF9kZWZhdWx0OiBmdW5jdGlvbihmeCl7XG5cdFx0XHRpZiAoIGZ4LmVsZW0uc3R5bGUgJiYgZnguZWxlbS5zdHlsZVsgZngucHJvcCBdICE9IG51bGwgKVxuXHRcdFx0XHRmeC5lbGVtLnN0eWxlWyBmeC5wcm9wIF0gPSBmeC5ub3cgKyBmeC51bml0O1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRmeC5lbGVtWyBmeC5wcm9wIF0gPSBmeC5ub3c7XG5cdFx0fVxuXHR9XG59KTtcbmlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCJdIClcblx0alF1ZXJ5LmZuLm9mZnNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbMF0gKSByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHRpZiAoIHRoaXNbMF0gPT09IHRoaXNbMF0ub3duZXJEb2N1bWVudC5ib2R5ICkgcmV0dXJuIGpRdWVyeS5vZmZzZXQuYm9keU9mZnNldCggdGhpc1swXSApO1xuXHRcdHZhciBib3ggID0gdGhpc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9jID0gdGhpc1swXS5vd25lckRvY3VtZW50LCBib2R5ID0gZG9jLmJvZHksIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0Y2xpZW50VG9wID0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCwgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcblx0XHRcdHRvcCAgPSBib3gudG9wICArIChzZWxmLnBhZ2VZT2Zmc2V0IHx8IGpRdWVyeS5ib3hNb2RlbCAmJiBkb2NFbGVtLnNjcm9sbFRvcCAgfHwgYm9keS5zY3JvbGxUb3AgKSAtIGNsaWVudFRvcCxcblx0XHRcdGxlZnQgPSBib3gubGVmdCArIChzZWxmLnBhZ2VYT2Zmc2V0IHx8IGpRdWVyeS5ib3hNb2RlbCAmJiBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0KSAtIGNsaWVudExlZnQ7XG5cdFx0cmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcblx0fTtcbmVsc2UgXG5cdGpRdWVyeS5mbi5vZmZzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWzBdICkgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0aWYgKCB0aGlzWzBdID09PSB0aGlzWzBdLm93bmVyRG9jdW1lbnQuYm9keSApIHJldHVybiBqUXVlcnkub2Zmc2V0LmJvZHlPZmZzZXQoIHRoaXNbMF0gKTtcblx0XHRqUXVlcnkub2Zmc2V0LmluaXRpYWxpemVkIHx8IGpRdWVyeS5vZmZzZXQuaW5pdGlhbGl6ZSgpO1xuXG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdLCBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCwgcHJldk9mZnNldFBhcmVudCA9IGVsZW0sXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsIGNvbXB1dGVkU3R5bGUsIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0Ym9keSA9IGRvYy5ib2R5LCBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0Vmlldyxcblx0XHRcdHByZXZDb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSxcblx0XHRcdHRvcCA9IGVsZW0ub2Zmc2V0VG9wLCBsZWZ0ID0gZWxlbS5vZmZzZXRMZWZ0O1xuXG5cdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbSAhPT0gYm9keSAmJiBlbGVtICE9PSBkb2NFbGVtICkge1xuXHRcdFx0Y29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XG5cdFx0XHR0b3AgLT0gZWxlbS5zY3JvbGxUb3AsIGxlZnQgLT0gZWxlbS5zY3JvbGxMZWZ0O1xuXHRcdFx0aWYgKCBlbGVtID09PSBvZmZzZXRQYXJlbnQgKSB7XG5cdFx0XHRcdHRvcCArPSBlbGVtLm9mZnNldFRvcCwgbGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG5cdFx0XHRcdGlmICggalF1ZXJ5Lm9mZnNldC5kb2VzTm90QWRkQm9yZGVyICYmICEoalF1ZXJ5Lm9mZnNldC5kb2VzQWRkQm9yZGVyRm9yVGFibGVBbmRDZWxscyAmJiAvXnQoYWJsZXxkfGgpJC9pLnRlc3QoZWxlbS50YWdOYW1lKSkgKVxuXHRcdFx0XHRcdHRvcCAgKz0gcGFyc2VJbnQoIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsICAxMCkgfHwgMCxcblx0XHRcdFx0XHRsZWZ0ICs9IHBhcnNlSW50KCBjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDA7XG5cdFx0XHRcdHByZXZPZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQsIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkub2Zmc2V0LnN1YnRyYWN0c0JvcmRlckZvck92ZXJmbG93Tm90VmlzaWJsZSAmJiBjb21wdXRlZFN0eWxlLm92ZXJmbG93ICE9PSBcInZpc2libGVcIiApXG5cdFx0XHRcdHRvcCAgKz0gcGFyc2VJbnQoIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsICAxMCkgfHwgMCxcblx0XHRcdFx0bGVmdCArPSBwYXJzZUludCggY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuXHRcdFx0cHJldkNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuXHRcdH1cblxuXHRcdGlmICggcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApXG5cdFx0XHR0b3AgICs9IGJvZHkub2Zmc2V0VG9wLFxuXHRcdFx0bGVmdCArPSBib2R5Lm9mZnNldExlZnQ7XG5cblx0XHRpZiAoIHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIgKVxuXHRcdFx0dG9wICArPSBNYXRoLm1heChkb2NFbGVtLnNjcm9sbFRvcCwgYm9keS5zY3JvbGxUb3ApLFxuXHRcdFx0bGVmdCArPSBNYXRoLm1heChkb2NFbGVtLnNjcm9sbExlZnQsIGJvZHkuc2Nyb2xsTGVmdCk7XG5cblx0XHRyZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuXHR9O1xuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuaW5pdGlhbGl6ZWQgKSByZXR1cm47XG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgaW5uZXJEaXYsIGNoZWNrRGl2LCB0YWJsZSwgdGQsIHJ1bGVzLCBwcm9wLCBib2R5TWFyZ2luVG9wID0gYm9keS5zdHlsZS5tYXJnaW5Ub3AsXG5cdFx0XHRodG1sID0gJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7bWFyZ2luOjA7Ym9yZGVyOjVweCBzb2xpZCAjMDAwO3BhZGRpbmc6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDtcIj48ZGl2PjwvZGl2PjwvZGl2Pjx0YWJsZSBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDttYXJnaW46MDtib3JkZXI6NXB4IHNvbGlkICMwMDA7cGFkZGluZzowO3dpZHRoOjFweDtoZWlnaHQ6MXB4O1wiIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiPjx0cj48dGQ+PC90ZD48L3RyPjwvdGFibGU+JztcblxuXHRcdHJ1bGVzID0geyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAwLCBsZWZ0OiAwLCBtYXJnaW46IDAsIGJvcmRlcjogMCwgd2lkdGg6ICcxcHgnLCBoZWlnaHQ6ICcxcHgnLCB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9O1xuXHRcdGZvciAoIHByb3AgaW4gcnVsZXMgKSBjb250YWluZXIuc3R5bGVbcHJvcF0gPSBydWxlc1twcm9wXTtcblxuXHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXHRcdGJvZHkuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgYm9keS5maXJzdENoaWxkKTtcblx0XHRpbm5lckRpdiA9IGNvbnRhaW5lci5maXJzdENoaWxkLCBjaGVja0RpdiA9IGlubmVyRGl2LmZpcnN0Q2hpbGQsIHRkID0gaW5uZXJEaXYubmV4dFNpYmxpbmcuZmlyc3RDaGlsZC5maXJzdENoaWxkO1xuXG5cdFx0dGhpcy5kb2VzTm90QWRkQm9yZGVyID0gKGNoZWNrRGl2Lm9mZnNldFRvcCAhPT0gNSk7XG5cdFx0dGhpcy5kb2VzQWRkQm9yZGVyRm9yVGFibGVBbmRDZWxscyA9ICh0ZC5vZmZzZXRUb3AgPT09IDUpO1xuXG5cdFx0aW5uZXJEaXYuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJywgaW5uZXJEaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHRcdHRoaXMuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlID0gKGNoZWNrRGl2Lm9mZnNldFRvcCA9PT0gLTUpO1xuXG5cdFx0Ym9keS5zdHlsZS5tYXJnaW5Ub3AgPSAnMXB4Jztcblx0XHR0aGlzLmRvZXNOb3RJbmNsdWRlTWFyZ2luSW5Cb2R5T2Zmc2V0ID0gKGJvZHkub2Zmc2V0VG9wID09PSAwKTtcblx0XHRib2R5LnN0eWxlLm1hcmdpblRvcCA9IGJvZHlNYXJnaW5Ub3A7XG5cblx0XHRib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG5cdFx0dGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG5cdH0sXG5cblx0Ym9keU9mZnNldDogZnVuY3Rpb24oYm9keSkge1xuXHRcdGpRdWVyeS5vZmZzZXQuaW5pdGlhbGl6ZWQgfHwgalF1ZXJ5Lm9mZnNldC5pbml0aWFsaXplKCk7XG5cdFx0dmFyIHRvcCA9IGJvZHkub2Zmc2V0VG9wLCBsZWZ0ID0gYm9keS5vZmZzZXRMZWZ0O1xuXHRcdGlmICggalF1ZXJ5Lm9mZnNldC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCApXG5cdFx0XHR0b3AgICs9IHBhcnNlSW50KCBqUXVlcnkuY3VyQ1NTKGJvZHksICdtYXJnaW5Ub3AnLCAgdHJ1ZSksIDEwICkgfHwgMCxcblx0XHRcdGxlZnQgKz0gcGFyc2VJbnQoIGpRdWVyeS5jdXJDU1MoYm9keSwgJ21hcmdpbkxlZnQnLCB0cnVlKSwgMTAgKSB8fCAwO1xuXHRcdHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG5cdH1cbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVmdCA9IDAsIHRvcCA9IDAsIHJlc3VsdHM7XG5cblx0XHRpZiAoIHRoaXNbMF0gKSB7XG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCksXG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSAvXmJvZHl8aHRtbCQvaS50ZXN0KG9mZnNldFBhcmVudFswXS50YWdOYW1lKSA/IHsgdG9wOiAwLCBsZWZ0OiAwIH0gOiBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cblx0XHRcdC8vIFN1YnRyYWN0IGVsZW1lbnQgbWFyZ2luc1xuXHRcdFx0Ly8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnQgXG5cdFx0XHQvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuXHRcdFx0b2Zmc2V0LnRvcCAgLT0gbnVtKCB0aGlzLCAnbWFyZ2luVG9wJyAgKTtcblx0XHRcdG9mZnNldC5sZWZ0IC09IG51bSggdGhpcywgJ21hcmdpbkxlZnQnICk7XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCAgKz0gbnVtKCBvZmZzZXRQYXJlbnQsICdib3JkZXJUb3BXaWR0aCcgICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBudW0oIG9mZnNldFBhcmVudCwgJ2JvcmRlckxlZnRXaWR0aCcgKTtcblxuXHRcdFx0Ly8gU3VidHJhY3QgdGhlIHR3byBvZmZzZXRzXG5cdFx0XHRyZXN1bHRzID0ge1xuXHRcdFx0XHR0b3A6ICBvZmZzZXQudG9wICAtIHBhcmVudE9mZnNldC50b3AsXG5cdFx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH0sXG5cblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpc1swXS5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuYm9keTtcblx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoIS9eYm9keXxodG1sJC9pLnRlc3Qob2Zmc2V0UGFyZW50LnRhZ05hbWUpICYmIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PSAnc3RhdGljJykgKVxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRyZXR1cm4galF1ZXJ5KG9mZnNldFBhcmVudCk7XG5cdH1cbn0pO1xuXG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIFsnTGVmdCcsICdUb3AnXSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuXHR2YXIgbWV0aG9kID0gJ3Njcm9sbCcgKyBuYW1lO1xuXHRcblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKHZhbCkge1xuXHRcdGlmICghdGhpc1swXSkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0XHQvLyBTZXQgdGhlIHNjcm9sbCBvZmZzZXRcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcyA9PSB3aW5kb3cgfHwgdGhpcyA9PSBkb2N1bWVudCA/XG5cdFx0XHRcdFx0d2luZG93LnNjcm9sbFRvKFxuXHRcdFx0XHRcdFx0IWkgPyB2YWwgOiBqUXVlcnkod2luZG93KS5zY3JvbGxMZWZ0KCksXG5cdFx0XHRcdFx0XHQgaSA/IHZhbCA6IGpRdWVyeSh3aW5kb3cpLnNjcm9sbFRvcCgpXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0dGhpc1sgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9KSA6XG5cblx0XHRcdC8vIFJldHVybiB0aGUgc2Nyb2xsIG9mZnNldFxuXHRcdFx0dGhpc1swXSA9PSB3aW5kb3cgfHwgdGhpc1swXSA9PSBkb2N1bWVudCA/XG5cdFx0XHRcdHNlbGZbIGkgPyAncGFnZVlPZmZzZXQnIDogJ3BhZ2VYT2Zmc2V0JyBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmJveE1vZGVsICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgbWV0aG9kIF0gfHxcblx0XHRcdFx0XHRkb2N1bWVudC5ib2R5WyBtZXRob2QgXSA6XG5cdFx0XHRcdHRoaXNbMF1bIG1ldGhvZCBdO1xuXHR9O1xufSk7XG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKFsgXCJIZWlnaHRcIiwgXCJXaWR0aFwiIF0sIGZ1bmN0aW9uKGksIG5hbWUpe1xuXG5cdHZhciB0bCA9IGkgPyBcIkxlZnRcIiAgOiBcIlRvcFwiLCAgLy8gdG9wIG9yIGxlZnRcblx0XHRiciA9IGkgPyBcIlJpZ2h0XCIgOiBcIkJvdHRvbVwiOyAvLyBib3R0b20gb3IgcmlnaHRcblxuXHQvLyBpbm5lckhlaWdodCBhbmQgaW5uZXJXaWR0aFxuXHRqUXVlcnkuZm5bXCJpbm5lclwiICsgbmFtZV0gPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSgpICtcblx0XHRcdG51bSh0aGlzLCBcInBhZGRpbmdcIiArIHRsKSArXG5cdFx0XHRudW0odGhpcywgXCJwYWRkaW5nXCIgKyBicik7XG5cdH07XG5cblx0Ly8gb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGhcblx0alF1ZXJ5LmZuW1wib3V0ZXJcIiArIG5hbWVdID0gZnVuY3Rpb24obWFyZ2luKSB7XG5cdFx0cmV0dXJuIHRoaXNbXCJpbm5lclwiICsgbmFtZV0oKSArXG5cdFx0XHRudW0odGhpcywgXCJib3JkZXJcIiArIHRsICsgXCJXaWR0aFwiKSArXG5cdFx0XHRudW0odGhpcywgXCJib3JkZXJcIiArIGJyICsgXCJXaWR0aFwiKSArXG5cdFx0XHQobWFyZ2luID9cblx0XHRcdFx0bnVtKHRoaXMsIFwibWFyZ2luXCIgKyB0bCkgKyBudW0odGhpcywgXCJtYXJnaW5cIiArIGJyKSA6IDApO1xuXHR9O1xuXHRcblx0dmFyIHR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHQvLyBHZXQgd2luZG93IHdpZHRoIG9yIGhlaWdodFxuXHRcdHJldHVybiB0aGlzWzBdID09IHdpbmRvdyA/XG5cdFx0XHQvLyBFdmVyeW9uZSBlbHNlIHVzZSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgb3IgZG9jdW1lbnQuYm9keSBkZXBlbmRpbmcgb24gUXVpcmtzIHZzIFN0YW5kYXJkcyBtb2RlXG5cdFx0XHRkb2N1bWVudC5jb21wYXRNb2RlID09IFwiQ1NTMUNvbXBhdFwiICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXSB8fFxuXHRcdFx0ZG9jdW1lbnQuYm9keVsgXCJjbGllbnRcIiArIG5hbWUgXSA6XG5cblx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdHRoaXNbMF0gPT0gZG9jdW1lbnQgP1xuXHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0sIHdoaWNoZXZlciBpcyBncmVhdGVyXG5cdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiICsgbmFtZV0sXG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keVtcInNjcm9sbFwiICsgbmFtZV0sIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcInNjcm9sbFwiICsgbmFtZV0sXG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keVtcIm9mZnNldFwiICsgbmFtZV0sIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcIm9mZnNldFwiICsgbmFtZV1cblx0XHRcdFx0KSA6XG5cblx0XHRcdFx0Ly8gR2V0IG9yIHNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0c2l6ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0KHRoaXMubGVuZ3RoID8galF1ZXJ5LmNzcyggdGhpc1swXSwgdHlwZSApIDogbnVsbCkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHRoZSB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQgKGRlZmF1bHQgdG8gcGl4ZWxzIGlmIHZhbHVlIGlzIHVuaXRsZXNzKVxuXHRcdFx0XHRcdHRoaXMuY3NzKCB0eXBlLCB0eXBlb2Ygc2l6ZSA9PT0gXCJzdHJpbmdcIiA/IHNpemUgOiBzaXplICsgXCJweFwiICk7XG5cdH07XG5cbn0pO30pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3B1YmxpYy91bml0L2pxdWVyeS0xLjMuMS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),

/***/ 9:
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(2);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tbW9uLmpzPzgzOWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIuLy4uLy4uL3B1YmxpYy91bml0L2pxdWVyeS0xLjMuMS5qc1wiKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ })

/******/ });